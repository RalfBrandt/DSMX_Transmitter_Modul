FILE: .\boot.asm                        (0001) ;  Generated by PSoC Designer 5.4.3191
                                        (0002) ;
                                        (0003) ;@Id: boot.tpl#903 @
                                        (0004) ;=============================================================================
                                        (0005) ;  FILENAME:   boot.asm
                                        (0006) ;  Version:    4.30
                                        (0007) ;
                                        (0008) ;  DESCRIPTION:
                                        (0009) ;  M8C Boot Code for CY8C21x34 microcontroller devices.
                                        (0010) ;
                                        (0011) ;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0012) ;
                                        (0013) ; NOTES:
                                        (0014) ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
                                        (0015) ; the project's root directory to create BOOT.ASM. Any changes made to
                                        (0016) ; BOOT.ASM will be  overwritten every time the project is generated; therefore
                                        (0017) ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
                                        (0018) ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
                                        (0019) ; are not accidentally modified.
                                        (0020) ;
                                        (0021) ;=============================================================================
                                        (0022) 
                                        (0023) include ".\lib\GlobalParams.inc"	;File generated by PSoC Designer (Project dependent)
                                        (0024) include "m8c.inc"			;Part specific file
                                        (0025) include "m8ssc.inc"			;Part specific file
                                        (0026) include "memory.inc"			;File generated by PSoC Designer (Project dependent)
                                        (0027) 
                                        (0028) ;--------------------------------------
                                        (0029) ; Export Declarations
                                        (0030) ;--------------------------------------
                                        (0031) 
                                        (0032) export __Start
                                        (0033) IF	(TOOLCHAIN & HITECH)
                                        (0034) ELSE
                                        (0035) export __bss_start
                                        (0036) export __data_start
                                        (0037) export __idata_start
                                        (0038) export __func_lit_start
                                        (0039) export __text_start
                                        (0040) ENDIF
                                        (0041) export  _bGetPowerSetting
                                        (0042) export   bGetPowerSetting
                                        (0043) 
                                        (0044) 
                                        (0045) ;--------------------------------------
                                        (0046) ; Optimization flags
                                        (0047) ;--------------------------------------
                                        (0048) ;
                                        (0049) ; To change the value of these flags, modify the file boot.tpl, not
                                        (0050) ; boot.asm. See the notes in the banner comment at the beginning of
                                        (0051) ; this file.
                                        (0052) 
                                        (0053) ; Optimization for Assembly language (only) projects and C-language projects
                                        (0054) ; that do not depend on the C compiler to initialize the values of RAM variables.
                                        (0055) ;   Set to 1: Support for C Run-time Environment initialization
                                        (0056) ;   Set to 0: Support for C not included. Faster start up, smaller code space.
                                        (0057) ;
                                        (0058) IF	(TOOLCHAIN & HITECH)
                                        (0059) ; The C compiler will customize the startup code - it's not required here
                                        (0060) 
                                        (0061) C_LANGUAGE_SUPPORT:              equ 0
                                        (0062) ELSE
                                        (0063) C_LANGUAGE_SUPPORT:              equ 1
                                        (0064) ENDIF
                                        (0065) 
                                        (0066) 
                                        (0067) ; For historical reasons, by default the boot code uses an lcall instruction
                                        (0068) ; to invoke the user's _main code. If _main executes a return instruction,
                                        (0069) ; boot provides an infinite loop. By changing the following equate from zero
                                        (0070) ; to 1, boot's lcall will be replaced by a ljmp instruction, saving two
                                        (0071) ; bytes on the stack which are otherwise required for the return address. If
                                        (0072) ; this option is enabled, _main must not return. (Beginning with the 4.2
                                        (0073) ; release, the C compiler automatically places an infinite loop at the end
                                        (0074) ; of main, rather than a return instruction.)
                                        (0075) ;
                                        (0076) ENABLE_LJMP_TO_MAIN:             equ 0
                                        (0077) 
                                        (0078) 
                                        (0079) ;-----------------------------------------------------------------------------
                                        (0080) ; Interrupt Vector Table
                                        (0081) ;-----------------------------------------------------------------------------
                                        (0082) ;
                                        (0083) ; Interrupt vector table entries are 4 bytes long.  Each one contains
                                        (0084) ; a jump instruction to an ISR (Interrupt Service Routine), although
                                        (0085) ; very short ISRs could be encoded within the table itself. Normally,
                                        (0086) ; vector jump targets are modified automatically according to the user
                                        (0087) ; modules selected. This occurs when the 'Generate Application' opera-
                                        (0088) ; tion is run causing PSoC Designer to create boot.asm and the other
                                        (0089) ; configuration files. If you need to hard code a vector, update the
                                        (0090) ; file boot.tpl, not boot.asm. See the banner comment at the beginning
                                        (0091) ; of this file.
                                        (0092) ;-----------------------------------------------------------------------------
                                        (0093) 
                                        (0094)     AREA TOP (ROM, ABS, CON)
                                        (0095) 
                                        (0096)     org   0                        ;Reset Interrupt Vector
                                        (0097) IF	(TOOLCHAIN & HITECH)
                                        (0098) ;   jmp   __Start                  ;C compiler fills in this vector
                                        (0099) ELSE
0000: 80 67    JMP   0x0068             (0100)     jmp   __Start                  ;First instruction executed following a Reset
                                        (0101) ENDIF
                                        (0102)     ;@PSoC_BOOT_ISR_UserCode_START@
                                        (0103)     ;---------------------------------------------------
                                        (0104)     ; Insert your custom code below this banner
                                        (0105)     ;---------------------------------------------------
                                        (0106) 
                                        (0107)     org   04h                      ;Low Voltage Detect (LVD) Interrupt Vector
0004: 30       HALT                     (0108)     halt                           ;Stop execution if power falls too low
                                        (0109) 
                                        (0110)     org   08h                      ;Analog Column 0 Interrupt Vector
                                        (0111)     // call	void_handler
0008: 7E       RETI                     (0112)     reti
                                        (0113) 
                                        (0114)     org   0Ch                      ;Analog Column 1 Interrupt Vector
                                        (0115)     // call	void_handler
000C: 7E       RETI                     (0116)     reti
                                        (0117) 
                                        (0118)     org   18h                      ;VC3 Interrupt Vector
                                        (0119)     // call	void_handler
0018: 7E       RETI                     (0120)     reti
                                        (0121) 
                                        (0122)     org   1Ch                      ;GPIO Interrupt Vector
001C: 7D 1D 6D LJMP  PSoC_GPIO_ISR      (0123)     ljmp	PSoC_GPIO_ISR
001F: 7E       RETI                     (0124)     reti
                                        (0125) 
                                        (0126)     org   20h                      ;PSoC Block DBB00 Interrupt Vector
                                        (0127)     // call	void_handler
0020: 7E       RETI                     (0128)     reti
                                        (0129) 
                                        (0130)     org   24h                      ;PSoC Block DBB01 Interrupt Vector
0024: 7D 05 48 LJMP  CS_PIN_GetState|_Counter16_1_ISR|CS_PIN_Invert(0131)     ljmp	_Counter16_1_ISR
0027: 7E       RETI                     (0132)     reti
                                        (0133) 
                                        (0134)     org   28h                      ;PSoC Block DCB02 Interrupt Vector
                                        (0135)     // call	void_handler
0028: 7E       RETI                     (0136)     reti
                                        (0137) 
                                        (0138)     org   2Ch                      ;PSoC Block DCB03 Interrupt Vector
002C: 7D 04 D2 LJMP  _SleepTimer_1_iGetTickCntr|_SleepTimer_1_bGetTimer|_SleepTimer_1_SetTimer|_SleepTimer_1_SyncWait|_RX8_1_ISR|_SleepTimer_1_bGetTickCntr(0139)     ljmp	_RX8_1_ISR
002F: 7E       RETI                     (0140)     reti
                                        (0141) 
                                        (0142)     org   60h                      ;PSoC I2C Interrupt Vector
                                        (0143)     // call	void_handler
0060: 7E       RETI                     (0144)     reti
                                        (0145) 
                                        (0146)     org   64h                      ;Sleep Timer Interrupt Vector
0064: 7D 04 97 LJMP  _SleepTimer_1_ISR  (0147)     ljmp	_SleepTimer_1_ISR
0067: 7E       RETI                     (0148)     reti
0068: 71 10    OR    F,0x10             
                                        (0149)     ;---------------------------------------------------
                                        (0150)     ; Insert your custom code above this banner
                                        (0151)     ;---------------------------------------------------
                                        (0152)     ;@PSoC_BOOT_ISR_UserCode_END@
                                        (0153) 
                                        (0154) ;-----------------------------------------------------------------------------
                                        (0155) ;  Start of Execution.
                                        (0156) ;-----------------------------------------------------------------------------
                                        (0157) ;  The Supervisory ROM SWBootReset function has already completed the
                                        (0158) ;  calibrate1 process, loading trim values for 5 volt operation.
                                        (0159) ;
                                        (0160) 
                                        (0161) IF	(TOOLCHAIN & HITECH)
                                        (0162)  	AREA PD_startup(CODE, REL, CON)
                                        (0163) ELSE
                                        (0164)     org 68h
                                        (0165) ENDIF
                                        (0166) __Start:
                                        (0167) 
                                        (0168)     ; initialize SMP values for voltage stabilization, if required,
                                        (0169)     ; leaving power-on reset (POR) level at the default (low) level, at
                                        (0170)     ; least for now. 
                                        (0171)     ;
                                        (0172)     M8C_SetBank1
006A: 62 E3 80 MOV   REG[0xE3],0x80     (0173)     mov   reg[VLT_CR], SWITCH_MODE_PUMP_JUST | LVD_TBEN_JUST | TRIP_VOLTAGE_JUST
006D: 70 EF    AND   F,0xEF             
006F: 62 E3 38 MOV   REG[0xE3],0x38     
                                        (0174)     M8C_SetBank0
                                        (0175) 
                                        (0176) M8C_ClearWDTAndSleep			   ; Clear WDT before enabling it.
                                        (0177) IF ( WATCHDOG_ENABLE )             ; WDT selected in Global Params
                                        (0178)     M8C_EnableWatchDog
                                        (0179) ENDIF
                                        (0180) 
0072: 41 FE FB AND   REG[0xFE],0xFB     (0181)     and  reg[CPU_SCR1], ~CPU_SCR1_ECO_ALLOWED  ; Prevent ECO from being enabled
                                        (0182) 
                                        (0183)     ;---------------------------
                                        (0184)     ; Set up the Temporary stack
                                        (0185)     ;---------------------------
                                        (0186)     ; A temporary stack is set up for the SSC instructions.
                                        (0187)     ; The real stack start will be assigned later.
                                        (0188)     ;
                                        (0189) _stack_start:          equ 80h
0075: 50 80    MOV   A,0x80             (0190)     mov   A, _stack_start          ; Set top of stack to end of used RAM
0077: 4E       SWAP  SP,A               (0191)     swap  SP, A                    ; This is only temporary if going to LMM
0078: 62 E3 38 MOV   REG[0xE3],0x38     
007B: 5D D0    MOV   A,REG[0xD0]        
007D: 08       PUSH  A                  
007E: 62 D0 00 MOV   REG[0xD0],0x0      
0081: 55 FA 01 MOV   [_ramareas_end+99],0x1
0084: 4F       MOV   X,SP               
0085: 5B       MOV   A,X                
0086: 01 03    ADD   A,0x3              
0088: 53 F9    MOV   [_ramareas_end+98],A
008A: 55 F8 3A MOV   [_ramareas_end+97],0x3A
008D: 50 06    MOV   A,0x6              
008F: 00       SWI                      
0090: 71 10    OR    F,0x10             
0092: 51 F9    MOV   A,[_ramareas_end+98]
0094: 60 E8    MOV   REG[0xE8],A        
0096: 51 F8    MOV   A,[_ramareas_end+97]
0098: 60 EA    MOV   REG[0xEA],A        
009A: 70 EF    AND   F,0xEF             
009C: 18       POP   A                  
009D: 60 D0    MOV   REG[0xD0],A        
                                        (0192) 
                                        (0193)     ;------------------------
                                        (0194)     ; Set Power-related Trim 
                                        (0195)     ;------------------------
                                        (0196)     
                                        (0197) M8C_ClearWDTAndSleep
                                        (0198) 
                                        (0199) IF ( POWER_SETTING & POWER_SET_5V0)            ; *** 5.0 Volt operation   ***
                                        (0200)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                        (0201)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0202)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_5V_6MHZ, 1, SSCTBL1_TRIM_BGR_5V
                                        (0203)  ENDIF
                                        (0204) ENDIF ; 5.0 V Operation
                                        (0205) 
                                        (0206) IF ( POWER_SETTING & POWER_SET_3V3)            ; *** 3.3 Volt operation   ***
                                        (0207)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                        (0208)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0209)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_3V_6MHZ, 1, SSCTBL1_TRIM_BGR_3V
                                        (0210)  ELSE                                          ; *** 12MHZ Main Oscillator ***
                                        (0211)     M8SSC_SetTableTrims  1, SSCTBL1_TRIM_IMO_3V_24MHZ, SSCTBL1_TRIM_BGR_3V
                                        (0212)  ENDIF
                                        (0213) ENDIF ; 3.3 Volt Operation
                                        (0214) 
                                        (0215) IF ( POWER_SETTING & POWER_SET_2V7_12MHZ)      ; *** 2.7 Volts / 12MHZ operation ***
                                        (0216)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0217)     M8SSC_SetTableTrims  2, SSCTBL2_TRIM_IMO_2V_12MHZ, SSCTBL2_TRIM_BGR_2V
                                        (0218) ENDIF ; *** 2.7 Volts / 12MHZ operation ***
                                        (0219) 
                                        (0220) IF ( POWER_SETTING & POWER_SET_2V7_6MHZ)       ; *** 2.7 Volts /  6MHZ operation ***
                                        (0221)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0222)     M8SSC_SetTableTrims  2, SSCTBL2_TRIM_IMO_2V_6MHZ,  SSCTBL2_TRIM_BGR_2V
                                        (0223) ENDIF ; *** 2.7 Volts /  6MHZ operation ***
                                        (0224) 
009F: 55 F8 00 MOV   [_ramareas_end+97],0x0(0225)     mov  [bSSC_KEY1],  0           ; Lock out Flash and Supervisiory operations
00A2: 55 F9 00 MOV   [_ramareas_end+98],0x0(0226)     mov  [bSSC_KEYSP], 0
00A5: 71 10    OR    F,0x10             
                                        (0227) 
                                        (0228)     ;---------------------------------------
                                        (0229)     ; Initialize Crystal Oscillator and PLL
                                        (0230)     ;---------------------------------------
                                        (0231) IF ( POWER_SETTING & POWER_SET_2V7)       ; *** 2.7 Volts  ***
                                        (0232)     M8C_SetBank1
                                        (0233)     mov   reg[OSC_CR0], (SLEEP_TIMER_JUST | OSC_CR0_CPU_3MHz)
                                        (0234)     M8C_SetBank0
                                        (0235)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                        (0236) 
                                        (0237) ELSE 	 ;*** all other voltages OK for 12Mhz ***
                                        (0238)     M8C_SetBank1
00A7: 62 E0 02 MOV   REG[0xE0],0x2      (0239)     mov   reg[OSC_CR0], (SLEEP_TIMER_JUST | OSC_CR0_CPU_12MHz)
00AA: 70 EF    AND   F,0xEF             
00AC: 62 E3 38 MOV   REG[0xE3],0x38     
                                        (0240)     M8C_SetBank0
                                        (0241)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                        (0242) 
                                        (0243) ENDIF
                                        (0244) 
                                        (0245) 	;-------------------------------------------------------
                                        (0246)     ; Initialize Proper Drive Mode for External Clock Pin
                                        (0247)     ;-------------------------------------------------------
                                        (0248) 
                                        (0249)     ; Change EXTCLK pin from Hi-Z Analog (110b) drive mode to Hi-Z (010b) drive mode
                                        (0250) 
                                        (0251) IF (SYSCLK_SOURCE)
                                        (0252)     and reg[PRT1DM2],  ~0x10        ; Clear bit 4 of EXTCLK pin's DM2 register 
                                        (0253) ENDIF
                                        (0254)     ; EXTCLK pin is now in proper drive mode to input the external clock signal
                                        (0255) 
                                        (0256) IF	(TOOLCHAIN & HITECH)
                                        (0257)     ;---------------------------------------------
                                        (0258)     ; HI-TECH initialization: Enter the Large Memory Model, if applicable
                                        (0259)     ;---------------------------------------------
                                        (0260) 	global		__Lstackps
                                        (0261) 	mov     a,low __Lstackps
                                        (0262) 	swap    a,sp
                                        (0263) 
                                        (0264) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0265)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
                                        (0266)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
                                        (0267)     RAM_SETPAGE_CUR 0
                                        (0268)     RAM_SETPAGE_MVW 0
                                        (0269)     RAM_SETPAGE_MVR 0
                                        (0270)     IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
                                        (0271)       or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                        (0272)     ELSE
                                        (0273)       or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                        (0274)     ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                        (0275) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                                        (0276) ELSE
                                        (0277)     ;---------------------------------------------
                                        (0278)     ; ImageCraft Enter the Large Memory Model, if applicable
                                        (0279)     ;---------------------------------------------
                                        (0280) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0281)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
                                        (0282)     mov   A, SYSTEM_STACK_BASE_ADDR        ;   and offset, if any
                                        (0283)     swap  A, SP
                                        (0284)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
                                        (0285)     RAM_SETPAGE_CUR 0
                                        (0286)     RAM_SETPAGE_MVW 0
                                        (0287)     RAM_SETPAGE_MVR 0
                                        (0288) 
                                        (0289)   IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
                                        (0290)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                        (0291)   ELSE
                                        (0292)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                        (0293)   ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                        (0294) ELSE
00AF: 50 97    MOV   A,0x97             (0295)     mov   A, __ramareas_end        ; Set top of stack to end of used RAM
00B1: 4E       SWAP  SP,A               (0296)     swap  SP, A
                                        (0297) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                                        (0298) ENDIF ;	TOOLCHAIN
                                        (0299) 
                                        (0300)     ;@PSoC_BOOT_LOADCFG_UserCode_START@
                                        (0301)     ;---------------------------------------------------
                                        (0302)     ; Insert your custom code below this banner
                                        (0303)     ;---------------------------------------------------
                                        (0304) 
                                        (0305)     ;---------------------------------------------------
                                        (0306)     ; Insert your custom code above this banner
                                        (0307)     ;---------------------------------------------------
                                        (0308)     ;@PSoC_BOOT_LOADCFG_UserCode_END@ 
                                        (0309) 
                                        (0310)     ;-------------------------
                                        (0311)     ; Load Base Configuration
                                        (0312)     ;-------------------------
                                        (0313)     ; Load global parameter settings and load the user modules in the
                                        (0314)     ; base configuration. Exceptions: (1) Leave CPU Speed fast as possible
                                        (0315)     ; to minimize start up time; (2) We may still need to play with the
                                        (0316)     ; Sleep Timer.
                                        (0317)     ;
00B2: 7C 04 76 LCALL 0x0476             (0318)     lcall LoadConfigInit
                                        (0319) 
                                        (0320)     ;-----------------------------------
                                        (0321)     ; Initialize C Run-Time Environment
                                        (0322)     ;-----------------------------------
                                        (0323) IF ( C_LANGUAGE_SUPPORT )
                                        (0324) IF ( SYSTEM_SMALL_MEMORY_MODEL )
00B5: 50 00    MOV   A,0x0              (0325)     mov  A,0                           ; clear the 'bss' segment to zero
00B7: 55 1D 26 MOV   [__r0],0x26        (0326)     mov  [__r0],<__bss_start
                                        (0327) BssLoop:
00BA: 3C 1D 97 CMP   [__r0],0x97        (0328)     cmp  [__r0],<__bss_end
00BD: A0 05    JZ    0x00C3             (0329)     jz   BssDone
00BF: 3F 1D    MVI   [__r0],A           (0330)     mvi  [__r0],A
00C1: 8F F8    JMP   0x00BA             (0331)     jmp  BssLoop
                                        (0332) BssDone:
00C3: 50 03    MOV   A,0x3              (0333)     mov  A,>__idata_start              ; copy idata to data segment
00C5: 57 1B    MOV   X,0x1B             (0334)     mov  X,<__idata_start
00C7: 55 1D 00 MOV   [__r0],0x0         (0335)     mov  [__r0],<__data_start
                                        (0336) IDataLoop:
00CA: 3C 1D 0F CMP   [__r0],0xF         (0337)     cmp  [__r0],<__data_end
00CD: A0 0B    JZ    0x00D9             (0338)     jz   C_RTE_Done
00CF: 08       PUSH  A                  (0339)     push A
00D0: 28       ROMX                     (0340)     romx
00D1: 3F 1D    MVI   [__r0],A           (0341)     mvi  [__r0],A
00D3: 18       POP   A                  (0342)     pop  A
00D4: 75       INC   X                  (0343)     inc  X
00D5: 09 00    ADC   A,0x0              (0344)     adc  A,0
00D7: 8F F2    JMP   0x00CA             (0345)     jmp  IDataLoop
00D9: 71 10    OR    F,0x10             
                                        (0346) 
                                        (0347) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
                                        (0348) 
                                        (0349) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0350)     mov   reg[CUR_PP], >__r0           ; force direct addr mode instructions
                                        (0351)                                        ; to use the Virtual Register page.
                                        (0352) 
                                        (0353)     ; Dereference the constant (flash) pointer pXIData to access the start
                                        (0354)     ; of the extended idata area, "xidata." Xidata follows the end of the
                                        (0355)     ; text segment and may have been relocated by the Code Compressor.
                                        (0356)     ;
                                        (0357)     mov   A, >__pXIData                ; Get the address of the flash
                                        (0358)     mov   X, <__pXIData                ;   pointer to the xidata area.
                                        (0359)     push  A
                                        (0360)     romx                               ; get the MSB of xidata's address
                                        (0361)     mov   [__r0], A
                                        (0362)     pop   A
                                        (0363)     inc   X
                                        (0364)     adc   A, 0
                                        (0365)     romx                               ; get the LSB of xidata's address
                                        (0366)     swap  A, X
                                        (0367)     mov   A, [__r0]                    ; pXIData (in [A,X]) points to the
                                        (0368)                                        ;   XIData structure list in flash
                                        (0369)     jmp   .AccessStruct
                                        (0370) 
                                        (0371)     ; Unpack one element in the xidata "structure list" that specifies the
                                        (0372)     ; values of C variables. Each structure contains 3 member elements.
                                        (0373)     ; The first is a pointer to a contiguous block of RAM to be initial-
                                        (0374)     ; ized. Blocks are always 255 bytes or less in length and never cross
                                        (0375)     ; RAM page boundaries. The list terminates when the MSB of the pointer
                                        (0376)     ; contains 0xFF. There are two formats for the struct depending on the
                                        (0377)     ; value in the second member element, an unsigned byte:
                                        (0378)     ; (1) If the value of the second element is non-zero, it represents
                                        (0379)     ; the 'size' of the block of RAM to be initialized. In this case, the
                                        (0380)     ; third member of the struct is an array of bytes of length 'size' and
                                        (0381)     ; the bytes are copied to the block of RAM.
                                        (0382)     ; (2) If the value of the second element is zero, the block of RAM is
                                        (0383)     ; to be cleared to zero. In this case, the third member of the struct
                                        (0384)     ; is an unsigned byte containing the number of bytes to clear.
                                        (0385) 
                                        (0386) .AccessNextStructLoop:
                                        (0387)     inc   X                            ; pXIData++
                                        (0388)     adc   A, 0
                                        (0389) .AccessStruct:                         ; Entry point for first block
                                        (0390)     ;
                                        (0391)     ; Assert: pXIData in [A,X] points to the beginning of an XIData struct.
                                        (0392)     ;
                                        (0393)     M8C_ClearWDT                       ; Clear the watchdog for long inits
                                        (0394)     push  A
                                        (0395)     romx                               ; MSB of RAM addr (CPU.A <- *pXIData)
                                        (0396)     mov   reg[MVW_PP], A               ;   for use with MVI write operations
                                        (0397)     inc   A                            ; End of Struct List? (MSB==0xFF?)
                                        (0398)     jz    .C_RTE_WrapUp                ;   Yes, C runtime environment complete
                                        (0399)     pop   A                            ; restore pXIData to [A,X]
                                        (0400)     inc   X                            ; pXIData++
                                        (0401)     adc   A, 0
                                        (0402)     push  A
                                        (0403)     romx                               ; LSB of RAM addr (CPU.A <- *pXIData)
                                        (0404)     mov   [__r0], A                    ; RAM Addr now in [reg[MVW_PP],[__r0]]
                                        (0405)     pop   A                            ; restore pXIData to [A,X]
                                        (0406)     inc   X                            ; pXIData++ (point to size)
                                        (0407)     adc   A, 0
                                        (0408)     push  A
                                        (0409)     romx                               ; Get the size (CPU.A <- *pXIData)
                                        (0410)     jz    .ClearRAMBlockToZero         ; If Size==0, then go clear RAM
                                        (0411)     mov   [__r1], A                    ;             else downcount in __r1
                                        (0412)     pop   A                            ; restore pXIData to [A,X]
                                        (0413) 
                                        (0414) .CopyNextByteLoop:
                                        (0415)     ; For each byte in the structure's array member, copy from flash to RAM.
                                        (0416)     ; Assert: pXIData in [A,X] points to previous byte of flash source;
                                        (0417)     ;         [reg[MVW_PP],[__r0]] points to next RAM destination;
                                        (0418)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                        (0419)     ;
                                        (0420)     inc   X                            ; pXIData++ (point to next data byte)
                                        (0421)     adc   A, 0
                                        (0422)     push  A
                                        (0423)     romx                               ; Get the data value (CPU.A <- *pXIData)
                                        (0424)     mvi   [__r0], A                    ; Transfer the data to RAM
                                        (0425)     tst   [__r0], 0xff                 ; Check for page crossing
                                        (0426)     jnz   .CopyLoopTail                ;   No crossing, keep going
                                        (0427)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
                                        (0428)     inc   A
                                        (0429)     mov   reg[ MVW_PP], A
                                        (0430) .CopyLoopTail:
                                        (0431)     pop   A                            ; restore pXIData to [A,X]
                                        (0432)     dec   [__r1]                       ; End of this array in flash?
                                        (0433)     jnz   .CopyNextByteLoop            ;   No,  more bytes to copy
                                        (0434)     jmp   .AccessNextStructLoop        ;   Yes, initialize another RAM block
                                        (0435) 
                                        (0436) .ClearRAMBlockToZero:
                                        (0437)     pop   A                            ; restore pXIData to [A,X]
                                        (0438)     inc   X                            ; pXIData++ (point to next data byte)
                                        (0439)     adc   A, 0
                                        (0440)     push  A
                                        (0441)     romx                               ; Get the run length (CPU.A <- *pXIData)
                                        (0442)     mov   [__r1], A                    ; Initialize downcounter
                                        (0443)     mov   A, 0                         ; Initialize source data
                                        (0444) 
                                        (0445) .ClearRAMBlockLoop:
                                        (0446)     ; Assert: [reg[MVW_PP],[__r0]] points to next RAM destination and
                                        (0447)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                        (0448)     ;
                                        (0449)     mvi   [__r0], A                    ; Clear a byte
                                        (0450)     tst   [__r0], 0xff                 ; Check for page crossing
                                        (0451)     jnz   .ClearLoopTail               ;   No crossing, keep going
                                        (0452)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
                                        (0453)     inc   A
                                        (0454)     mov   reg[ MVW_PP], A
                                        (0455)     mov   A, 0                         ; Restore the zero used for clearing
                                        (0456) .ClearLoopTail:
                                        (0457)     dec   [__r1]                       ; Was this the last byte?
                                        (0458)     jnz   .ClearRAMBlockLoop           ;   No,  continue
                                        (0459)     pop   A                            ;   Yes, restore pXIData to [A,X] and
                                        (0460)     jmp   .AccessNextStructLoop        ;        initialize another RAM block
                                        (0461) 
                                        (0462) .C_RTE_WrapUp:
                                        (0463)     pop   A                            ; balance stack
                                        (0464) 
                                        (0465) ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                                        (0466) 
                                        (0467) C_RTE_Done:
                                        (0468) 
                                        (0469) ENDIF ; C_LANGUAGE_SUPPORT
                                        (0470) 
                                        (0471)     ;-------------------------------
                                        (0472)     ; Voltage Stabilization for SMP
                                        (0473)     ;-------------------------------
                                        (0474) 
                                        (0475) IF ( POWER_SETTING & POWER_SET_5V0)    ; 5.0V Operation
                                        (0476) IF ( SWITCH_MODE_PUMP ^ 1 )            ; SMP is operational
                                        (0477)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0478)     ; When using the SMP at 5V, we must wait for Vdd to slew from 3.1V to
                                        (0479)     ; 5V before enabling the Precision Power-On Reset (PPOR).
                                        (0480)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0481)     or   reg[INT_MSK0],INT_MSK0_SLEEP
                                        (0482)     M8C_SetBank1
                                        (0483)     and   reg[OSC_CR0], ~OSC_CR0_SLEEP
                                        (0484)     or    reg[OSC_CR0],  OSC_CR0_SLEEP_512Hz
                                        (0485)     M8C_SetBank0
                                        (0486)     M8C_ClearWDTAndSleep                   ; Restart the sleep timer
                                        (0487)     mov   reg[INT_VC], 0                   ; Clear all pending interrupts
                                        (0488) .WaitFor2ms:
                                        (0489)     tst   reg[INT_CLR0], INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
                                        (0490)     jz   .WaitFor2ms                       ; Branch fails when 2 msec has passed
                                        (0491) ENDIF ; SMP is operational
                                        (0492) ENDIF ; 5.0V Operation
                                        (0493) 
                                        (0494)     ;-------------------------------
                                        (0495)     ; Set Power-On Reset (POR) Level
                                        (0496)     ;-------------------------------
                                        (0497)     ;  The writes to the VLT_CR register below include setting the POR to VLT_CR_POR_HIGH,
                                        (0498)     ;  VLT_CR_POR_MID or VLT_CR_POR_LOW. Correctly setting this value is critical to the proper
                                        (0499)     ;  operation of the PSoC. The POR protects the M8C from mis-executing when Vdd falls low. 
                                        (0500)     ;  These values should not be changed from the settings here. See Section "POR and LVD" of 
                                        (0501)     ;  Technical Reference Manual #001-14463 for more information.
                                        (0502) 
                                        (0503)     M8C_SetBank1
                                        (0504) 
                                        (0505) IF (POWER_SETTING & POWER_SET_2V7)             ; 2.7V Operation?
                                        (0506)                                                ;  Yes, lowest trip already set
                                        (0507) ELSE                                           ;   No, must adjust POR...
                                        (0508) IF (POWER_SETTING & POWER_SET_3V3)             ; 3.3V Operation?
00DB: 43 E3 10 OR    REG[0xE3],0x10     (0509)     or   reg[VLT_CR], VLT_CR_POR_MID           ;   Yes, change to midpoint trip
00DE: 70 EF    AND   F,0xEF             
                                        (0510) ELSE
                                        (0511) IF (POWER_SETTING & POWER_SET_5V0)             ; 5.0V Operation?
                                        (0512)  IF (POWER_SETTING & POWER_SET_SLOW_IMO)       ; and Slow Mode?
                                        (0513)     or   reg[VLT_CR], VLT_CR_POR_MID           ;   Yes, set to midpoint trip
                                        (0514)  ELSE                                          ;    No, fast mode
                                        (0515)   IF ( CPU_CLOCK_JUST ^ OSC_CR0_CPU_24MHz )    ;      As fast as 24MHz?
                                        (0516)     or   reg[VLT_CR], VLT_CR_POR_MID           ;         No, change to midpoint trip
                                        (0517)   ELSE ; 24HMz                                 ;
                                        (0518)     or    reg[VLT_CR], VLT_CR_POR_HIGH         ;        Yes, switch to	highest setting
                                        (0519)   ENDIF ; 24MHz
                                        (0520)  ENDIF ; Slow Mode
                                        (0521) ENDIF ; 5.0V Operation
                                        (0522) ENDIF ; 3.3V Operation
                                        (0523) ENDIF ; 2.7V Operation
                                        (0524) 
                                        (0525)     M8C_SetBank0
                                        (0526) 
                                        (0527)     ;----------------------------
                                        (0528)     ; Wrap up and invoke "main"
                                        (0529)     ;----------------------------
                                        (0530) 
                                        (0531)     ; Disable the Sleep interrupt that was used for timing above.  In fact,
                                        (0532)     ; no interrupts should be enabled now, so may as well clear the register.
                                        (0533)     ;
00E0: 62 E0 00 MOV   REG[0xE0],0x0      (0534)     mov  reg[INT_MSK0],0
00E3: 71 10    OR    F,0x10             
                                        (0535) 
                                        (0536)     ; Everything has started OK. Now select requested CPU & sleep frequency.
                                        (0537)     ;
                                        (0538)     M8C_SetBank1
00E5: 62 E0 02 MOV   REG[0xE0],0x2      (0539)     mov  reg[OSC_CR0],(SLEEP_TIMER_JUST | CPU_CLOCK_JUST)
00E8: 70 EF    AND   F,0xEF             
                                        (0540)     M8C_SetBank0
                                        (0541) 
                                        (0542)     ; Global Interrupt are NOT enabled, this should be done in main().
                                        (0543)     ; LVD is set but will not occur unless Global Interrupts are enabled.
                                        (0544)     ; Global Interrupts should be enabled as soon as possible in main().
                                        (0545)     ;
00EA: 62 E2 00 MOV   REG[0xE2],0x0      (0546)     mov  reg[INT_VC],0             ; Clear any pending interrupts which may
                                        (0547)                                    ; have been set during the boot process.
                                        (0548) IF	(TOOLCHAIN & HITECH)
                                        (0549) 	ljmp  startup                  ; Jump to C compiler startup code
                                        (0550) ELSE
                                        (0551) IF ENABLE_LJMP_TO_MAIN
                                        (0552)     ljmp  _main                    ; goto main (no return)
                                        (0553) ELSE
00ED: 7C 18 9A LCALL _main              (0554)     lcall _main                    ; call main
                                        (0555) .Exit:
00F0: 8F FF    JMP   0x00F0             (0556)     jmp  .Exit                     ; Wait here after return till power-off or reset
                                        (0557) ENDIF
                                        (0558) ENDIF ; TOOLCHAIN
                                        (0559) 
                                        (0560)     ;---------------------------------
                                        (0561)     ; Library Access to Global Parms
                                        (0562)     ;---------------------------------
                                        (0563)     ;
                                        (0564)  bGetPowerSetting:
                                        (0565) _bGetPowerSetting:
                                        (0566)     ; Returns value of POWER_SETTING in the A register.
                                        (0567)     ; No inputs. No Side Effects.
                                        (0568)     ;
                                        (0569) IF (POWER_SETTING & POWER_SET_2V7)
                                        (0570)     mov   A, POWER_SETTING | POWER_SET_SLOW_IMO
                                        (0571) ELSE
00F2: 50 08    MOV   A,0x8              (0572)     mov   A, POWER_SETTING          ; Supply voltage and internal main osc
                                        (0573) ENDIF
00F4: 7F       RET                      (0574)     ret
                                        (0575) 
                                        (0576) IF	(TOOLCHAIN & HITECH)
                                        (0577) ELSE
                                        (0578)     ;---------------------------------
                                        (0579)     ; Order Critical RAM & ROM AREAs
                                        (0580)     ;---------------------------------
                                        (0581)     ;  'TOP' is all that has been defined so far...
                                        (0582) 
                                        (0583)     ;  ROM AREAs for C CONST, static & global items
                                        (0584)     ;
                                        (0585)     AREA lit               (ROM, REL, CON, LIT)   ; 'const' definitions
                                        (0586)     AREA idata             (ROM, REL, CON, LIT)   ; Constants for initializing RAM
                                        (0587) __idata_start:
                                        (0588) 
                                        (0589)     AREA func_lit          (ROM, REL, CON, proclab)   ; Function Pointers
                                        (0590) __func_lit_start:
                                        (0591) 
                                        (0592) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0593)     ; We use the func_lit area to store a pointer to extended initialized
                                        (0594)     ; data (xidata) area that follows the text area. Func_lit isn't
                                        (0595)     ; relocated by the code compressor, but the text area may shrink and
                                        (0596)     ; that moves xidata around.
                                        (0597)     ;
                                        (0598) __pXIData:         word __text_end           ; ptr to extended idata
                                        (0599) ENDIF
                                        (0600) 
                                        (0601)     AREA psoc_config       (ROM, REL, CON)   ; Configuration Load & Unload
                                        (0602)     AREA UserModules       (ROM, REL, CON)   ; User Module APIs
                                        (0603) 
                                        (0604)     ; CODE segment for general use
                                        (0605)     ;
                                        (0606)     AREA text (ROM, REL, CON)
                                        (0607) __text_start:
                                        (0608) 
                                        (0609)     ; RAM area usage
                                        (0610)     ;
                                        (0611)     AREA data              (RAM, REL, CON)   ; initialized RAM
                                        (0612) __data_start:
                                        (0613) 
                                        (0614)     AREA virtual_registers (RAM, REL, CON)   ; Temp vars of C compiler
                                        (0615)     AREA InterruptRAM      (RAM, REL, CON)   ; Interrupts, on Page 0
                                        (0616)     AREA bss               (RAM, REL, CON)   ; general use
                                        (0617) __bss_start:
                                        (0618) ENDIF ; TOOLCHAIN
                                        (0619) ; end of file boot.asm
FILE: lib\psocconfigtbl.asm             (0001) ;  Generated by PSoC Designer 5.4.3191
033A: 70 EF    AND   F,0xEF             (0002) ;
                                        (0003) ; =============================================================================
                                        (0004) ; FILENAME: PSoCConfigTBL.asm
                                        (0005) ;  
                                        (0006) ; Copyright (c) Cypress Semiconductor 2013. All Rights Reserved.
                                        (0007) ;  
                                        (0008) ; NOTES:
                                        (0009) ; Do not modify this file. It is generated by PSoC Designer each time the
                                        (0010) ; generate application function is run. The values of the parameters in this
                                        (0011) ; file can be modified by changing the values of the global parameters in the
                                        (0012) ; device editor.
                                        (0013) ;  
                                        (0014) ; =============================================================================
                                        (0015)  
                                        (0016) include "m8c.inc"
                                        (0017) ;  Personalization tables 
                                        (0018) export LoadConfigTBL_dsm_sateilte
                                        (0019) AREA psoc_config(rom, rel)
                                        (0020) LoadConfigTBL_dsm_sateilte:
                                        (0021) 	M8C_SetBank0
                                        (0022) ;  Global Register values Bank 0
033C: 62 60 04 MOV   REG[0x60],0x4      (0023) 	mov	reg[60h], 04h		; AnalogColumnInputSelect register (AMX_IN)
033F: 62 64 00 MOV   REG[0x64],0x0      (0024) 	mov	reg[64h], 00h		; AnalogComparatorControl0 register (CMP_CR0)
0342: 62 66 00 MOV   REG[0x66],0x0      (0025) 	mov	reg[66h], 00h		; AnalogComparatorControl1 register (CMP_CR1)
0345: 62 61 00 MOV   REG[0x61],0x0      (0026) 	mov	reg[61h], 00h		; AnalogMuxBusConfig register (AMUXCFG)
0348: 62 E6 00 MOV   REG[0xE6],0x0      (0027) 	mov	reg[e6h], 00h		; DecimatorControl_0 register (DEC_CR0)
034B: 62 E7 00 MOV   REG[0xE7],0x0      (0028) 	mov	reg[e7h], 00h		; DecimatorControl_1 register (DEC_CR1)
034E: 62 D6 00 MOV   REG[0xD6],0x0      (0029) 	mov	reg[d6h], 00h		; I2CConfig register (I2CCFG)
0351: 62 62 00 MOV   REG[0x62],0x0      (0030) 	mov	reg[62h], 00h		; PWM_Control register (PWM_CR)
0354: 62 B0 38 MOV   REG[0xB0],0x38     (0031) 	mov	reg[b0h], 38h		; Row_0_InputMux register (RDI0RI)
0357: 62 B1 01 MOV   REG[0xB1],0x1      (0032) 	mov	reg[b1h], 01h		; Row_0_InputSync register (RDI0SYN)
035A: 62 B2 00 MOV   REG[0xB2],0x0      (0033) 	mov	reg[b2h], 00h		; Row_0_LogicInputAMux register (RDI0IS)
035D: 62 B3 33 MOV   REG[0xB3],0x33     (0034) 	mov	reg[b3h], 33h		; Row_0_LogicSelect_0 register (RDI0LT0)
0360: 62 B4 33 MOV   REG[0xB4],0x33     (0035) 	mov	reg[b4h], 33h		; Row_0_LogicSelect_1 register (RDI0LT1)
0363: 62 B5 20 MOV   REG[0xB5],0x20     (0036) 	mov	reg[b5h], 20h		; Row_0_OutputDrive_0 register (RDI0SRO0)
0366: 62 B6 10 MOV   REG[0xB6],0x10     (0037) 	mov	reg[b6h], 10h		; Row_0_OutputDrive_1 register (RDI0SRO1)
                                        (0038) ;  Instance name CS_PIN, User Module LED
                                        (0039) ;  Instance name Counter16_1, User Module Counter16
                                        (0040) ;       Instance name Counter16_1, Block Name CNTR16_LSB(DBB00)
0369: 62 23 00 MOV   REG[0x23],0x0      (0041) 	mov	reg[23h], 00h		;Counter16_1_CONTROL_LSB_REG(DBB00CR0)
036C: 62 21 A0 MOV   REG[0x21],0xA0     (0042) 	mov	reg[21h], a0h		;Counter16_1_PERIOD_LSB_REG(DBB00DR1)
036F: 62 22 A4 MOV   REG[0x22],0xA4     (0043) 	mov	reg[22h], a4h		;Counter16_1_COMPARE_LSB_REG(DBB00DR2)
                                        (0044) ;       Instance name Counter16_1, Block Name CNTR16_MSB(DBB01)
0372: 62 27 00 MOV   REG[0x27],0x0      (0045) 	mov	reg[27h], 00h		;Counter16_1_CONTROL_MSB_REG(DBB01CR0)
0375: 62 25 0F MOV   REG[0x25],0xF      (0046) 	mov	reg[25h], 0fh		;Counter16_1_PERIOD_MSB_REG(DBB01DR1)
0378: 62 26 06 MOV   REG[0x26],0x6      (0047) 	mov	reg[26h], 06h		;Counter16_1_COMPARE_MSB_REG(DBB01DR2)
                                        (0048) ;  Instance name DIAG_OUT1, User Module LED
                                        (0049) ;  Instance name E2PROM_1, User Module E2PROM
                                        (0050) ;  Instance name LED_1, User Module LED
                                        (0051) ;  Instance name RST, User Module LED
                                        (0052) ;  Instance name RX8_1, User Module RX8
                                        (0053) ;       Instance name RX8_1, Block Name RX8(DCB03)
037B: 62 2F 00 MOV   REG[0x2F],0x0      (0054) 	mov	reg[2fh], 00h		;RX8_1_CONTROL_REG  (DCB03CR0)
037E: 62 2D 00 MOV   REG[0x2D],0x0      (0055) 	mov	reg[2dh], 00h		;RX8_1_(DCB03DR1)
0381: 62 2E 00 MOV   REG[0x2E],0x0      (0056) 	mov	reg[2eh], 00h		;RX8_1_RX_BUFFER_REG(DCB03DR2)
                                        (0057) ;  Instance name SPIM_1, User Module SPIM
                                        (0058) ;       Instance name SPIM_1, Block Name SPIM(DCB02)
0384: 62 2B 00 MOV   REG[0x2B],0x0      (0059) 	mov	reg[2bh], 00h		;SPIM_1_CONTROL_REG  (DCB02CR0)
0387: 62 29 00 MOV   REG[0x29],0x0      (0060) 	mov	reg[29h], 00h		;SPIM_1_TX_BUFFER_REG(DCB02DR1)
038A: 62 2A 00 MOV   REG[0x2A],0x0      (0061) 	mov	reg[2ah], 00h		;SPIM_1_RX_BUFFER_REG(DCB02DR2)
038D: 71 10    OR    F,0x10             
                                        (0062) ;  Instance name SleepTimer_1, User Module SleepTimer
                                        (0063) ;  Instance name TX8SW_1, User Module TX8SW
                                        (0064) 	M8C_SetBank1
                                        (0065) ;  Global Register values Bank 1
038F: 62 61 00 MOV   REG[0x61],0x0      (0066) 	mov	reg[61h], 00h		; AnalogClockSelect1 register (CLK_CR1)
0392: 62 6B 04 MOV   REG[0x6B],0x4      (0067) 	mov	reg[6bh], 04h		; AnalogColumnClockDivide register (CLK_CR3)
0395: 62 60 00 MOV   REG[0x60],0x0      (0068) 	mov	reg[60h], 00h		; AnalogColumnClockSelect register (CLK_CR0)
0398: 62 62 80 MOV   REG[0x62],0x80     (0069) 	mov	reg[62h], 80h		; AnalogIOControl_0 register (ABF_CR0)
039B: 62 67 00 MOV   REG[0x67],0x0      (0070) 	mov	reg[67h], 00h		; AnalogLUTControl0 register (ALT_CR0)
039E: 62 64 00 MOV   REG[0x64],0x0      (0071) 	mov	reg[64h], 00h		; ComparatorGlobalOutEn register (CMP_GO_EN)
03A1: 62 FD 00 MOV   REG[0xFD],0x0      (0072) 	mov	reg[fdh], 00h		; DAC_Control register (DAC_CR)
03A4: 62 D1 00 MOV   REG[0xD1],0x0      (0073) 	mov	reg[d1h], 00h		; GlobalDigitalInterconnect_Drive_Even_Input register (GDI_E_IN)
03A7: 62 D3 00 MOV   REG[0xD3],0x0      (0074) 	mov	reg[d3h], 00h		; GlobalDigitalInterconnect_Drive_Even_Output register (GDI_E_OU)
03AA: 62 D0 00 MOV   REG[0xD0],0x0      (0075) 	mov	reg[d0h], 00h		; GlobalDigitalInterconnect_Drive_Odd_Input register (GDI_O_IN)
03AD: 62 D2 00 MOV   REG[0xD2],0x0      (0076) 	mov	reg[d2h], 00h		; GlobalDigitalInterconnect_Drive_Odd_Output register (GDI_O_OU)
03B0: 62 E1 72 MOV   REG[0xE1],0x72     (0077) 	mov	reg[e1h], 72h		; OscillatorControl_1 register (OSC_CR1)
03B3: 62 E2 00 MOV   REG[0xE2],0x0      (0078) 	mov	reg[e2h], 00h		; OscillatorControl_2 register (OSC_CR2)
03B6: 62 DF 16 MOV   REG[0xDF],0x16     (0079) 	mov	reg[dfh], 16h		; OscillatorControl_3 register (OSC_CR3)
03B9: 62 DE 00 MOV   REG[0xDE],0x0      (0080) 	mov	reg[deh], 00h		; OscillatorControl_4 register (OSC_CR4)
03BC: 62 DD 00 MOV   REG[0xDD],0x0      (0081) 	mov	reg[ddh], 00h		; OscillatorGlobalBusEnableControl register (OSC_GO_EN)
03BF: 62 D8 00 MOV   REG[0xD8],0x0      (0082) 	mov	reg[d8h], 00h		; Port_0_MUXBusCtrl register (MUX_CR0)
03C2: 62 D9 00 MOV   REG[0xD9],0x0      (0083) 	mov	reg[d9h], 00h		; Port_1_MUXBusCtrl register (MUX_CR1)
03C5: 62 DA 00 MOV   REG[0xDA],0x0      (0084) 	mov	reg[dah], 00h		; Port_2_MUXBusCtrl register (MUX_CR2)
03C8: 62 DB 00 MOV   REG[0xDB],0x0      (0085) 	mov	reg[dbh], 00h		; Port_3_MUXBusCtrl register (MUX_CR3)
                                        (0086) ;  Instance name CS_PIN, User Module LED
                                        (0087) ;  Instance name Counter16_1, User Module Counter16
                                        (0088) ;       Instance name Counter16_1, Block Name CNTR16_LSB(DBB00)
03CB: 62 20 01 MOV   REG[0x20],0x1      (0089) 	mov	reg[20h], 01h		;Counter16_1_FUNC_LSB_REG(DBB00FN)
03CE: 62 21 06 MOV   REG[0x21],0x6      (0090) 	mov	reg[21h], 06h		;Counter16_1_INPUT_LSB_REG(DBB00IN)
03D1: 62 22 40 MOV   REG[0x22],0x40     (0091) 	mov	reg[22h], 40h		;Counter16_1_OUTPUT_LSB_REG(DBB00OU)
                                        (0092) ;       Instance name Counter16_1, Block Name CNTR16_MSB(DBB01)
03D4: 62 24 21 MOV   REG[0x24],0x21     (0093) 	mov	reg[24h], 21h		;Counter16_1_FUNC_MSB_REG(DBB01FN)
03D7: 62 25 36 MOV   REG[0x25],0x36     (0094) 	mov	reg[25h], 36h		;Counter16_1_INPUT_MSB_REG(DBB01IN)
03DA: 62 26 40 MOV   REG[0x26],0x40     (0095) 	mov	reg[26h], 40h		;Counter16_1_OUTPUT_MSB_REG(DBB01OU)
                                        (0096) ;  Instance name DIAG_OUT1, User Module LED
                                        (0097) ;  Instance name E2PROM_1, User Module E2PROM
                                        (0098) ;  Instance name LED_1, User Module LED
                                        (0099) ;  Instance name RST, User Module LED
                                        (0100) ;  Instance name RX8_1, User Module RX8
                                        (0101) ;       Instance name RX8_1, Block Name RX8(DCB03)
03DD: 62 2C 05 MOV   REG[0x2C],0x5      (0102) 	mov	reg[2ch], 05h		;RX8_1_FUNC_REG     (DCB03FN)
03E0: 62 2D D1 MOV   REG[0x2D],0xD1     (0103) 	mov	reg[2dh], d1h		;RX8_1_INPUT_REG    (DCB03IN)
03E3: 62 2E 40 MOV   REG[0x2E],0x40     (0104) 	mov	reg[2eh], 40h		;RX8_1_OUTPUT_REG   (DCB03OU)
                                        (0105) ;  Instance name SPIM_1, User Module SPIM
                                        (0106) ;       Instance name SPIM_1, Block Name SPIM(DCB02)
03E6: 62 28 06 MOV   REG[0x28],0x6      (0107) 	mov	reg[28h], 06h		;SPIM_1_FUNCTION_REG (DCB02FN)
03E9: 62 29 C5 MOV   REG[0x29],0xC5     (0108) 	mov	reg[29h], c5h		;SPIM_1_INPUT_REG    (DCB02IN)
03EC: 62 2A 7D MOV   REG[0x2A],0x7D     (0109) 	mov	reg[2ah], 7dh		;SPIM_1_OUTPUT_REG   (DCB02OU)
03EF: 70 EF    AND   F,0xEF             
03F1: 70 EF    AND   F,0xEF             
                                        (0110) ;  Instance name SleepTimer_1, User Module SleepTimer
                                        (0111) ;  Instance name TX8SW_1, User Module TX8SW
                                        (0112) 	M8C_SetBank0
                                        (0113) ;  Ordered Global Register values
                                        (0114) 	M8C_SetBank0
03F3: 62 00 00 MOV   REG[0x0],0x0       (0115) 	mov	reg[00h], 00h		; Port_0_Data register (PRT0DR)
03F6: 71 10    OR    F,0x10             
                                        (0116) 	M8C_SetBank1
03F8: 62 00 BE MOV   REG[0x0],0xBE      (0117) 	mov	reg[00h], beh		; Port_0_DriveMode_0 register (PRT0DM0)
03FB: 62 01 41 MOV   REG[0x1],0x41      (0118) 	mov	reg[01h], 41h		; Port_0_DriveMode_1 register (PRT0DM1)
03FE: 70 EF    AND   F,0xEF             
                                        (0119) 	M8C_SetBank0
0400: 62 03 00 MOV   REG[0x3],0x0       (0120) 	mov	reg[03h], 00h		; Port_0_DriveMode_2 register (PRT0DM2)
0403: 62 02 29 MOV   REG[0x2],0x29      (0121) 	mov	reg[02h], 29h		; Port_0_GlobalSelect register (PRT0GS)
0406: 71 10    OR    F,0x10             
                                        (0122) 	M8C_SetBank1
0408: 62 02 40 MOV   REG[0x2],0x40      (0123) 	mov	reg[02h], 40h		; Port_0_IntCtrl_0 register (PRT0IC0)
040B: 62 03 40 MOV   REG[0x3],0x40      (0124) 	mov	reg[03h], 40h		; Port_0_IntCtrl_1 register (PRT0IC1)
040E: 70 EF    AND   F,0xEF             
                                        (0125) 	M8C_SetBank0
0410: 62 01 40 MOV   REG[0x1],0x40      (0126) 	mov	reg[01h], 40h		; Port_0_IntEn register (PRT0IE)
0413: 62 04 00 MOV   REG[0x4],0x0       (0127) 	mov	reg[04h], 00h		; Port_1_Data register (PRT1DR)
0416: 71 10    OR    F,0x10             
                                        (0128) 	M8C_SetBank1
0418: 62 04 A9 MOV   REG[0x4],0xA9      (0129) 	mov	reg[04h], a9h		; Port_1_DriveMode_0 register (PRT1DM0)
041B: 62 05 56 MOV   REG[0x5],0x56      (0130) 	mov	reg[05h], 56h		; Port_1_DriveMode_1 register (PRT1DM1)
041E: 70 EF    AND   F,0xEF             
                                        (0131) 	M8C_SetBank0
0420: 62 07 14 MOV   REG[0x7],0x14      (0132) 	mov	reg[07h], 14h		; Port_1_DriveMode_2 register (PRT1DM2)
0423: 62 06 02 MOV   REG[0x6],0x2       (0133) 	mov	reg[06h], 02h		; Port_1_GlobalSelect register (PRT1GS)
0426: 71 10    OR    F,0x10             
                                        (0134) 	M8C_SetBank1
0428: 62 06 00 MOV   REG[0x6],0x0       (0135) 	mov	reg[06h], 00h		; Port_1_IntCtrl_0 register (PRT1IC0)
042B: 62 07 00 MOV   REG[0x7],0x0       (0136) 	mov	reg[07h], 00h		; Port_1_IntCtrl_1 register (PRT1IC1)
042E: 70 EF    AND   F,0xEF             
                                        (0137) 	M8C_SetBank0
0430: 62 05 00 MOV   REG[0x5],0x0       (0138) 	mov	reg[05h], 00h		; Port_1_IntEn register (PRT1IE)
0433: 62 08 00 MOV   REG[0x8],0x0       (0139) 	mov	reg[08h], 00h		; Port_2_Data register (PRT2DR)
0436: 71 10    OR    F,0x10             
                                        (0140) 	M8C_SetBank1
0438: 62 08 FF MOV   REG[0x8],0xFF      (0141) 	mov	reg[08h], ffh		; Port_2_DriveMode_0 register (PRT2DM0)
043B: 62 09 00 MOV   REG[0x9],0x0       (0142) 	mov	reg[09h], 00h		; Port_2_DriveMode_1 register (PRT2DM1)
043E: 70 EF    AND   F,0xEF             
                                        (0143) 	M8C_SetBank0
0440: 62 0B 00 MOV   REG[0xB],0x0       (0144) 	mov	reg[0bh], 00h		; Port_2_DriveMode_2 register (PRT2DM2)
0443: 62 0A 10 MOV   REG[0xA],0x10      (0145) 	mov	reg[0ah], 10h		; Port_2_GlobalSelect register (PRT2GS)
0446: 71 10    OR    F,0x10             
                                        (0146) 	M8C_SetBank1
0448: 62 0A 00 MOV   REG[0xA],0x0       (0147) 	mov	reg[0ah], 00h		; Port_2_IntCtrl_0 register (PRT2IC0)
044B: 62 0B 00 MOV   REG[0xB],0x0       (0148) 	mov	reg[0bh], 00h		; Port_2_IntCtrl_1 register (PRT2IC1)
044E: 70 EF    AND   F,0xEF             
                                        (0149) 	M8C_SetBank0
0450: 62 09 00 MOV   REG[0x9],0x0       (0150) 	mov	reg[09h], 00h		; Port_2_IntEn register (PRT2IE)
0453: 62 0C 00 MOV   REG[0xC],0x0       (0151) 	mov	reg[0ch], 00h		; Port_3_Data register (PRT3DR)
0456: 71 10    OR    F,0x10             
                                        (0152) 	M8C_SetBank1
0458: 62 0C 0F MOV   REG[0xC],0xF       (0153) 	mov	reg[0ch], 0fh		; Port_3_DriveMode_0 register (PRT3DM0)
045B: 62 0D 00 MOV   REG[0xD],0x0       (0154) 	mov	reg[0dh], 00h		; Port_3_DriveMode_1 register (PRT3DM1)
045E: 70 EF    AND   F,0xEF             
                                        (0155) 	M8C_SetBank0
0460: 62 0F 00 MOV   REG[0xF],0x0       (0156) 	mov	reg[0fh], 00h		; Port_3_DriveMode_2 register (PRT3DM2)
0463: 62 0E 00 MOV   REG[0xE],0x0       (0157) 	mov	reg[0eh], 00h		; Port_3_GlobalSelect register (PRT3GS)
0466: 71 10    OR    F,0x10             
                                        (0158) 	M8C_SetBank1
0468: 62 0E 00 MOV   REG[0xE],0x0       (0159) 	mov	reg[0eh], 00h		; Port_3_IntCtrl_0 register (PRT3IC0)
046B: 62 0F 00 MOV   REG[0xF],0x0       (0160) 	mov	reg[0fh], 00h		; Port_3_IntCtrl_1 register (PRT3IC1)
046E: 70 EF    AND   F,0xEF             
                                        (0161) 	M8C_SetBank0
0470: 62 0D 00 MOV   REG[0xD],0x0       (0162) 	mov	reg[0dh], 00h		; Port_3_IntEn register (PRT3IE)
0473: 70 EF    AND   F,0xEF             
                                        (0163) 	M8C_SetBank0
0475: 7F       RET                      (0164) 	ret
                                        (0165) 
                                        (0166) 
                                        (0167) ; PSoC Configuration file trailer PsocConfig.asm
FILE: lib\psocconfig.asm                (0001) ;  Generated by PSoC Designer 5.4.3191
                                        (0002) ;
                                        (0003) ;==========================================================================
                                        (0004) ;  PSoCConfig.asm
                                        (0005) ;  @PSOC_VERSION
                                        (0006) ;
                                        (0007) ;  Version: 0.85
                                        (0008) ;  Revised: June 22, 2004
                                        (0009) ;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0010) ;
                                        (0011) ;  This file is generated by the Device Editor on Application Generation.
                                        (0012) ;  It contains code which loads the configuration data table generated in
                                        (0013) ;  the file PSoCConfigTBL.asm
                                        (0014) ;
                                        (0015) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                        (0016) ;  Edits to this file will not be preserved.
                                        (0017) ;==========================================================================
                                        (0018) ;
                                        (0019) include "m8c.inc"
                                        (0020) include "memory.inc"
                                        (0021) include "GlobalParams.inc"
                                        (0022) 
                                        (0023) export LoadConfigInit
                                        (0024) export _LoadConfigInit
                                        (0025) export LoadConfig_dsm_sateilte
                                        (0026) export _LoadConfig_dsm_sateilte
                                        (0027) export Port_0_Data_SHADE
                                        (0028) export _Port_0_Data_SHADE
                                        (0029) export Port_1_Data_SHADE
                                        (0030) export _Port_1_Data_SHADE
                                        (0031) export Port_3_Data_SHADE
                                        (0032) export _Port_3_Data_SHADE
                                        (0033) 
                                        (0034) 
                                        (0035) export NO_SHADOW
                                        (0036) export _NO_SHADOW
                                        (0037) 
                                        (0038) FLAG_CFG_MASK:      equ 10h         ;M8C flag register REG address bit mask
                                        (0039) END_CONFIG_TABLE:   equ ffh         ;end of config table indicator
                                        (0040) 
                                        (0041) AREA psoc_config(rom, rel)
                                        (0042) 
                                        (0043) 
                                        (0044) ;---------------------------------------------------------------------------
                                        (0045) ; LoadConfigInit - Establish the start-up configuration (except for a few
                                        (0046) ;                  parameters handled by boot code, like CPU speed). This
                                        (0047) ;                  function can be called from user code, but typically it
                                        (0048) ;                  is only called from boot.
                                        (0049) ;
                                        (0050) ;       INPUTS: None.
                                        (0051) ;      RETURNS: Nothing.
                                        (0052) ; SIDE EFFECTS: Registers are volatile: the A and X registers can be modified!
                                        (0053) ;               In the large memory model currently only the page
                                        (0054) ;               pointer registers listed below are modified.  This does
                                        (0055) ;               not guarantee that in future implementations of this
                                        (0056) ;               function other page pointer registers will not be
                                        (0057) ;               modified.
                                        (0058) ;          
                                        (0059) ;               Page Pointer Registers Modified: 
                                        (0060) ;               CUR_PP
                                        (0061) ;
                                        (0062) _LoadConfigInit:
                                        (0063)  LoadConfigInit:
                                        (0064)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0065)     
0476: 55 23 00 MOV   [0x23],0x0         (0066) 	mov		[Port_0_Data_SHADE], 0h
0479: 55 24 00 MOV   [0x24],0x0         (0067) 	mov		[Port_1_Data_SHADE], 0h
047C: 55 25 00 MOV   [0x25],0x0         (0068) 	mov		[Port_3_Data_SHADE], 0h
                                        (0069) 
047F: 7C 04 83 LCALL 0x0483             (0070) 	lcall	LoadConfig_dsm_sateilte
                                        (0071) 
                                        (0072) 
                                        (0073)     RAM_EPILOGUE RAM_USE_CLASS_4
0482: 7F       RET                      (0074)     ret
                                        (0075) 
                                        (0076) ;---------------------------------------------------------------------------
                                        (0077) ; Load Configuration dsm_sateilte
                                        (0078) ;
                                        (0079) ;    Load configuration registers for dsm_sateilte.
                                        (0080) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                        (0081) ;
                                        (0082) ;       INPUTS: None.
                                        (0083) ;      RETURNS: Nothing.
                                        (0084) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                        (0085) ;               modified as may the Page Pointer registers!
                                        (0086) ;               In the large memory model currently only the page
                                        (0087) ;               pointer registers listed below are modified.  This does
                                        (0088) ;               not guarantee that in future implementations of this
                                        (0089) ;               function other page pointer registers will not be
                                        (0090) ;               modified.
                                        (0091) ;          
                                        (0092) ;               Page Pointer Registers Modified: 
                                        (0093) ;               CUR_PP
                                        (0094) ;
                                        (0095) _LoadConfig_dsm_sateilte:
                                        (0096)  LoadConfig_dsm_sateilte:
                                        (0097)     RAM_PROLOGUE RAM_USE_CLASS_4
0483: 7C 03 3A LCALL 0x033A             (0098)     lcall   LoadConfigTBL_dsm_sateilte            ; Call load config table routine
0486: 70 EF    AND   F,0xEF             
                                        (0099) 
                                        (0100) 
                                        (0101)     M8C_SetBank0                    ; Force return to bank 0
                                        (0102)     RAM_EPILOGUE RAM_USE_CLASS_4
0488: 7F       RET                      (0103)     ret
                                        (0104) 
                                        (0105) 
                                        (0106) 
                                        (0107) AREA InterruptRAM(ram, rel)
                                        (0108) 
                                        (0109) NO_SHADOW:
                                        (0110) _NO_SHADOW:
                                        (0111) ; write only register shadows
                                        (0112) _Port_0_Data_SHADE:
                                        (0113) Port_0_Data_SHADE:	BLK	1
                                        (0114) _Port_1_Data_SHADE:
                                        (0115) Port_1_Data_SHADE:	BLK	1
                                        (0116) _Port_3_Data_SHADE:
                                        (0117) Port_3_Data_SHADE:	BLK	1
                                        (0118) 
FILE: lib\spim_1.asm                    (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: SPIM_1.asm
                                        (0004) ;;   Version: 2.6, Updated on 2015/3/4 at 22:27:42
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: SPIM User Module software implementation file.
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "memory.inc"
                                        (0024) include "SPIM_1.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export   SPIM_1_EnableInt
                                        (0030) export  _SPIM_1_EnableInt
                                        (0031) export   SPIM_1_DisableInt
                                        (0032) export  _SPIM_1_DisableInt
                                        (0033) export   SPIM_1_Start
                                        (0034) export  _SPIM_1_Start
                                        (0035) export   SPIM_1_Stop
                                        (0036) export  _SPIM_1_Stop
                                        (0037) export   SPIM_1_SendTxData
                                        (0038) export  _SPIM_1_SendTxData
                                        (0039) export   SPIM_1_bReadRxData
                                        (0040) export  _SPIM_1_bReadRxData
                                        (0041) export   SPIM_1_bReadStatus
                                        (0042) export  _SPIM_1_bReadStatus
                                        (0043) 
                                        (0044) // These globals will be removed in a future release
                                        (0045) // Do not use
                                        (0046) export   bSPIM_1_ReadRxData
                                        (0047) export  _bSPIM_1_ReadRxData
                                        (0048) export   bSPIM_1_ReadStatus
                                        (0049) export  _bSPIM_1_ReadStatus
                                        (0050) 
                                        (0051) ;-----------------------------------------------
                                        (0052) ;  Constant Definitions
                                        (0053) ;-----------------------------------------------
                                        (0054) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                        (0055) 
                                        (0056) 
                                        (0057) area UserModules (ROM, REL)
                                        (0058) 
                                        (0059) .SECTION
                                        (0060) ;-----------------------------------------------------------------------------
                                        (0061) ;  FUNCTION NAME: SPIM_1_EnableInt
                                        (0062) ;
                                        (0063) ;  DESCRIPTION:
                                        (0064) ;     Enables the SPIM interrupt by setting the interrupt enable mask
                                        (0065) ;     bit associated with this User Module.
                                        (0066) ;
                                        (0067) ;     NOTE:  Remember to enable the global interrupt by calling the
                                        (0068) ;           M8C global macro: M8C_EnableGInt
                                        (0069) ;
                                        (0070) ;-----------------------------------------------------------------------------
                                        (0071) ;
                                        (0072) ;  ARGUMENTS:  none
                                        (0073) ;
                                        (0074) ;  RETURNS:  none
                                        (0075) ;
                                        (0076) ;  SIDE EFFECTS: 
                                        (0077) ;    The A and X registers may be modified by this or future implementations
                                        (0078) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0079) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0080) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0081) ;    functions.
                                        (0082) ;
                                        (0083) ;  THEORY of OPERATION or PROCEDURE:
                                        (0084) ;     Sets the specific user module interrupt enable mask bit.
                                        (0085) ;
                                        (0086)  SPIM_1_EnableInt:
                                        (0087) _SPIM_1_EnableInt:
                                        (0088)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0089)    M8C_EnableIntMask SPIM_1_INT_REG, SPIM_1_bINT_MASK
                                        (0090)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0091)    ret
                                        (0092) 
                                        (0093) .ENDSECTION
                                        (0094) 
                                        (0095) .SECTION
                                        (0096) ;-----------------------------------------------------------------------------
                                        (0097) ;  FUNCTION NAME: SPIM_1_DisableInt
                                        (0098) ;
                                        (0099) ;  DESCRIPTION:
                                        (0100) ;     Disables this SPIM's interrupt by clearing the interrupt enable mask bit
                                        (0101) ;     associated with this User Module.
                                        (0102) ;
                                        (0103) ;-----------------------------------------------------------------------------
                                        (0104) ;
                                        (0105) ;  ARGUMENTS:  none
                                        (0106) ;
                                        (0107) ;  RETURNS:  none
                                        (0108) ;
                                        (0109) ;  SIDE EFFECTS: 
                                        (0110) ;    The A and X registers may be modified by this or future implementations
                                        (0111) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0112) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0113) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0114) ;    functions.
                                        (0115) ;
                                        (0116) ;  THEORY of OPERATION or PROCEDURE:
                                        (0117) ;     Clears the specific user module interrupt enable mask bit.
                                        (0118) ;
                                        (0119)  SPIM_1_DisableInt:
                                        (0120) _SPIM_1_DisableInt:
                                        (0121)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0122)    M8C_DisableIntMask SPIM_1_INT_REG, SPIM_1_bINT_MASK
                                        (0123)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0124)    ret
                                        (0125) 
                                        (0126) .ENDSECTION
                                        (0127) 
                                        (0128) .SECTION
                                        (0129) ;-----------------------------------------------------------------------------
                                        (0130) ;  FUNCTION NAME: SPIM_1_Start
                                        (0131) ;
                                        (0132) ;  DESCRIPTION:
                                        (0133) ;     Sets the start bit, SPI mode, and LSB/MSB first configuration of the SPIM
                                        (0134) ;     user module.
                                        (0135) ;
                                        (0136) ;     Transmission will begin transmitting when a byte is written into the TX buffer
                                        (0137) ;     using the SPIM_1_SendTxData function.
                                        (0138) ;
                                        (0139) ;-----------------------------------------------------------------------------
                                        (0140) ;
                                        (0141) ;  ARGUMENTS:
                                        (0142) ;     BYTE bConfiguration - Consists of SPI Mode and LSB/MSB first bit.
                                        (0143) ;           Use defined masks - masks can be OR'd together.
                                        (0144) ;     PASSED in Accumulator.
                                        (0145) ;
                                        (0146) ;  RETURNS:  none
                                        (0147) ;
                                        (0148) ;  SIDE EFFECTS: 
                                        (0149) ;    The A and X registers may be modified by this or future implementations
                                        (0150) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0151) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0152) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0153) ;    functions.
                                        (0154) ;
                                        (0155) ;  THEORY of OPERATION or PROCEDURE:
                                        (0156) ;     1) Set all Slave Select outputs high
                                        (0157) ;     2) Set the specified SPI configuration bits in the Control register.
                                        (0158) ;
                                        (0159)  SPIM_1_Start:
                                        (0160) _SPIM_1_Start:
                                        (0161)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0162)    ; setup the SPIM configuration setting
0489: 29 01    OR    A,0x1              (0163)    or    A, bfCONTROL_REG_START_BIT
048B: 60 2B    MOV   REG[0x2B],A        (0164)    mov   REG[SPIM_1_CONTROL_REG], A
                                        (0165)    RAM_EPILOGUE RAM_USE_CLASS_1
048D: 7F       RET                      (0166)    ret
                                        (0167) 
                                        (0168) .ENDSECTION
                                        (0169) 
                                        (0170) .SECTION
                                        (0171) ;-----------------------------------------------------------------------------
                                        (0172) ;  FUNCTION NAME: SPIM_1_Stop
                                        (0173) ;
                                        (0174) ;  DESCRIPTION:
                                        (0175) ;     Disables SPIM operation.
                                        (0176) ;
                                        (0177) ;-----------------------------------------------------------------------------
                                        (0178) ;
                                        (0179) ;  ARGUMENTS:  none
                                        (0180) ;
                                        (0181) ;  RETURNS:  none
                                        (0182) ;
                                        (0183) ;  SIDE EFFECTS: 
                                        (0184) ;    The A and X registers may be modified by this or future implementations
                                        (0185) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0186) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0187) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0188) ;    functions.
                                        (0189) ;
                                        (0190) ;  THEORY of OPERATION or PROCEDURE:
                                        (0191) ;     Clear the start bit in the Control register.
                                        (0192) ;
                                        (0193)  SPIM_1_Stop:
                                        (0194) _SPIM_1_Stop:
                                        (0195)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0196)    ; clear the SPIM stop bits
                                        (0197)    and   REG[SPIM_1_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                        (0198)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0199)    ret
                                        (0200) 
                                        (0201) .ENDSECTION
                                        (0202) 
                                        (0203) .SECTION
                                        (0204) ;-----------------------------------------------------------------------------
                                        (0205) ;  FUNCTION NAME: SPIM_1_SendTxData
                                        (0206) ;
                                        (0207) ;  DESCRIPTION:
                                        (0208) ;     Initiates an SPI data transfer.
                                        (0209) ;
                                        (0210) ;-----------------------------------------------------------------------------
                                        (0211) ;
                                        (0212) ;  ARGUMENTS:
                                        (0213) ;     BYTE  bTxData - data to transmit.
                                        (0214) ;        Passed in Accumulator.
                                        (0215) ;
                                        (0216) ;  RETURNS:  none
                                        (0217) ;
                                        (0218) ;  SIDE EFFECTS: 
                                        (0219) ;    The A and X registers may be modified by this or future implementations
                                        (0220) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0221) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0222) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0223) ;    functions.
                                        (0224) ;
                                        (0225) ;  THEORY of OPERATION or PROCEDURE:
                                        (0226) ;     Writes data to the TX buffer register.
                                        (0227) ;
                                        (0228)  SPIM_1_SendTxData:
                                        (0229) _SPIM_1_SendTxData:
                                        (0230)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0231)    ; Transmit the data!
048E: 60 29    MOV   REG[0x29],A        (0232)    mov REG[SPIM_1_TX_BUFFER_REG], A
                                        (0233)    RAM_EPILOGUE RAM_USE_CLASS_1
0490: 7F       RET                      (0234)    ret
                                        (0235) 
                                        (0236) .ENDSECTION
                                        (0237) 
                                        (0238) .SECTION
                                        (0239) ;-----------------------------------------------------------------------------
                                        (0240) ;  FUNCTION NAME: SPIM_1_bReadRxData
                                        (0241) ;
                                        (0242) ;  DESCRIPTION:
                                        (0243) ;     Reads the RX buffer register.  Should check the status regiser to make
                                        (0244) ;     sure data is valid.
                                        (0245) ;
                                        (0246) ;-----------------------------------------------------------------------------
                                        (0247) ;
                                        (0248) ;  ARGUMENTS:  none
                                        (0249) ;
                                        (0250) ;  RETURNS:
                                        (0251) ;     bRxData - returned in A.
                                        (0252) ;
                                        (0253) ;  SIDE EFFECTS: 
                                        (0254) ;    The A and X registers may be modified by this or future implementations
                                        (0255) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0256) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0257) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0258) ;    functions.
                                        (0259) ;
                                        (0260) ;  THEORY of OPERATION or PROCEDURE:
                                        (0261) ;
                                        (0262)  SPIM_1_bReadRxData:
                                        (0263) _SPIM_1_bReadRxData:
                                        (0264)  bSPIM_1_ReadRxData:
                                        (0265) _bSPIM_1_ReadRxData:
                                        (0266)    RAM_PROLOGUE RAM_USE_CLASS_1
0491: 5D 2A    MOV   A,REG[0x2A]        (0267)    mov A, REG[SPIM_1_RX_BUFFER_REG]
                                        (0268)    RAM_EPILOGUE RAM_USE_CLASS_1   
0493: 7F       RET                      (0269)    ret
                                        (0270) 
                                        (0271) 
                                        (0272) .ENDSECTION
                                        (0273) 
                                        (0274) .SECTION
                                        (0275) ;-----------------------------------------------------------------------------
                                        (0276) ;  FUNCTION NAME: SPIM_1_ReadStatus
                                        (0277) ;
                                        (0278) ;  DESCRIPTION:
                                        (0279) ;     Reads the SPIM Status bits in the Control/Status register.
                                        (0280) ;
                                        (0281) ;-----------------------------------------------------------------------------
                                        (0282) ;
                                        (0283) ;  ARGUMENTS:  none
                                        (0284) ;
                                        (0285) ;  RETURNS:
                                        (0286) ;     BYTE  bStatus - transmit status data.  Use the defined bit masks.
                                        (0287) ;        Returned in Accumulator.
                                        (0288) ;
                                        (0289) ;  SIDE EFFECTS: 
                                        (0290) ;    The A and X registers may be modified by this or future implementations
                                        (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0294) ;    functions.
                                        (0295) ;
                                        (0296) ;  THEORY of OPERATION or PROCEDURE:
                                        (0297) ;     Read the status and control register.
                                        (0298) ;
                                        (0299)  SPIM_1_bReadStatus:
                                        (0300) _SPIM_1_bReadStatus:
                                        (0301)  bSPIM_1_ReadStatus:
                                        (0302) _bSPIM_1_ReadStatus:
                                        (0303)    RAM_PROLOGUE RAM_USE_CLASS_1
0494: 5D 2B    MOV   A,REG[0x2B]        (0304)    mov A,  REG[SPIM_1_CONTROL_REG]
                                        (0305)    RAM_EPILOGUE RAM_USE_CLASS_1   
0496: 7F       RET                      (0306)    ret
                                        (0307) 
                                        (0308) .ENDSECTION
                                        (0309) 
                                        (0310) ; End of File SPIM_1.asm
FILE: lib\sleeptimer_1int.asm           (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   SleepTimer_1INT.asm
                                        (0004) ;;  Version: 1.0, Updated on 2015/3/4 at 22:26:59
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION:  SleepTimer Interrupt Service Routine.
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "SleepTimer_1.inc"
                                        (0014) include "memory.inc"
                                        (0015) include "m8c.inc"
                                        (0016) 
                                        (0017) ;-----------------------------------------------
                                        (0018) ;  Global Symbols
                                        (0019) ;-----------------------------------------------
                                        (0020) export  _SleepTimer_1_ISR
                                        (0021) 
                                        (0022) 
                                        (0023) export  SleepTimer_1_fTick
                                        (0024) export _SleepTimer_1_fTick
                                        (0025) export  SleepTimer_1_bTimerValue
                                        (0026) export _SleepTimer_1_bTimerValue
                                        (0027) export  SleepTimer_1_bCountDown
                                        (0028) export _SleepTimer_1_bCountDown
                                        (0029) export  SleepTimer_1_TickCount
                                        (0030) export _SleepTimer_1_TickCount
                                        (0031) 
                                        (0032) ;-----------------------------------------------
                                        (0033) ; Variable Allocation
                                        (0034) ;-----------------------------------------------
                                        (0035) AREA InterruptRAM (RAM, REL, CON)
                                        (0036) 
                                        (0037)  SleepTimer_1_fTick:
                                        (0038) _SleepTimer_1_fTick:        BLK  1
                                        (0039) 
                                        (0040)  SleepTimer_1_bTimerValue:
                                        (0041) _SleepTimer_1_bTimerValue:  BLK  1
                                        (0042) 
                                        (0043)  SleepTimer_1_bCountDown:
                                        (0044) _SleepTimer_1_bCountDown:   BLK  1
                                        (0045) 
                                        (0046)  SleepTimer_1_TickCount:
                                        (0047) _SleepTimer_1_TickCount:    BLK  SleepTimer_1_TICK_CNTR_SIZE
                                        (0048) 
                                        (0049) 
                                        (0050) 
                                        (0051) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0052) ;---------------------------------------------------
                                        (0053) ; Insert your custom declarations below this banner
                                        (0054) ;---------------------------------------------------
                                        (0055) 
                                        (0056) ;------------------------
                                        (0057) ;  Includes
                                        (0058) ;------------------------
                                        (0059) 
                                        (0060) 
                                        (0061) ;------------------------
                                        (0062) ;  Constant Definitions
                                        (0063) ;------------------------
                                        (0064) 
                                        (0065) 
                                        (0066) ;------------------------
                                        (0067) ; Variable Allocation
                                        (0068) ;------------------------
                                        (0069) 
                                        (0070) 
                                        (0071) ;---------------------------------------------------
                                        (0072) ; Insert your custom declarations above this banner
                                        (0073) ;---------------------------------------------------
                                        (0074) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0075) 
                                        (0076) 
                                        (0077) AREA UserModules (ROM, REL, CON)
                                        (0078) 
                                        (0079) ;-----------------------------------------------------------------------------
                                        (0080) ;  FUNCTION NAME: _SleepTimer_1_ISR
                                        (0081) ;
                                        (0082) ;  DESCRIPTION:
                                        (0083) ;      interrupt handler for instance SleepTimer_1.
                                        (0084) ;
                                        (0085) ;     This is a place holder function.  If the user requires use of an interrupt
                                        (0086) ;     handler for this function, then place code where specified.
                                        (0087) ;-----------------------------------------------------------------------------
                                        (0088) 
                                        (0089) _SleepTimer_1_ISR:
                                        (0090) 
0497: 2E 1E 01 OR    [0x1E],0x1         (0091)    or   [SleepTimer_1_fTick],0x01           ; Set tick flag
                                        (0092)  
                                        (0093)                                                 ; Decrement CountDown (Sync counter)
049A: 47 20 FF TST   [0x20],0xFF        (0094)    tst  [SleepTimer_1_bCountDown],0xFF
049D: A0 03    JZ    0x04A1             (0095)    jz   .DoTimer
049F: 7A 20    DEC   [0x20]             (0096)    dec  [SleepTimer_1_bCountDown]
                                        (0097) 
                                        (0098) .DoTimer:                                       ; Decrement TimerValue, if required
04A1: 47 1F FF TST   [0x1F],0xFF        (0099)    tst  [SleepTimer_1_bTimerValue],0xFF
04A4: A0 03    JZ    0x04A8             (0100)    jz   .IncBigCounter
04A6: 7A 1F    DEC   [0x1F]             (0101)    dec  [SleepTimer_1_bTimerValue]
                                        (0102) 
                                        (0103) .IncBigCounter:                                 ; Increment big tick counter
                                        (0104) IF (SleepTimer_1_TICK_CNTR_SIZE & 0x04)
                                        (0105)    inc  [SleepTimer_1_TickCount+3]
                                        (0106)    jnc  SleepTimer_1_SLEEP_ISR_END
                                        (0107) 
                                        (0108)    inc  [SleepTimer_1_TickCount+2]
                                        (0109)    jnc  SleepTimer_1_SLEEP_ISR_END
                                        (0110) ENDIF
                                        (0111) 
                                        (0112) IF (SleepTimer_1_TICK_CNTR_SIZE & (0x04|0x02))
04A8: 76 22    INC   [0x22]             (0113)    inc  [SleepTimer_1_TickCount+1]
04AA: D0 03    JNC   0x04AE             (0114)    jnc  SleepTimer_1_SLEEP_ISR_END
                                        (0115) ENDIF
                                        (0116) 
04AC: 76 21    INC   [0x21]             (0117)    inc  [SleepTimer_1_TickCount+0]
                                        (0118) 
                                        (0119) SleepTimer_1_SLEEP_ISR_END:
                                        (0120) 
                                        (0121)    ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
                                        (0122)    ;---------------------------------------------------
                                        (0123)    ; Insert your custom assembly code below this banner
                                        (0124)    ;---------------------------------------------------
                                        (0125)    ;   NOTE: interrupt service routines must preserve
                                        (0126)    ;   the values of the A and X CPU registers.
                                        (0127)    
                                        (0128)    ;---------------------------------------------------
                                        (0129)    ; Insert your custom assembly code above this banner
                                        (0130)    ;---------------------------------------------------
                                        (0131)    
                                        (0132)    ;---------------------------------------------------
                                        (0133)    ; Insert a lcall to a C function below this banner
                                        (0134)    ; and un-comment the lines between these banners
                                        (0135)    ;---------------------------------------------------
                                        (0136)    
                                        (0137)    ;PRESERVE_CPU_CONTEXT
04AE: 7D 1C 81 LJMP  _Sleep_Timer_Interrupt(0138)    ljmp _Sleep_Timer_Interrupt
                                        (0139)    ;RESTORE_CPU_CONTEXT
                                        (0140)    
                                        (0141)    ;---------------------------------------------------
                                        (0142)    ; Insert a lcall to a C function above this banner
                                        (0143)    ; and un-comment the lines between these banners
                                        (0144)    ;---------------------------------------------------
                                        (0145)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0146) 
04B1: 7E       RETI                     (0147)    reti
                                        (0148) 
                                        (0149) ; end of file SleepTimer_1INT.asm
                                        (0150) 
FILE: lib\sleeptimer_1.asm              (0001) ;;*****************************************************************************
04B2: 43 E0 40 OR    REG[0xE0],0x40     (0002) ;;*****************************************************************************
                                        (0003) ;;  Filename:   SleepTimer_1.asm
                                        (0004) ;;  Version: 1.0, Updated on 2015/3/4 at 22:26:59
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION:  SleepTimer User Module software implementation file for the
                                        (0008) ;;                22/24/27/29xxx families.
                                        (0009) ;;
                                        (0010) ;;
                                        (0011) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0012) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0013) ;;        This means it is the caller's responsibility to preserve any values
                                        (0014) ;;        in the X and A registers that are still needed after the API functions
                                        (0015) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0016) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0017) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0018) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0019) ;;-----------------------------------------------------------------------------
                                        (0020) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0021) ;;*****************************************************************************
                                        (0022) ;;*****************************************************************************
                                        (0023) 
                                        (0024) 
                                        (0025) include "m8c.inc"
                                        (0026) include "memory.inc"
                                        (0027) include "SleepTimer_1.inc"
                                        (0028) 
                                        (0029) ;-----------------------------------------------
                                        (0030) ;  Global Symbols
                                        (0031) ;-----------------------------------------------
                                        (0032) ;-------------------------------------------------------------------
                                        (0033) ;  Declare the functions global for both assembler and C compiler.
                                        (0034) ;
                                        (0035) ;  Note that there are two names for each API. First name is
                                        (0036) ;  assembler reference. Name with underscore is name reference for
                                        (0037) ;  C compiler.  Calling function in C source code does not require
                                        (0038) ;  the underscore.
                                        (0039) ;-------------------------------------------------------------------
                                        (0040) export  SleepTimer_1_EnableInt
                                        (0041) export _SleepTimer_1_EnableInt
                                        (0042) export  SleepTimer_1_DisableInt
                                        (0043) export _SleepTimer_1_DisableInt
                                        (0044) 
                                        (0045) export  SleepTimer_1_Start
                                        (0046) export _SleepTimer_1_Start
                                        (0047) export  SleepTimer_1_Stop
                                        (0048) export _SleepTimer_1_Stop
                                        (0049) 
                                        (0050) export  SleepTimer_1_TickWait
                                        (0051) export _SleepTimer_1_TickWait
                                        (0052) 
                                        (0053) export  SleepTimer_1_SyncWait
                                        (0054) export _SleepTimer_1_SyncWait
                                        (0055) 
                                        (0056) export  SleepTimer_1_SetInterval
                                        (0057) export _SleepTimer_1_SetInterval
                                        (0058) 	
                                        (0059) export  SleepTimer_1_bGetTickCntr
                                        (0060) export _SleepTimer_1_bGetTickCntr
                                        (0061) 
                                        (0062) export  SleepTimer_1_SetTimer
                                        (0063) export _SleepTimer_1_SetTimer
                                        (0064) 
                                        (0065) export  SleepTimer_1_bGetTimer
                                        (0066) export _SleepTimer_1_bGetTimer
                                        (0067) 
                                        (0068) IF(SleepTimer_1_TICK_CNTR_SIZE & (4|2))
                                        (0069) export  SleepTimer_1_iGetTickCntr
                                        (0070) export _SleepTimer_1_iGetTickCntr
                                        (0071) ENDIF
                                        (0072) 
                                        (0073) IF(SleepTimer_1_TICK_CNTR_SIZE & 4)
                                        (0074) export  SleepTimer_1_lGetTickCntr
                                        (0075) export _SleepTimer_1_lGetTickCntr
                                        (0076) ENDIF
                                        (0077) 
                                        (0078) 
                                        (0079) area text (ROM,REL)
                                        (0080) 
                                        (0081) ;-----------------------------------------------
                                        (0082) ;  EQUATES
                                        (0083) ;-----------------------------------------------
                                        (0084) 
                                        (0085) ; Counter LSB Offset if 4 byte tick counter
                                        (0086) IF(SleepTimer_1_TICK_CNTR_SIZE & 4)
                                        (0087) ST_LSB_OFFSET:   equ  3
                                        (0088) ENDIF
                                        (0089) 
                                        (0090) ; Counter LSB Offset if 2 byte tick counter
                                        (0091) IF(SleepTimer_1_TICK_CNTR_SIZE & 2)
                                        (0092) ST_LSB_OFFSET:   equ  1
                                        (0093) ENDIF
                                        (0094) 
                                        (0095) ; Counter LSB Offset if 1 byte tick counter
                                        (0096) IF(SleepTimer_1_TICK_CNTR_SIZE & 1)
                                        (0097) ST_LSB_OFFSET:   equ  0
                                        (0098) ENDIF
                                        (0099) 
                                        (0100) 
                                        (0101) area UserModules (ROM, REL, CON)
                                        (0102) 
                                        (0103) ;=============================================================================
                                        (0104) ;=============================================================================
                                        (0105) ;
                                        (0106) ;     Low-Level Commands
                                        (0107) ;
                                        (0108) ;=============================================================================
                                        (0109) ;=============================================================================
                                        (0110) 
                                        (0111) .SECTION
                                        (0112) ;-----------------------------------------------------------------------------
                                        (0113) ;  FUNCTION NAME: SleepTimer_1_EnableInt
                                        (0114) ;
                                        (0115) ;  DESCRIPTION:
                                        (0116) ;     Enables SleepTimer interrupts.
                                        (0117) ;-----------------------------------------------------------------------------
                                        (0118) ;
                                        (0119) ;  ARGUMENTS:
                                        (0120) ;     none.
                                        (0121) ;
                                        (0122) ;  RETURNS:
                                        (0123) ;     none.
                                        (0124) ;
                                        (0125) ;  SIDE EFFECTS:
                                        (0126) ;     REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0127) ;
                                        (0128) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0129) ;
                                        (0130)  SleepTimer_1_EnableInt:
                                        (0131) _SleepTimer_1_EnableInt:
                                        (0132)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0133)    M8C_EnableIntMask SleepTimer_1_INT_REG, SleepTimer_1_INT_MASK
                                        (0134)    RAM_EPILOGUE RAM_USE_CLASS_1
04B5: 7F       RET                      (0135)    ret
                                        (0136) .ENDSECTION
                                        (0137) 
                                        (0138)     
                                        (0139) .SECTION
                                        (0140) ;-----------------------------------------------------------------------------
                                        (0141) ;  FUNCTION NAME: SleepTimer_1_DisableInt
                                        (0142) ;
                                        (0143) ;  DESCRIPTION:
                                        (0144) ;     Disables the sleep timer. 
                                        (0145) ;
                                        (0146) ;-----------------------------------------------------------------------------
                                        (0147) ;
                                        (0148) ;  ARGUMENTS:
                                        (0149) ;     none.
                                        (0150) ;
                                        (0151) ;  RETURNS:
                                        (0152) ;     none.
                                        (0153) ;
                                        (0154) ;  SIDE EFFECTS:
                                        (0155) ;     REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0156) ;
                                        (0157) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0158) ;
                                        (0159)  SleepTimer_1_DisableInt:
                                        (0160) _SleepTimer_1_DisableInt:
                                        (0161)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0162)    M8C_DisableIntMask SleepTimer_1_INT_REG, SleepTimer_1_INT_MASK
                                        (0163)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0164)    ret
                                        (0165) .ENDSECTION
                                        (0166) 
                                        (0167) 
                                        (0168) .SECTION
                                        (0169) ;-----------------------------------------------------------------------------
                                        (0170) ;  FUNCTION NAME: SleepTimer_1_Start()
                                        (0171) ;
                                        (0172) ;  DESCRIPTION:
                                        (0173) ;     Clears all the variables.  
                                        (0174) ;-----------------------------------------------------------------------------
                                        (0175) ;
                                        (0176) ;  ARGUMENTS:
                                        (0177) ;      none
                                        (0178) ;
                                        (0179) ;  RETURNS:
                                        (0180) ;     none.
                                        (0181) ;
                                        (0182) ;  SIDE EFFECTS;    
                                        (0183) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0184) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0185) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0186) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0187) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0188) ;          
                                        (0189) ;    Page Pointer Registers Modified: 
                                        (0190) ;          CUR_PP
                                        (0191) ;
                                        (0192) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0193) ;
                                        (0194)  SleepTimer_1_Start:
                                        (0195) _SleepTimer_1_Start:
                                        (0196)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0197)    RAM_SETPAGE_CUR >SleepTimer_1_fTick      
04B6: 50 00    MOV   A,0x0              (0198)    mov  A,0
04B8: 53 1E    MOV   [0x1E],A           (0199)    mov  [SleepTimer_1_fTick],A
04BA: 53 1F    MOV   [0x1F],A           (0200)    mov  [SleepTimer_1_bTimerValue],A
04BC: 53 20    MOV   [0x20],A           (0201)    mov  [SleepTimer_1_bCountDown],A
04BE: 53 22    MOV   [0x22],A           (0202)    mov  [SleepTimer_1_TickCount + ST_LSB_OFFSET],A        ; Clear TickCount[0:7]
                                        (0203) IF(SleepTimer_1_TICK_CNTR_SIZE & (4|2))
04C0: 53 21    MOV   [0x21],A           (0204)    mov  [SleepTimer_1_TickCount + ST_LSB_OFFSET - 1],A    ; Clear TickCount[8:15]
                                        (0205) ENDIF
                                        (0206) 
                                        (0207) 
                                        (0208) IF(SleepTimer_1_TICK_CNTR_SIZE & 4)
                                        (0209)    mov   [SleepTimer_1_TickCount + ST_LSB_OFFSET - 2],A    ; Clear TickCount[16:31]
                                        (0210)    mov   [SleepTimer_1_TickCount + ST_LSB_OFFSET - 3],A    
                                        (0211) ENDIF
                                        (0212) 
                                        (0213) 
                                        (0214)    RAM_EPILOGUE RAM_USE_CLASS_4
04C2: 7F       RET                      (0215)    ret
                                        (0216) .ENDSECTION
                                        (0217) 
                                        (0218) 
                                        (0219) .SECTION
                                        (0220) ;-----------------------------------------------------------------------------
                                        (0221) ;  FUNCTION NAME: SleepTimer_1_Stop
                                        (0222) ;
                                        (0223) ;  DESCRIPTION:
                                        (0224) ;   This function does nothing at this time.  It is only here as a place 
                                        (0225) ;   holder.
                                        (0226) ;-----------------------------------------------------------------------------
                                        (0227) ;
                                        (0228) ;  ARGUMENTS:
                                        (0229) ;     none.
                                        (0230) ;
                                        (0231) ;  RETURNS:
                                        (0232) ;     none.
                                        (0233) ;
                                        (0234) ;  SIDE EFFECTS:
                                        (0235) ;     REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0236) ;
                                        (0237) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0238) ;
                                        (0239)  SleepTimer_1_Stop:
                                        (0240) _SleepTimer_1_Stop:
                                        (0241)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0242)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0243)    ret
                                        (0244) .ENDSECTION
                                        (0245) 
                                        (0246) .SECTION
                                        (0247) ;-----------------------------------------------------------------------------
                                        (0248) ;  FUNCTION NAME: SleepTimer_1_SetInterval
                                        (0249) ;
                                        (0250) ;  DESCRIPTION:
                                        (0251) ;     Sets sleep timer interval
                                        (0252) ;
                                        (0253) ;-----------------------------------------------------------------------------
                                        (0254) ;
                                        (0255) ;  ARGUMENTS:
                                        (0256) ;     A <= Timer setting
                                        (0257) ;
                                        (0258) ;  RETURNS:
                                        (0259) ;     none.
                                        (0260) ;
                                        (0261) ;  SIDE EFFECTS:
                                        (0262) ;     REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0263) ;
                                        (0264) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0265) ;
                                        (0266)  SleepTimer_1_SetInterval:
                                        (0267) _SleepTimer_1_SetInterval:
                                        (0268)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0269)    and  A,SleepTimer_1_CLOCK_MASK               ; Mask off invalid data
                                        (0270)    mov  X, SP
                                        (0271)    push A
                                        (0272)    M8C_SetBank1
                                        (0273)    mov  A, reg[OSC_CR0]                  ; Get current timer value
                                        (0274)    and  A,~SleepTimer_1_CLOCK_MASK   ; Zero out old timer value
                                        (0275)    or   A, [X]                           ; Set new timer values
                                        (0276)    mov  reg[OSC_CR0],A                   ; Write it
                                        (0277)    M8C_SetBank0
                                        (0278)    pop  A
                                        (0279)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0280)    ret
                                        (0281) .ENDSECTION
                                        (0282) 
                                        (0283) 
                                        (0284) .SECTION
                                        (0285) ;-----------------------------------------------------------------------------
                                        (0286) ;  FUNCTION NAME: SleepTimer_1_TickWait(BYTE bTicks)
                                        (0287) ;
                                        (0288) ;  DESCRIPTION:
                                        (0289) ;     Wait X Ticks and return
                                        (0290) ;
                                        (0291) ;-----------------------------------------------------------------------------
                                        (0292) ;
                                        (0293) ;  ARGUMENTS:
                                        (0294) ;     A <= Count down time
                                        (0295) ;
                                        (0296) ;  RETURNS:
                                        (0297) ;     none.
                                        (0298) ;
                                        (0299) ;  SIDE EFFECTS;    
                                        (0300) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0301) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0302) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0303) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0304) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0305) ;          
                                        (0306) ;    Page Pointer Registers Modified: 
                                        (0307) ;          CUR_PP
                                        (0308) ;
                                        (0309) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0310) ;
                                        (0311)  SleepTimer_1_TickWait:
                                        (0312) _SleepTimer_1_TickWait:
                                        (0313)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0314)    RAM_SETPAGE_CUR >SleepTimer_1_fTick      
04C3: 55 1E 00 MOV   [0x1E],0x0         (0315)    mov   [SleepTimer_1_fTick],0x00          ; Clear tick flag
                                        (0316) 
                                        (0317) .WaitTick:
04C6: 47 1E FF TST   [0x1E],0xFF        (0318)    tst   [SleepTimer_1_fTick],0xFF          ; Check for tick 
04C9: AF FC    JZ    0x04C6             (0319)    jz    .WaitTick
04CB: 55 1E 00 MOV   [0x1E],0x0         (0320)    mov   [SleepTimer_1_fTick],0x00          ; Clear tick flag
04CE: 78       DEC   A                  (0321)    dec   A                                      ; Dec the timer variable
04CF: BF F6    JNZ   0x04C6             (0322)    jnz   .WaitTick                              ; Loop until we count down to zero
                                        (0323) 
                                        (0324)    RAM_EPILOGUE RAM_USE_CLASS_4
04D1: 7F       RET                      (0325)    ret
                                        (0326) .ENDSECTION
                                        (0327) 
                                        (0328) 
                                        (0329) .SECTION
                                        (0330) ;-----------------------------------------------------------------------------
                                        (0331) ;  FUNCTION NAME: SleepTimer_1_SyncWait(BYTE bCounts, BYTE fMode)
                                        (0332) ;
                                        (0333) ;  DESCRIPTION:
                                        (0334) ;     This function resets the SyncWait timer.  If fMode = 0, the timer
                                        (0335) ;     is set to the new value then exits the function immediatly.  If fMode
                                        (0336) ;     is set to 1, the firmware waits for the timer to expire before the
                                        (0337) ;     timer is reset and and exits.
                                        (0338) ;
                                        (0339) ;-----------------------------------------------------------------------------
                                        (0340) ;
                                        (0341) ;  ARGUMENTS:
                                        (0342) ;     A <= tCounts to wait
                                        (0343) ;     X <= fMode    fMode = 0  Just reload the value, do not wait
                                        (0344) ;                   fMode = 1  Wait for last value to count down to zero
                                        (0345) ;                              then reload.
                                        (0346) ;
                                        (0347) ;  RETURNS:
                                        (0348) ;     none.
                                        (0349) ;
                                        (0350) ;  SIDE EFFECTS;    
                                        (0351) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0352) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0353) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0354) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0355) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0356) ;          
                                        (0357) ;    Page Pointer Registers Modified: 
                                        (0358) ;          CUR_PP
                                        (0359) ;
                                        (0360) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0361) ;
                                        (0362)  SleepTimer_1_SyncWait:
                                        (0363) _SleepTimer_1_SyncWait:
                                        (0364)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0365)    RAM_SETPAGE_CUR >SleepTimer_1_bCountDown
                                        (0366)    swap  A,X
                                        (0367)    AND   A,SleepTimer_1_FORCE_RELOAD
                                        (0368)    jnz   .ReloadIt
                                        (0369) 
                                        (0370) .WaitLoop:
                                        (0371)    tst   [SleepTimer_1_bCountDown],0xFF
                                        (0372)    jnz   .WaitLoop
                                        (0373) 
                                        (0374) 
                                        (0375) .ReloadIt:
                                        (0376)    swap  A,X
                                        (0377)    mov   [SleepTimer_1_bCountDown],A 
                                        (0378) 
                                        (0379)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0380)    ret
                                        (0381) .ENDSECTION
                                        (0382) 
                                        (0383) 
                                        (0384) 
                                        (0385) .SECTION
                                        (0386) ;-----------------------------------------------------------------------------
                                        (0387) ;  FUNCTION NAME: SleepTimer_1_bGetTickCntr
                                        (0388) ;
                                        (0389) ;  DESCRIPTION:
                                        (0390) ;     Returns the LSB of the tick Counter
                                        (0391) ;
                                        (0392) ;-----------------------------------------------------------------------------
                                        (0393) ;
                                        (0394) ;  ARGUMENTS:
                                        (0395) ;     none
                                        (0396) ;
                                        (0397) ;  RETURNS:
                                        (0398) ;     LSB of lTickCount
                                        (0399) ;
                                        (0400) ;  SIDE EFFECTS;    
                                        (0401) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0402) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0403) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0404) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0405) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0406) ;          
                                        (0407) ;    Page Pointer Registers Modified: 
                                        (0408) ;          CUR_PP
                                        (0409) ;
                                        (0410) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0411) ;
                                        (0412)  SleepTimer_1_bGetTickCntr:
                                        (0413) _SleepTimer_1_bGetTickCntr:
                                        (0414)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0415)    RAM_SETPAGE_CUR >SleepTimer_1_TickCount
                                        (0416)    mov   A,[SleepTimer_1_TickCount + ST_LSB_OFFSET]
                                        (0417)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0418)    ret
                                        (0419) .ENDSECTION
                                        (0420) 
                                        (0421) .SECTION
                                        (0422) ;-----------------------------------------------------------------------------
                                        (0423) ;  FUNCTION NAME: SleepTimer_1_SetTimer
                                        (0424) ;
                                        (0425) ;  DESCRIPTION:
                                        (0426) ;     Set timer with parameter in A
                                        (0427) ;
                                        (0428) ;-----------------------------------------------------------------------------
                                        (0429) ;
                                        (0430) ;  ARGUMENTS:
                                        (0431) ;     A => Value used to set Timer value
                                        (0432) ;
                                        (0433) ;  RETURNS:
                                        (0434) ;     None
                                        (0435) ;
                                        (0436) ;  SIDE EFFECTS;    
                                        (0437) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0438) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0439) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0440) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0441) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0442) ;          
                                        (0443) ;    Page Pointer Registers Modified: 
                                        (0444) ;          CUR_PP
                                        (0445) ;
                                        (0446) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0447) ;
                                        (0448)  SleepTimer_1_SetTimer:
                                        (0449) _SleepTimer_1_SetTimer:
                                        (0450)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0451)    RAM_SETPAGE_CUR >SleepTimer_1_TickCount
                                        (0452)    mov   [SleepTimer_1_bTimerValue],A
                                        (0453)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0454)    ret
                                        (0455) .ENDSECTION
                                        (0456) 
                                        (0457) .SECTION
                                        (0458) ;-----------------------------------------------------------------------------
                                        (0459) ;  FUNCTION NAME: SleepTimer_1_bGetTimer
                                        (0460) ;
                                        (0461) ;  DESCRIPTION:
                                        (0462) ;     Returns timer value in A
                                        (0463) ;
                                        (0464) ;-----------------------------------------------------------------------------
                                        (0465) ;
                                        (0466) ;  ARGUMENTS:
                                        (0467) ;     None
                                        (0468) ;
                                        (0469) ;  RETURNS:
                                        (0470) ;     Return timer value in A
                                        (0471) ;
                                        (0472) ;  SIDE EFFECTS;    
                                        (0473) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0474) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0475) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0476) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0477) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0478) ;          
                                        (0479) ;    Page Pointer Registers Modified: 
                                        (0480) ;          CUR_PP
                                        (0481) ;
                                        (0482) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0483) ;
                                        (0484)  SleepTimer_1_bGetTimer:
                                        (0485) _SleepTimer_1_bGetTimer:
                                        (0486)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0487)    RAM_SETPAGE_CUR >SleepTimer_1_TickCount
                                        (0488)    mov   A,[SleepTimer_1_bTimerValue]
                                        (0489)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0490)    ret
                                        (0491) .ENDSECTION
                                        (0492) 
                                        (0493) IF(SleepTimer_1_TICK_CNTR_SIZE & (4|2))
                                        (0494) .SECTION
                                        (0495) ;-----------------------------------------------------------------------------
                                        (0496) ;  FUNCTION NAME: SleepTimer_1_iGetTickCntr
                                        (0497) ;
                                        (0498) ;  DESCRIPTION:
                                        (0499) ;     Returns the least significant 16 bits.
                                        (0500) ;
                                        (0501) ;-----------------------------------------------------------------------------
                                        (0502) ;
                                        (0503) ;  ARGUMENTS:
                                        (0504) ;     none
                                        (0505) ;
                                        (0506) ;  RETURNS:
                                        (0507) ;     (int)TickCount in A and X  
                                        (0508) ;     X  <= MSB
                                        (0509) ;     A  <= LSB
                                        (0510) ;
                                        (0511) ;  SIDE EFFECTS;    
                                        (0512) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0513) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0514) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0515) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0516) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0517) ;          
                                        (0518) ;    Page Pointer Registers Modified: 
                                        (0519) ;          CUR_PP
                                        (0520) ;
                                        (0521) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0522) ;
                                        (0523)  SleepTimer_1_iGetTickCntr:
                                        (0524) _SleepTimer_1_iGetTickCntr:
                                        (0525)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0526)    RAM_SETPAGE_CUR >SleepTimer_1_TickCount
                                        (0527)    ; Disable interrupt here
                                        (0528)    M8C_DisableIntMask SleepTimer_1_INT_REG, SleepTimer_1_INT_MASK
                                        (0529)    mov   A,[SleepTimer_1_TickCount + ST_LSB_OFFSET]    ; Place LSB in A
                                        (0530)    mov   X,[SleepTimer_1_TickCount + ST_LSB_OFFSET - 1]    ; Place MSB in X
                                        (0531)    M8C_EnableIntMask SleepTimer_1_INT_REG, SleepTimer_1_INT_MASK
                                        (0532)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0533)    ret
                                        (0534) .ENDSECTION
                                        (0535) ENDIF
                                        (0536) 
                                        (0537) IF(SleepTimer_1_TICK_CNTR_SIZE & 4)
                                        (0538) .SECTION
                                        (0539) ;-----------------------------------------------------------------------------
                                        (0540) ;  FUNCTION NAME: SleepTimer_1_lGetTickCntr
                                        (0541) ;
                                        (0542) ;  DESCRIPTION:
                                        (0543) ;     Returns a pointer to TickCount
                                        (0544) ;
                                        (0545) ;-----------------------------------------------------------------------------
                                        (0546) ;
                                        (0547) ;  ARGUMENTS:
                                        (0548) ;     [A:X] => Pointer to 32 bit tick counter (X=LSB, A=MSB)
                                        (0549) ;
                                        (0550) ;  RETURNS:
                                        (0551) ;     Pointer to lTickCount
                                        (0552) ;
                                        (0553) ;  SIDE EFFECTS;    
                                        (0554) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0555) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0556) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0557) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0558) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0559) ;          
                                        (0560) ;    Page Pointer Registers Modified: 
                                        (0561) ;          CUR_PP
                                        (0562) ;
                                        (0563) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0564) ;
                                        (0565)  SleepTimer_1_lGetTickCntr:
                                        (0566) _SleepTimer_1_lGetTickCntr:
                                        (0567)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0568)    RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0569)    ; Disable interrupt here
                                        (0570)    M8C_DisableIntMask SleepTimer_1_INT_REG, SleepTimer_1_INT_MASK
                                        (0571)    RAM_SETPAGE_CUR >SleepTimer_1_TickCount
                                        (0572)    RAM_SETPAGE_IDX A
                                        (0573)    push  A
                                        (0574)    mov   A,[SleepTimer_1_TickCount + 0]
                                        (0575)    mov   [X + 0],A
                                        (0576)    mov   A,[SleepTimer_1_TickCount + 1]
                                        (0577)    mov   [X + 1],A
                                        (0578)    mov   A,[SleepTimer_1_TickCount + 2]
                                        (0579)    mov   [X + 2],A
                                        (0580)    mov   A,[SleepTimer_1_TickCount + 3]
                                        (0581)    mov   [X + 3],A
                                        (0582)    pop   A
                                        (0583)    
                                        (0584)    M8C_EnableIntMask SleepTimer_1_INT_REG, SleepTimer_1_INT_MASK
                                        (0585)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0586)    RAM_EPILOGUE RAM_USE_CLASS_3
                                        (0587)    ret
                                        (0588) .ENDSECTION
                                        (0589) ENDIF
                                        (0590) 
                                        (0591) 
                                        (0592) 
                                        (0593) 
                                        (0594) ; End of File SleepTimer_1.asm
FILE: lib\rx8_1int.asm                  (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: RX8_1INT.asm
                                        (0004) ;;   Version: 3.50, Updated on 2015/3/4 at 22:26:55
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "memory.inc"
                                        (0015) include "RX8_1.inc"
                                        (0016) 
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export  _RX8_1_ISR
                                        (0022) 
                                        (0023) 
                                        (0024) IF (RX8_1_RXBUF_ENABLE)
                                        (0025) export  RX8_1_aRxBuffer
                                        (0026) export _RX8_1_aRxBuffer
                                        (0027) export  RX8_1_bRxCnt
                                        (0028) export _RX8_1_bRxCnt
                                        (0029) export  RX8_1_fStatus
                                        (0030) export _RX8_1_fStatus
                                        (0031) ENDIF
                                        (0032) 
                                        (0033) 
                                        (0034) ;-----------------------------------------------
                                        (0035) ; Variable Allocation
                                        (0036) ;-----------------------------------------------
                                        (0037) 
                                        (0038) IF (RX8_1_RXBUF_ENABLE)
                                        (0039) AREA InterruptRAM(RAM,REL,CON)
                                        (0040)  RX8_1_fStatus:
                                        (0041) _RX8_1_fStatus:      BLK  1
                                        (0042)  RX8_1_bRxCnt:
                                        (0043) _RX8_1_bRxCnt:       BLK  1
                                        (0044) AREA RX8_1_RAM(RAM,REL,CON)
                                        (0045)  RX8_1_aRxBuffer:    
                                        (0046) _RX8_1_aRxBuffer:    BLK RX8_1_RX_BUFFER_SIZE
                                        (0047) ENDIF
                                        (0048) 
                                        (0049) 
                                        (0050) AREA InterruptRAM(RAM,REL,CON)
                                        (0051) 
                                        (0052) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0053) ;---------------------------------------------------
                                        (0054) ; Insert your custom declarations below this banner
                                        (0055) ;---------------------------------------------------
                                        (0056) 
                                        (0057) ;------------------------
                                        (0058) ; Includes
                                        (0059) ;------------------------
                                        (0060) 
                                        (0061) 	
                                        (0062) ;------------------------
                                        (0063) ;  Constant Definitions
                                        (0064) ;------------------------
                                        (0065) 
                                        (0066) 
                                        (0067) ;------------------------
                                        (0068) ; Variable Allocation
                                        (0069) ;------------------------
                                        (0070) 
                                        (0071) 
                                        (0072) ;---------------------------------------------------
                                        (0073) ; Insert your custom declarations above this banner
                                        (0074) ;---------------------------------------------------
                                        (0075) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0076) 
                                        (0077) 
                                        (0078) AREA UserModules (ROM, REL)
                                        (0079) 
                                        (0080) ;-----------------------------------------------------------------------------
                                        (0081) ;  FUNCTION NAME: _RX8_1_ISR
                                        (0082) ;
                                        (0083) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0084) ;
                                        (0085) ;-----------------------------------------------------------------------------
                                        (0086) ;
                                        (0087) 
                                        (0088) _RX8_1_ISR:
                                        (0089) 
                                        (0090)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0091)    ;---------------------------------------------------
                                        (0092)    ; Insert your custom assembly code below this banner
                                        (0093)    ;---------------------------------------------------
                                        (0094)    ;   NOTE: interrupt service routines must preserve
                                        (0095)    ;   the values of the A and X CPU registers.
                                        (0096)    
                                        (0097)    ;---------------------------------------------------
                                        (0098)    ; Insert your custom assembly code above this banner
                                        (0099)    ;---------------------------------------------------
                                        (0100)    
                                        (0101)    ;---------------------------------------------------
                                        (0102)    ; Insert a lcall to a C function below this banner
                                        (0103)    ; and un-comment the lines between these banners
                                        (0104)    ;---------------------------------------------------
                                        (0105)    
                                        (0106)    ;PRESERVE_CPU_CONTEXT
04D2: 7D 1B 12 LJMP  _RX8_1_Interrupt   (0107)    ljmp _RX8_1_Interrupt
                                        (0108)    ;RESTORE_CPU_CONTEXT
                                        (0109)    
                                        (0110)    ;---------------------------------------------------
                                        (0111)    ; Insert a lcall to a C function above this banner
                                        (0112)    ; and un-comment the lines between these banners
                                        (0113)    ;---------------------------------------------------
                                        (0114)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0115) 
                                        (0116)  IF (RX8_1_RXBUF_ENABLE)
                                        (0117)    push A
                                        (0118)    push X
                                        (0119) 
                                        (0120)    IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0121)       REG_PRESERVE IDX_PP                                  ; Save the IDX_PP register	
                                        (0122)    ENDIF
                                        (0123) 
                                        (0124)    mov  X,[RX8_1_bRxCnt]                                   ; Load X with byte counter
                                        (0125)    mov  A,REG[RX8_1_CONTROL_REG]                           ; Read the control register
                                        (0126)    push A                                                  ; Store copy for later test
                                        (0127)                                                            ; IF real RX interrupt
                                        (0128)    and  A,RX8_1_RX_REG_FULL                                ; Did really really get an IRQ
                                        (0129)    jnz  .UARTRX_ReadRx                                     ; Data ready, go get it
                                        (0130)    pop  A                                                  ; Restore stack
                                        (0131)    jmp  .RESTORE_IDX_PP
                                        (0132) 
                                        (0133) .UARTRX_ReadRx:
                                        (0134) 
                                        (0135)    pop  A                                                  ; Restore status flags
                                        (0136)                                                            ; IF there is no error, get data
                                        (0137)                                                            ; Check for parity or framing error
                                        (0138)    and  A,RX8_1_RX_ERROR
                                        (0139)    jz   .UARTRX_NO_ERROR                                   ; If there is not an Error go read data
                                        (0140) 
                                        (0141)    or   [RX8_1_fStatus],A                                  ; Set error flags (parity,framing,overrun) bits
                                        (0142) 
                                        (0143)    tst  REG[RX8_1_RX_BUFFER_REG], 0x00                     ; Read the data buffer to clear it.
                                        (0144) 
                                        (0145)    and  A,RX8_1_RX_FRAMING_ERROR                           ; Check for framing error special case
                                        (0146)    jz   .RESTORE_IDX_PP                                    ; Not framing error, all done
                                        (0147) 
                                        (0148)                                                            ; Disable and re-enable RX to reset after
                                        (0149)                                                            ; framing error.
                                        (0150)    and   REG[RX8_1_CONTROL_REG], ~RX8_1_RX_ENABLE          ; Disable RX
                                        (0151)    or    REG[RX8_1_CONTROL_REG],  RX8_1_RX_ENABLE          ; Enable RX
                                        (0152)    jmp  .RESTORE_IDX_PP                                    ; Done with framing error, leave.
                                        (0153) 
                                        (0154) 
                                        (0155) .UARTRX_NO_ERROR:
                                        (0156)    mov  A,REG[RX8_1_RX_BUFFER_REG ]                        ; Read the data buffer
                                        (0157) 
                                        (0158)                                                            ; IF buffer not full
                                        (0159)    tst  [RX8_1_fStatus],RX8_1_RX_BUF_CMDTERM               ; Check for buffer full
                                        (0160)    jnz  .RESTORE_IDX_PP                                    ; All done
                                        (0161) 
                                        (0162)    cmp  A,RX8_1_CMD_TERM                                   ; Check for End of command
                                        (0163)    jnz  .UARTRX_CHK_CTLCHAR
                                        (0164)    or   [RX8_1_fStatus],RX8_1_RX_BUF_CMDTERM               ; Set command ready bit
                                        (0165) 
                                        (0166)    RAM_SETPAGE_IDX >RX8_1_aRxBuffer
                                        (0167)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
                                        (0168)    mov  [X + RX8_1_aRxBuffer],00h                          ; Zero out last data
                                        (0169)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
                                        (0170)    jmp  .RESTORE_IDX_PP
                                        (0171) 
                                        (0172) .UARTRX_CHK_CTLCHAR:                                       ; Ignore charaters below this value
                                        (0173)                                                            ; If ignore char is set to 0x00, do not
                                        (0174)                                                            ; ignore any characters.
                                        (0175) IF(RX8_1_RX_IGNORE_BELOW)
                                        (0176)    cmp  A,RX8_1_RX_IGNORE_BELOW
                                        (0177)    jc   .RESTORE_IDX_PP
                                        (0178) ENDIF
                                        (0179) 
                                        (0180) .UARTRX_CHK_OVFL:                                          ; Check for MAX String here
                                        (0181)    cmp  [RX8_1_bRxCnt],(RX8_1_RX_BUFFER_SIZE - 1)
                                        (0182)    jc   .UARTRX_ISR_GETDATA
                                        (0183)    or   [RX8_1_fStatus],RX8_1_RX_BUF_OVERRUN               ; Set error flags (parity,framing,overrun) bits
                                        (0184) 
                                        (0185)    RAM_SETPAGE_IDX >RX8_1_aRxBuffer             ;   using idexed address mode
                                        (0186)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
                                        (0187)    mov  [X + RX8_1_aRxBuffer],00h                          ; Zero out last data
                                        (0188)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
                                        (0189)    jmp  .RESTORE_IDX_PP
                                        (0190) 
                                        (0191)                                                            ; IF input data == "CR", then end of command
                                        (0192) .UARTRX_ISR_GETDATA:
                                        (0193)    inc  X                                                  ; Inc the pointer
                                        (0194)    mov  [RX8_1_bRxCnt],X                                   ; Restore the pointer
                                        (0195)    dec  X                                                  ; Mov X to its original value
                                        (0196) 
                                        (0197)    RAM_SETPAGE_IDX >RX8_1_aRxBuffer             ;   using idexed address mode
                                        (0198)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
                                        (0199)    mov  [X+RX8_1_aRxBuffer],A                              ; store data in array
                                        (0200)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
                                        (0201) 
                                        (0202) 
                                        (0203) .RESTORE_IDX_PP:
                                        (0204)    IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0205)       REG_RESTORE IDX_PP
                                        (0206)    ENDIF
                                        (0207) 
                                        (0208) .END_UARTRX_ISR:
                                        (0209)    pop  X
                                        (0210)    pop  A
                                        (0211) 
                                        (0212) ENDIF
                                        (0213) 
                                        (0214) RX8_1_RX_ISR_END:
04D5: 7E       RETI                     (0215)    reti
                                        (0216) 
                                        (0217) 
                                        (0218) ; end of file RX8_1INT.asm
FILE: lib\rx8_1.asm                     (0001) ;;*****************************************************************************
04D6: 43 E1 08 OR    REG[0xE1],0x8      (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: RX8_1.asm
                                        (0004) ;;   Version: 3.50, Updated on 2015/3/4 at 22:26:55
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: RX8 User Module software implementation file.
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) ;-----------------------------------------------
                                        (0023) ; include instance specific register definitions
                                        (0024) ;-----------------------------------------------
                                        (0025) include "m8c.inc"
                                        (0026) include "memory.inc"
                                        (0027) include "RX8_1.inc"
                                        (0028) 
                                        (0029) 
                                        (0030) ;-----------------------------------------------
                                        (0031) ;  Global Symbols
                                        (0032) ;-----------------------------------------------
                                        (0033) export   RX8_1_EnableInt
                                        (0034) export  _RX8_1_EnableInt
                                        (0035) export   RX8_1_DisableInt
                                        (0036) export  _RX8_1_DisableInt
                                        (0037) export   RX8_1_Start
                                        (0038) export  _RX8_1_Start
                                        (0039) export   RX8_1_Stop
                                        (0040) export  _RX8_1_Stop
                                        (0041) export   RX8_1_bReadRxData
                                        (0042) export  _RX8_1_bReadRxData
                                        (0043) export   RX8_1_bReadRxStatus
                                        (0044) export  _RX8_1_bReadRxStatus
                                        (0045) 
                                        (0046) ; Old function name convension, do not use.
                                        (0047) ; These will be removed in a future release.
                                        (0048) export  bRX8_1_ReadRxData
                                        (0049) export _bRX8_1_ReadRxData
                                        (0050) export  bRX8_1_ReadRxStatus
                                        (0051) export _bRX8_1_ReadRxStatus
                                        (0052) 
                                        (0053) ;-----------------------------------------------
                                        (0054) ; High Level RX functions
                                        (0055) ;-----------------------------------------------
                                        (0056) 
                                        (0057) export  RX8_1_cGetChar
                                        (0058) export _RX8_1_cGetChar
                                        (0059) export  RX8_1_cReadChar
                                        (0060) export _RX8_1_cReadChar
                                        (0061) export  RX8_1_iReadChar
                                        (0062) export _RX8_1_iReadChar
                                        (0063) 
                                        (0064) IF (RX8_1_RXBUF_ENABLE)
                                        (0065) export  RX8_1_CmdReset
                                        (0066) export _RX8_1_CmdReset
                                        (0067) export  RX8_1_bCmdCheck
                                        (0068) export _RX8_1_bCmdCheck
                                        (0069) export  RX8_1_bCmdLength
                                        (0070) export _RX8_1_bCmdLength
                                        (0071) export  RX8_1_bErrCheck
                                        (0072) export _RX8_1_bErrCheck
                                        (0073) 
                                        (0074) export  RX8_1_szGetParam
                                        (0075) export _RX8_1_szGetParam
                                        (0076) export  RX8_1_szGetRestOfParams
                                        (0077) export _RX8_1_szGetRestOfParams
                                        (0078) 
                                        (0079) ;-----------------------------------------------
                                        (0080) ;  Variables
                                        (0081) ;-----------------------------------------------
                                        (0082) 
                                        (0083) AREA RX8_1_RAM(RAM,REL,CON)
                                        (0084)  ptrParam:   			BLK  1
                                        (0085) 
                                        (0086) ENDIF
                                        (0087) ;-----------------------------------------------
                                        (0088) ;  EQUATES
                                        (0089) ;-----------------------------------------------
                                        (0090) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                        (0091) 
                                        (0092) area UserModules (ROM, REL)
                                        (0093) 
                                        (0094) .SECTION
                                        (0095) ;-----------------------------------------------------------------------------
                                        (0096) ;  FUNCTION NAME: RX8_1_EnableInt
                                        (0097) ;
                                        (0098) ;  DESCRIPTION:
                                        (0099) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                        (0100) ;     bit associated with this User Module. Remember to call the global interrupt
                                        (0101) ;     enable function by using the macro: M8C_EnableGInt.
                                        (0102) ;
                                        (0103) ;-----------------------------------------------------------------------------
                                        (0104) ;
                                        (0105) ;  ARGUMENTS: none
                                        (0106) ;
                                        (0107) ;  RETURNS: none
                                        (0108) ;
                                        (0109) ;  SIDE EFFECTS:
                                        (0110) ;    The A and X registers may be modified by this or future implementations
                                        (0111) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0112) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0113) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0114) ;    functions.
                                        (0115) ;
                                        (0116)  RX8_1_EnableInt:
                                        (0117) _RX8_1_EnableInt:
                                        (0118)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0119)    M8C_EnableIntMask RX8_1_INT_REG, RX8_1_bINT_MASK
                                        (0120)    RAM_EPILOGUE RAM_USE_CLASS_1
04D9: 7F       RET                      (0121)    ret
                                        (0122) .ENDSECTION
                                        (0123) 
                                        (0124) .SECTION
                                        (0125) ;-----------------------------------------------------------------------------
                                        (0126) ;  FUNCTION NAME: RX8_1_DisableInt
                                        (0127) ;
                                        (0128) ;  DESCRIPTION:
                                        (0129) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                        (0130) ;     associated with this User Module.
                                        (0131) ;
                                        (0132) ;-----------------------------------------------------------------------------
                                        (0133) ;
                                        (0134) ;  ARGUMENTS:  none
                                        (0135) ;
                                        (0136) ;  RETURNS:  none
                                        (0137) ;
                                        (0138) ;  SIDE EFFECTS:
                                        (0139) ;    The A and X registers may be modified by this or future implementations
                                        (0140) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0141) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0142) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0143) ;    functions.
                                        (0144) ;
                                        (0145)  RX8_1_DisableInt:
                                        (0146) _RX8_1_DisableInt:
                                        (0147)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0148)    M8C_DisableIntMask RX8_1_INT_REG, RX8_1_bINT_MASK
                                        (0149)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0150)    ret
                                        (0151) .ENDSECTION
                                        (0152) 
                                        (0153) .SECTION
                                        (0154) ;-----------------------------------------------------------------------------
                                        (0155) ;  FUNCTION NAME: RX8_1_Start(BYTE bParity)
                                        (0156) ;
                                        (0157) ;  DESCRIPTION:
                                        (0158) ;    Sets the start bit and parity in the Control register of this user module.
                                        (0159) ;
                                        (0160) ;-----------------------------------------------------------------------------
                                        (0161) ;
                                        (0162) ;  ARGUMENTS:
                                        (0163) ;    BYTE bParity - parity of received data.  Use defined masks.
                                        (0164) ;    passed in A register.
                                        (0165) ;
                                        (0166) ;  RETURNS: none
                                        (0167) ;
                                        (0168) ;  SIDE EFFECTS:
                                        (0169) ;    The A and X registers may be modified by this or future implementations
                                        (0170) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0171) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0172) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0173) ;    functions.
                                        (0174) ;
                                        (0175)  RX8_1_Start:
                                        (0176) _RX8_1_Start:
                                        (0177)    RAM_PROLOGUE RAM_USE_CLASS_1
04DA: 29 01    OR    A,0x1              (0178)    or    A, bfCONTROL_REG_START_BIT
04DC: 60 2F    MOV   REG[0x2F],A        (0179)    mov   REG[RX8_1_CONTROL_REG], A
                                        (0180)    RAM_EPILOGUE RAM_USE_CLASS_1
04DE: 7F       RET                      (0181)    ret
                                        (0182) .ENDSECTION
                                        (0183) 
                                        (0184) .SECTION
                                        (0185) ;-----------------------------------------------------------------------------
                                        (0186) ;  FUNCTION NAME: RX8_1_Stop
                                        (0187) ;
                                        (0188) ;  DESCRIPTION:
                                        (0189) ;     Disables RX8 operation.
                                        (0190) ;
                                        (0191) ;-----------------------------------------------------------------------------
                                        (0192) ;
                                        (0193) ;  ARGUMENTS: none
                                        (0194) ;
                                        (0195) ;  RETURNS: none
                                        (0196) ;
                                        (0197) ;  SIDE EFFECTS:
                                        (0198) ;    The A and X registers may be modified by this or future implementations
                                        (0199) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0200) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0201) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0202) ;    functions.
                                        (0203) ;
                                        (0204)  RX8_1_Stop:
                                        (0205) _RX8_1_Stop:
                                        (0206)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0207)    and   REG[RX8_1_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                        (0208)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0209)    ret
                                        (0210) .ENDSECTION
                                        (0211) 
                                        (0212) .SECTION
                                        (0213) ;-----------------------------------------------------------------------------
                                        (0214) ;  FUNCTION NAME: RX8_1_bReadRxData
                                        (0215) ;
                                        (0216) ;  DESCRIPTION:
                                        (0217) ;     Reads the RX buffer register.  Should check the status regiser to make
                                        (0218) ;     sure data is valid.
                                        (0219) ;
                                        (0220) ;-----------------------------------------------------------------------------
                                        (0221) ;
                                        (0222) ;  ARGUMENTS:  none
                                        (0223) ;
                                        (0224) ;  RETURNS:
                                        (0225) ;    bRxData - returned in A.
                                        (0226) ;
                                        (0227) ;  SIDE EFFECTS:
                                        (0228) ;    The A and X registers may be modified by this or future implementations
                                        (0229) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0230) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0231) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0232) ;    functions.
                                        (0233) ;
                                        (0234)  RX8_1_bReadRxData:
                                        (0235) _RX8_1_bReadRxData:
                                        (0236)  bRX8_1_ReadRxData:
                                        (0237) _bRX8_1_ReadRxData:
                                        (0238)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0239)    mov A, REG[RX8_1_RX_BUFFER_REG]
                                        (0240)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0241)    ret
                                        (0242) .ENDSECTION
                                        (0243) 
                                        (0244) .SECTION
                                        (0245) ;-----------------------------------------------------------------------------
                                        (0246) ;  FUNCTION NAME: RX8_1_bReadRxStatus
                                        (0247) ;
                                        (0248) ;  DESCRIPTION:
                                        (0249) ;    Reads the RX Status bits in the Control/Status register.
                                        (0250) ;
                                        (0251) ;-----------------------------------------------------------------------------
                                        (0252) ;
                                        (0253) ;  ARGUMENTS:  none
                                        (0254) ;
                                        (0255) ;  RETURNS:
                                        (0256) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                        (0257) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                        (0258) ;
                                        (0259) ;  SIDE EFFECTS:
                                        (0260) ;    The A and X registers may be modified by this or future implementations
                                        (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0264) ;    functions.
                                        (0265) ;
                                        (0266)  RX8_1_bReadRxStatus:
                                        (0267) _RX8_1_bReadRxStatus:
                                        (0268)  bRX8_1_ReadRxStatus:
                                        (0269) _bRX8_1_ReadRxStatus:
                                        (0270)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0271)    mov A,  REG[RX8_1_CONTROL_REG]
                                        (0272)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0273)    ret
                                        (0274) .ENDSECTION
                                        (0275) 
                                        (0276) ;-----------------------------------------------
                                        (0277) ; High Level RX functions
                                        (0278) ;-----------------------------------------------
                                        (0279) 
                                        (0280) .SECTION
                                        (0281) ;-----------------------------------------------------------------------------
                                        (0282) ;  FUNCTION NAME: RX8_1_cGetChar
                                        (0283) ;
                                        (0284) ;  DESCRIPTION:
                                        (0285) ;     Read character from UART RX port.
                                        (0286) ;
                                        (0287) ;
                                        (0288) ;  ARGUMENTS:
                                        (0289) ;      none
                                        (0290) ;
                                        (0291) ;  RETURNS:
                                        (0292) ;     char that is returned from UART
                                        (0293) ;
                                        (0294) ;  SIDE EFFECTS:
                                        (0295) ;    The A and X registers may be modified by this or future implementations
                                        (0296) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0297) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0298) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0299) ;    functions.
                                        (0300) ;    
                                        (0301) ;    Program flow will stay in this function until a character is received.
                                        (0302) ;    If the watchdog timer is used, care must be taken to make sure that
                                        (0303) ;    the delay between characters is less than the watchdog timeout.
                                        (0304) ;
                                        (0305)  RX8_1_cGetChar:
                                        (0306) _RX8_1_cGetChar:
                                        (0307)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0308) 
                                        (0309) .getChar_Loop:
04DF: 49 2F 08 TST   REG[0x2F],0x8      (0310)    tst REG[RX8_1_CONTROL_REG],RX8_1_RX_REG_FULL  ; Check if a character is ready
04E2: AF FC    JZ    bRX8_1_ReadRxData|_RX8_1_cGetChar|bRX8_1_ReadRxStatus|_bRX8_1_ReadRxStatus|_RX8_1_Stop|RX8_1_cGetChar|_RX8_1_bReadRxData|_RX8_1_bReadRxStatus|_bRX8_1_ReadRxData(0311)    jz  .getChar_Loop                                        ; If not loop
                                        (0312) 
04E4: 5D 2E    MOV   A,REG[0x2E]        (0313)    mov A, REG[RX8_1_RX_BUFFER_REG]               ; Get character
                                        (0314)    RAM_EPILOGUE RAM_USE_CLASS_1
04E6: 7F       RET                      (0315)    ret
                                        (0316) .ENDSECTION
                                        (0317) 
                                        (0318) .SECTION
                                        (0319) ;-----------------------------------------------------------------------------
                                        (0320) ;  FUNCTION NAME: RX8_1_cReadChar
                                        (0321) ;
                                        (0322) ;  DESCRIPTION:
                                        (0323) ;     Read character from UART RX port.
                                        (0324) ;
                                        (0325) ;  ARGUMENTS:
                                        (0326) ;      none
                                        (0327) ;
                                        (0328) ;  RETURNS:
                                        (0329) ;     char that is returned from UART
                                        (0330) ;
                                        (0331) ;  SIDE EFFECTS:
                                        (0332) ;    The A and X registers may be modified by this or future implementations
                                        (0333) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0334) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0335) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0336) ;    functions.
                                        (0337) ;
                                        (0338) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                        (0339) ;    implies a valid character or an error condition occured.
                                        (0340) ;
                                        (0341)  RX8_1_cReadChar:
                                        (0342) _RX8_1_cReadChar:
                                        (0343)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0344) 
                                        (0345)    mov  A,REG[RX8_1_CONTROL_REG]                           ; Get Status of RX
                                        (0346)    push A
                                        (0347)    and  A,RX8_1_RX_COMPLETE                                ; Check if a character is ready
                                        (0348)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
                                        (0349)    pop  A
                                        (0350)    jmp  .RX_NO_VALID_CHAR
                                        (0351) 
                                        (0352) .RX_DATA_RDY:
                                        (0353)    mov  A,REG[RX8_1_RX_BUFFER_REG]                         ; Read data first, then
                                        (0354)    swap A,X                                                ; determine if data is valid
                                        (0355) 
                                        (0356)    pop  A                                                  ; Check for errors
                                        (0357)    and  A,(RX8_1_RX_PARITY_ERROR | RX8_1_RX_FRAMING_ERROR)
                                        (0358)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                        (0359)    swap A,X                                                ; Put data in A and exit
                                        (0360)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0361)    ret
                                        (0362) 
                                        (0363) .RX_NO_VALID_CHAR:
                                        (0364)    mov A,0x00                                              ; Zero out character
                                        (0365) 
                                        (0366)  End_RX8_1_cReadChar:
                                        (0367)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0368)    ret
                                        (0369) .ENDSECTION
                                        (0370) 																			
                                        (0371) .SECTION
                                        (0372) ;-----------------------------------------------------------------------------
                                        (0373) ;  FUNCTION NAME: RX8_1_iReadChar
                                        (0374) ;
                                        (0375) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                        (0376) ; to just set a value in the upper byte if error conditions exists.
                                        (0377) ;
                                        (0378) ;  DESCRIPTION:
                                        (0379) ;     Read character from UART RX port.
                                        (0380) ;
                                        (0381) ;  ARGUMENTS:
                                        (0382) ;      none
                                        (0383) ;
                                        (0384) ;  RETURNS:
                                        (0385) ;     An integer value is returned.  A negative value inplies and error
                                        (0386) ;     condition, a positive value between 0 and 255 is the return character.
                                        (0387) ;
                                        (0388) ;     Error Codes:
                                        (0389) ;        0x80CC    Parity Error
                                        (0390) ;        0x40CC    Overrun Error
                                        (0391) ;        0x20CC    Framing Error
                                        (0392) ;        0x01CC    No Data available
                                        (0393) ;
                                        (0394) ;  SIDE EFFECTS:
                                        (0395) ;    The A and X registers may be modified by this or future implementations
                                        (0396) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0397) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0398) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0399) ;    functions.
                                        (0400) ;
                                        (0401)  RX8_1_iReadChar:
                                        (0402) _RX8_1_iReadChar:
                                        (0403)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0404) 
                                        (0405)    mov  A,REG[RX8_1_CONTROL_REG]                           ; Get Status of RX
                                        (0406)                                                            ; Mask only errors and data ready
                                        (0407)    and  A,(RX8_1_RX_ERROR|RX8_1_RX_REG_FULL)
                                        (0408)    push A
                                        (0409)    and  A,RX8_1_RX_COMPLETE                                ; Check if a character is ready
                                        (0410)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                        (0411)    pop  A
                                        (0412)    or   A,RX8_1_RX_NO_DATA                                 ; Add no data flag
                                        (0413)    swap A,X
                                        (0414)    jmp  End_RX8_1_iReadChar
                                        (0415) 
                                        (0416) .RX_GET_DATA:
                                        (0417)    pop  A
                                        (0418)    and  A,RX8_1_RX_ERROR
                                        (0419)    swap A,X
                                        (0420)    mov  A,REG[RX8_1_RX_BUFFER_REG]                         ; Read data first, then
                                        (0421)                                                            ; determine if data is valid
                                        (0422) 
                                        (0423)  End_RX8_1_iReadChar:
                                        (0424)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0425)    ret
                                        (0426) .ENDSECTION
                                        (0427) 
                                        (0428) 
                                        (0429) 
                                        (0430) IF (RX8_1_RXBUF_ENABLE)
                                        (0431) .SECTION
                                        (0432) ;-----------------------------------------------------------------------------
                                        (0433) ;-----------------------------------------------------------------------------
                                        (0434) ;
                                        (0435) ;     Command Buffer commands
                                        (0436) ;
                                        (0437) ;-----------------------------------------------------------------------------
                                        (0438) ;-----------------------------------------------------------------------------
                                        (0439) 
                                        (0440) ;-----------------------------------------------------------------------------
                                        (0441) ;  FUNCTION NAME: RX8_1_CmdReset
                                        (0442) ;
                                        (0443) ;  DESCRIPTION:
                                        (0444) ;     Reset command string and status flags
                                        (0445) ;
                                        (0446) ;  ARGUMENTS:
                                        (0447) ;     none.
                                        (0448) ;
                                        (0449) ;  RETURNS:
                                        (0450) ;     none.
                                        (0451) ;
                                        (0452) ;  SIDE EFFECTS:
                                        (0453) ;    The A and X registers may be modified by this or future implementations
                                        (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0457) ;    functions.
                                        (0458) ;          
                                        (0459) ;    Currently only the page pointer registers listed below are modified: 
                                        (0460) ;          CUR_PP
                                        (0461) ;
                                        (0462) ;  THEORY of OPERATION or PROCEDURE:
                                        (0463) ;     Clear the command buffer, command counter, and flag.
                                        (0464) ;
                                        (0465)  RX8_1_CmdReset:
                                        (0466) _RX8_1_CmdReset:
                                        (0467)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0468)    RAM_SETPAGE_CUR >RX8_1_aRxBuffer
                                        (0469)    mov [RX8_1_aRxBuffer], 0x00
                                        (0470)    RAM_SETPAGE_CUR >ptrParam
                                        (0471)    mov [ptrParam],0x00
                                        (0472)    RAM_SETPAGE_CUR >RX8_1_bRxCnt
                                        (0473)    mov [RX8_1_bRxCnt], 0x00
                                        (0474)    and [RX8_1_fStatus], 0x00
                                        (0475)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0476)    ret
                                        (0477) .ENDSECTION
                                        (0478) 
                                        (0479) .SECTION
                                        (0480) ;-----------------------------------------------------------------------------
                                        (0481) ;  FUNCTION NAME: RX8_1_bCmdCheck
                                        (0482) ;
                                        (0483) ;  DESCRIPTION:
                                        (0484) ;     Check to see if valid command in buffer.
                                        (0485) ;
                                        (0486) ;  ARGUMENTS:
                                        (0487) ;     none.
                                        (0488) ;
                                        (0489) ;  RETURNS:
                                        (0490) ;     BYTE  fStatus - Status of command receive buffer.
                                        (0491) ;                     Returns non-zero value in A if command is valid.
                                        (0492) ;
                                        (0493) ;  SIDE EFFECTS:
                                        (0494) ;    The A and X registers may be modified by this or future implementations
                                        (0495) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0496) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0497) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0498) ;    functions.
                                        (0499) ;          
                                        (0500) ;    Currently only the page pointer registers listed below are modified: 
                                        (0501) ;          CUR_PP
                                        (0502) ;
                                        (0503) ;  THEORY of OPERATION or PROCEDURE:
                                        (0504) ;     Read the status and control register.
                                        (0505) ;
                                        (0506)  RX8_1_bCmdCheck:
                                        (0507) _RX8_1_bCmdCheck:
                                        (0508)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0509)    RAM_SETPAGE_CUR >RX8_1_fStatus
                                        (0510)    mov A,  [RX8_1_fStatus]
                                        (0511)    and A, RX8_1_RX_BUF_CMDTERM                   ; Mask off Command status
                                        (0512)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0513)    ret
                                        (0514) .ENDSECTION
                                        (0515) 
                                        (0516) .SECTION
                                        (0517) ;-----------------------------------------------------------------------------
                                        (0518) ;  FUNCTION NAME: RX8_1_bErrCheck
                                        (0519) ;
                                        (0520) ;  DESCRIPTION:
                                        (0521) ;     Check to see if an error has occured since last CmdReset
                                        (0522) ;
                                        (0523) ;  ARGUMENTS:
                                        (0524) ;     none.
                                        (0525) ;
                                        (0526) ;  RETURNS:
                                        (0527) ;     BYTE  fStatus - Status of command receive buffer.
                                        (0528) ;                     Returns non-zero value in A if command is valid.
                                        (0529) ;           0x80 => Parity Error
                                        (0530) ;           0x40 => OverRun Error
                                        (0531) ;           0x20 => Framing Error
                                        (0532) ;           0x10 => Software Buffer OverRun
                                        (0533) ;
                                        (0534) ;  SIDE EFFECTS:
                                        (0535) ;    The A and X registers may be modified by this or future implementations
                                        (0536) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0537) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0538) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0539) ;    functions.
                                        (0540) ;          
                                        (0541) ;    Currently only the page pointer registers listed below are modified: 
                                        (0542) ;          CUR_PP
                                        (0543) ;
                                        (0544) ;     Error Status is clear when read.
                                        (0545) ;
                                        (0546) ;  THEORY of OPERATION or PROCEDURE:
                                        (0547) ;     Read RX buffer error status and clear status
                                        (0548) ;
                                        (0549)  RX8_1_bErrCheck:
                                        (0550) _RX8_1_bErrCheck:
                                        (0551)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0552)    RAM_SETPAGE_CUR >RX8_1_fStatus
                                        (0553)    mov A,  [RX8_1_fStatus]
                                        (0554)    and A, RX8_1_RX_BUF_ERROR                     ; Mask off Error status
                                        (0555)    and [RX8_1_fStatus], ~RX8_1_RX_BUF_ERROR
                                        (0556)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0557)    ret
                                        (0558) .ENDSECTION
                                        (0559) 
                                        (0560) .SECTION
                                        (0561) ;-----------------------------------------------------------------------------
                                        (0562) ;  FUNCTION NAME: RX8_1_bCmdLength
                                        (0563) ;
                                        (0564) ;  DESCRIPTION:
                                        (0565) ;     Get length of command string
                                        (0566) ;
                                        (0567) ;  ARGUMENTS:
                                        (0568) ;     none.
                                        (0569) ;
                                        (0570) ;  RETURNS:
                                        (0571) ;     BYTE  bRxCnt    Returns the command length in A.
                                        (0572) ;
                                        (0573) ;  SIDE EFFECTS:
                                        (0574) ;    The A and X registers may be modified by this or future implementations
                                        (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0578) ;    functions.
                                        (0579) ;          
                                        (0580) ;    Currently only the page pointer registers listed below are modified: 
                                        (0581) ;          CUR_PP
                                        (0582) ;
                                        (0583)  RX8_1_bCmdLength:
                                        (0584) _RX8_1_bCmdLength:
                                        (0585)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0586)    RAM_SETPAGE_CUR >RX8_1_bRxCnt
                                        (0587)    mov A,  [RX8_1_bRxCnt]
                                        (0588)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0589)    ret
                                        (0590) .ENDSECTION
                                        (0591) 
                                        (0592) .SECTION
                                        (0593) ;-----------------------------------------------------------------------------
                                        (0594) ;  FUNCTION NAME: RX8_1_szGetParam
                                        (0595) ;
                                        (0596) ;  DESCRIPTION:
                                        (0597) ;      Return next parameter from UART Rx buffer
                                        (0598) ;
                                        (0599) ;
                                        (0600) ;  ARGUMENTS:  none
                                        (0601) ;
                                        (0602) ;  RETURNS:
                                        (0603) ;     A => MSB of parameter address
                                        (0604) ;     X => LSB of parameter address
                                        (0605) ;
                                        (0606) ;  SIDE EFFECTS:
                                        (0607) ;    The A and X registers may be modified by this or future implementations
                                        (0608) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0609) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0610) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0611) ;    functions.
                                        (0612) ;          
                                        (0613) ;    Currently only the page pointer registers listed below are modified:
                                        (0614) ;          CUR_PP
                                        (0615) ;          IDX_PP
                                        (0616) ;
                                        (0617) ;     The receive string is modified by placing Null characters at the end
                                        (0618) ;     of each parameter as they are recovered.
                                        (0619) ;
                                        (0620) ;  THEORY OF OPERATION:
                                        (0621) ;     This function is a stateful generator of addresses to the "parameters"
                                        (0622) ;     of an input "Command". It scans the (optional) input buffer and breaks
                                        (0623) ;     each lexically distinct element into a null-terminated string by replacing
                                        (0624) ;     delimiters with nulls, as appropriate. The state of the generator is 
                                        (0625) ;     maintained by the private variable ptrParam, which is a buffer-relative
                                        (0626) ;     offset. The generator is initialized by a call to the function
                                        (0627) ;     RX8_1_CmdReset which resets the entire buffer to the 'empty'
                                        (0628) ;     state. Typically this function, RX8_1_szGetParam, is
                                        (0629) ;     not called until the buffer has been loaded with an entire command
                                        (0630) ;     (See RX8_1_bCmdCheck).
                                        (0631) ;
                                        (0632) ;     Note, there is no special distinction between the "command" and the 
                                        (0633) ;     "parameters". The first non-delimiter character of the buffer---the first
                                        (0634) ;     character of the "command"---is also, for the purposes of this function,
                                        (0635) ;     the first "parameter" to which it returns an address.
                                        (0636) ;
                                        (0637) ;     The value of a delimiter (commonly an ascii space, 0x20 and decimal 32)
                                        (0638) ;     is determined at configuration time by a user module parameter.
                                        (0639) ;
                                        (0640)  RX8_1_szGetParam:
                                        (0641) _RX8_1_szGetParam:
                                        (0642)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0643)    RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0644)    RAM_SETPAGE_CUR >ptrParam
                                        (0645)    RAM_SETPAGE_IDX >RX8_1_aRxBuffer
                                        (0646) 
                                        (0647)    mov  A, <RX8_1_aRxBuffer                 ; Get address to receive buffer
                                        (0648)    add  A, [ptrParam]                      ; Add string offset
                                        (0649)    mov  X,A
                                        (0650) 
                                        (0651)    mov  A,[X]                              ; Get character pointed by X
                                        (0652)    jnz  .CheckForDelim                     ; Check for Null character
                                        (0653)    push X                                  ; Save LSB of current pointer
                                        (0654)    jmp  .End_GetNextParam
                                        (0655) 
                                        (0656)                                             ; Check for delimiter and keep looping until
                                        (0657)                                             ; all leading delimiters have been found.
                                        (0658) .CheckForDelim:
                                        (0659)     cmp  A,RX8_1_DELIMITER                  ; Check if we have a delimiter
                                        (0660)     jnz  .ParamStartFound
                                        (0661)     inc  X                                  ; Increment both current pointer and
                                        (0662)     inc  [ptrParam]                         ; stored pointer.
                                        (0663)     mov  A,[X]                              ; Get character pointed by X
                                        (0664)     cmp  [ptrParam],(RX8_1_RX_BUFFER_SIZE -1)  ; Check if we are at the end of buffer
                                        (0665)     jnz  .CheckForDelim
                                        (0666)                                             ; End of string found
                                        (0667) .EndOfString:
                                        (0668)     push X                                  ; Save ptr
                                        (0669) .TerminateString:
                                        (0670)     mov  [X],0x00                           ; Make sure string is zero
                                        (0671)     jmp  .End_GetNextParam
                                        (0672) 
                                        (0673) .ParamStartFound:
                                        (0674)     push X                                  ; Beginning of parameter found, save pointer
                                        (0675) 
                                        (0676) .ParamLoop:
                                        (0677)                                             ; Now loop until end of parameter found.
                                        (0678)     inc  X                                  ; Advance pointers.
                                        (0679)     inc  [ptrParam]
                                        (0680)     cmp  [ptrParam],(RX8_1_RX_BUFFER_SIZE -1)  ; Check if we are at the end of buffer
                                        (0681)     jz   .TerminateString
                                        (0682)     mov  A,[X]                              ; Get next character
                                        (0683)     jz   .End_GetNextParam
                                        (0684)     cmp  A,RX8_1_DELIMITER                  ; Check if we have a delimiter
                                        (0685)     jnz  .ParamLoop                         ; Still no delimiter, loop again
                                        (0686) 
                                        (0687)     mov  [X],0x00                           ; Replace delimiter with null for end of substring
                                        (0688)     inc  [ptrParam]
                                        (0689)     cmp  [ptrParam],(RX8_1_RX_BUFFER_SIZE -1)  ; Check if we are at the end of buffer
                                        (0690)     jnz  .End_GetNextParam                  ; If not end of string leave
                                        (0691)     mov  [ptrParam],(RX8_1_RX_BUFFER_SIZE -1)  ; Reset pointer to end of string.
                                        (0692) 
                                        (0693) 
                                        (0694) .End_GetNextParam:
                                        (0695)    pop  X
                                        (0696)    push X
                                        (0697)    cmp  [X],0x00
                                        (0698)    jnz  .NotNullString
                                        (0699)    pop  X
                                        (0700)    mov  X,0x00
                                        (0701)    mov  A,X
                                        (0702)    RAM_EPILOGUE RAM_USE_CLASS_3
                                        (0703)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0704)    ret
                                        (0705) 
                                        (0706) .NotNullString:
                                        (0707)    pop  X
                                        (0708)    mov  A,>RX8_1_aRxBuffer                     ; Return pointer
                                        (0709)    RAM_EPILOGUE RAM_USE_CLASS_3
                                        (0710)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0711)    ret
                                        (0712) .ENDSECTION
                                        (0713) 
                                        (0714) .SECTION
                                        (0715) ;-----------------------------------------------------------------------------
                                        (0716) ;  FUNCTION NAME: RX8_1_szGetRestOfParams
                                        (0717) ;
                                        (0718) ;  DESCRIPTION:
                                        (0719) ;      Return the rest of the UART RX buffer
                                        (0720) ;
                                        (0721) ;
                                        (0722) ;  ARGUMENTS:  none
                                        (0723) ;
                                        (0724) ;  RETURNS:
                                        (0725) ;     A => MSB of parameter
                                        (0726) ;     X => LSB of parameter
                                        (0727) ;
                                        (0728) ;  SIDE EFFECTS:
                                        (0729) ;    The A and X registers may be modified by this or future implementations
                                        (0730) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0731) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0732) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0733) ;    functions.
                                        (0734) ;          
                                        (0735) ;    Currently only the page pointer registers listed below are modified: 
                                        (0736) ;          CUR_PP
                                        (0737) ;
                                        (0738)  RX8_1_szGetRestOfParams:
                                        (0739) _RX8_1_szGetRestOfParams:
                                        (0740)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0741)    RAM_SETPAGE_CUR >ptrParam
                                        (0742) 
                                        (0743)     mov  A, <RX8_1_aRxBuffer                ; Get address to receive buffer
                                        (0744)     add  A, [ptrParam]                      ; Add string offset
                                        (0745)     mov  X,A
                                        (0746)     mov  A,>RX8_1_aRxBuffer                 ; Return pointer
                                        (0747) 
                                        (0748)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0749)     ret
                                        (0750) .ENDSECTION
                                        (0751) 
                                        (0752) ENDIF
                                        (0753) ; End of File RX8_1.asm
FILE: lib\rst.asm                       (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   RST.asm
                                        (0004) ;;  Version: 2.00, Updated on 2015/3/4 at 22:26:37
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: LED user module.
                                        (0008) ;;
                                        (0009) ;;
                                        (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0012) ;;        This means it is the caller's responsibility to preserve any values
                                        (0013) ;;        in the X and A registers that are still needed after the API functions
                                        (0014) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0015) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0017) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0018) ;;-----------------------------------------------------------------------------
                                        (0019) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0020) ;;*****************************************************************************
                                        (0021) ;;*****************************************************************************
                                        (0022) 
                                        (0023) include "RST.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) export _RST_Start
                                        (0027) export  RST_Start
                                        (0028) 
                                        (0029) export _RST_Stop
                                        (0030) export  RST_Stop
                                        (0031) 
                                        (0032) export _RST_On
                                        (0033) export  RST_On
                                        (0034) 
                                        (0035) export _RST_Off
                                        (0036) export  RST_Off
                                        (0037) 
                                        (0038) export _RST_Switch
                                        (0039) export  RST_Switch
                                        (0040) 
                                        (0041) export _RST_Invert
                                        (0042) export  RST_Invert
                                        (0043) 
                                        (0044) export _RST_GetState
                                        (0045) export  RST_GetState
                                        (0046) 
                                        (0047) 
                                        (0048) AREA UserModules (ROM, REL)
                                        (0049) 
                                        (0050) 
                                        (0051) .SECTION
                                        (0052) ;-----------------------------------------------------------------------------
                                        (0053) ;  FUNCTION NAME: RST_Start(void)
                                        (0054) ;  FUNCTION NAME: RST_Stop(void)
                                        (0055) ;
                                        (0056) ;  FUNCTION NAME: RST_Switch(void)
                                        (0057) ;
                                        (0058) ;  DESCRIPTION: ( Switch )
                                        (0059) ;     Turn LED on or off     
                                        (0060) ;
                                        (0061) ;  DESCRIPTION: ( Start, Stop )
                                        (0062) ;     Turn LED off                       
                                        (0063) ;
                                        (0064) ;-----------------------------------------------------------------------------
                                        (0065) ;
                                        (0066) ;  ARGUMENTS:  ( Switch )
                                        (0067) ;     A => If 0, turn off LED, if > 0 turn on LED
                                        (0068) ;
                                        (0069) ;  ARGUMENTS:  ( Start, Stop )
                                        (0070) ;      None
                                        (0071) ;
                                        (0072) ;  RETURNS:  none
                                        (0073) ;
                                        (0074) ;  SIDE EFFECTS:
                                        (0075) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0076) ;
                                        (0077) ;-----------------------------------------------------------------------------
                                        (0078) _RST_On:
                                        (0079)  RST_On:
04E7: 50 01    MOV   A,0x1              (0080)    mov  A,0x01
04E9: 80 03    JMP   _RST_Switch        (0081)    jmp  RST_Switch 
                                        (0082) 
                                        (0083) _RST_Start:
                                        (0084)  RST_Start:
                                        (0085) _RST_Stop:
                                        (0086)  RST_Stop:
                                        (0087) _RST_Off:
                                        (0088)  RST_Off:
04EB: 50 00    MOV   A,0x0              (0089)    mov  A,0x00
                                        (0090) 
                                        (0091) _RST_Switch:
                                        (0092)  RST_Switch:
                                        (0093)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0094)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0095)    RAM_SETPAGE_CUR >Port_0_Data_SHADE
                                        (0096) 
04ED: 29 00    OR    A,0x0              (0097)    or   A,0x00                                   ; Check mode
04EF: A0 06    JZ    0x04F6             (0098)    jz   .Turn_Off_LED
                                        (0099) 
                                        (0100) .Turn_On_LED:
                                        (0101) IF(1)                                            ; Active High Digit Drive
04F1: 2E 23 10 OR    [0x23],0x10        (0102)    or   [Port_0_Data_SHADE],RST_PinMask
                                        (0103) ELSE                                             ; Active Low Digit Drive
                                        (0104)    and  [Port_0_Data_SHADE],~RST_PinMask
                                        (0105) ENDIF
04F4: 80 04    JMP   0x04F9             (0106)    jmp  .Switch_LED
                                        (0107) 
                                        (0108) .Turn_Off_LED:
                                        (0109) IF(1)                      ; Active High Digit Drive
04F6: 26 23 EF AND   [0x23],0xEF        (0110)    and  [Port_0_Data_SHADE],~RST_PinMask
                                        (0111) ELSE                              ; Active Low Digit Drive
                                        (0112)    or   [Port_0_Data_SHADE],RST_PinMask
                                        (0113) ENDIF
                                        (0114) 
                                        (0115) .Switch_LED:
04F9: 51 23    MOV   A,[0x23]           (0116)    mov  A,[Port_0_Data_SHADE]
04FB: 60 00    MOV   REG[0x0],A         (0117)    mov  reg[RST_PortDR],A
                                        (0118) 
                                        (0119)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0120)    RAM_EPILOGUE RAM_USE_CLASS_4
04FD: 7F       RET                      (0121)    ret
                                        (0122) .ENDSECTION
                                        (0123) 
                                        (0124) 
                                        (0125) 
                                        (0126) .SECTION
                                        (0127) ;-----------------------------------------------------------------------------
                                        (0128) ;  FUNCTION NAME: RST_Invert(void)
                                        (0129) ;
                                        (0130) ;  DESCRIPTION:
                                        (0131) ;     Invert state of LED                               
                                        (0132) ;
                                        (0133) ;-----------------------------------------------------------------------------
                                        (0134) ;
                                        (0135) ;  ARGUMENTS: none
                                        (0136) ;
                                        (0137) ;  RETURNS:  none
                                        (0138) ;
                                        (0139) ;  SIDE EFFECTS:
                                        (0140) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0141) ;
                                        (0142) ;-----------------------------------------------------------------------------
                                        (0143) _RST_Invert:
                                        (0144)  RST_Invert:
                                        (0145)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0146)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0147)    RAM_SETPAGE_CUR >Port_0_Data_SHADE
                                        (0148) 
                                        (0149)    xor  [Port_0_Data_SHADE],RST_PinMask
                                        (0150)    mov  A,[Port_0_Data_SHADE]
                                        (0151)    mov  reg[RST_PortDR],A
                                        (0152) 
                                        (0153)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0154)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0155)    ret
                                        (0156) .ENDSECTION
                                        (0157) 
                                        (0158) .SECTION
                                        (0159) ;-----------------------------------------------------------------------------
                                        (0160) ;  FUNCTION NAME: RST_GetState(void)
                                        (0161) ;
                                        (0162) ;  DESCRIPTION:
                                        (0163) ;     Get state of LED
                                        (0164) ;
                                        (0165) ;-----------------------------------------------------------------------------
                                        (0166) ;
                                        (0167) ;  ARGUMENTS: none
                                        (0168) ;
                                        (0169) ;  RETURNS:  
                                        (0170) ;    State of LED   1 = ON,  0 = OFF
                                        (0171) ;
                                        (0172) ;  SIDE EFFECTS:
                                        (0173) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0174) ;
                                        (0175) ;-----------------------------------------------------------------------------
                                        (0176) _RST_GetState:
                                        (0177)  RST_GetState:
                                        (0178)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0179)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0180)    RAM_SETPAGE_CUR >Port_0_Data_SHADE
                                        (0181) 
                                        (0182)    mov   A,[Port_0_Data_SHADE]         ; Get shade value
                                        (0183) IF(1)                                  ; Active High Digit Drive
                                        (0184)    // Nothing for now
                                        (0185) ELSE                                   ; Active Low Digit Drive
                                        (0186)    cpl   A                             ; Invert bit if Active low
                                        (0187) ENDIF
                                        (0188)    and   A,RST_PinMask                 ; Mask off the trash
                                        (0189)    jz    .End_LED_GS                   ; If zero, we're done
                                        (0190)    mov   A,0x01                        ; Return a 1 no mater what the mask is.
                                        (0191) 
                                        (0192) .End_LED_GS:
                                        (0193)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0194)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0195)    ret
                                        (0196) .ENDSECTION
FILE: lib\led_1.asm                     (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   LED_1.asm
                                        (0004) ;;  Version: 2.00, Updated on 2015/3/4 at 22:26:37
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: LED user module.
                                        (0008) ;;
                                        (0009) ;;
                                        (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0012) ;;        This means it is the caller's responsibility to preserve any values
                                        (0013) ;;        in the X and A registers that are still needed after the API functions
                                        (0014) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0015) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0017) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0018) ;;-----------------------------------------------------------------------------
                                        (0019) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0020) ;;*****************************************************************************
                                        (0021) ;;*****************************************************************************
                                        (0022) 
                                        (0023) include "LED_1.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) export _LED_1_Start
                                        (0027) export  LED_1_Start
                                        (0028) 
                                        (0029) export _LED_1_Stop
                                        (0030) export  LED_1_Stop
                                        (0031) 
                                        (0032) export _LED_1_On
                                        (0033) export  LED_1_On
                                        (0034) 
                                        (0035) export _LED_1_Off
                                        (0036) export  LED_1_Off
                                        (0037) 
                                        (0038) export _LED_1_Switch
                                        (0039) export  LED_1_Switch
                                        (0040) 
                                        (0041) export _LED_1_Invert
                                        (0042) export  LED_1_Invert
                                        (0043) 
                                        (0044) export _LED_1_GetState
                                        (0045) export  LED_1_GetState
                                        (0046) 
                                        (0047) 
                                        (0048) AREA UserModules (ROM, REL)
                                        (0049) 
                                        (0050) 
                                        (0051) .SECTION
                                        (0052) ;-----------------------------------------------------------------------------
                                        (0053) ;  FUNCTION NAME: LED_1_Start(void)
                                        (0054) ;  FUNCTION NAME: LED_1_Stop(void)
                                        (0055) ;
                                        (0056) ;  FUNCTION NAME: LED_1_Switch(void)
                                        (0057) ;
                                        (0058) ;  DESCRIPTION: ( Switch )
                                        (0059) ;     Turn LED on or off     
                                        (0060) ;
                                        (0061) ;  DESCRIPTION: ( Start, Stop )
                                        (0062) ;     Turn LED off                       
                                        (0063) ;
                                        (0064) ;-----------------------------------------------------------------------------
                                        (0065) ;
                                        (0066) ;  ARGUMENTS:  ( Switch )
                                        (0067) ;     A => If 0, turn off LED, if > 0 turn on LED
                                        (0068) ;
                                        (0069) ;  ARGUMENTS:  ( Start, Stop )
                                        (0070) ;      None
                                        (0071) ;
                                        (0072) ;  RETURNS:  none
                                        (0073) ;
                                        (0074) ;  SIDE EFFECTS:
                                        (0075) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0076) ;
                                        (0077) ;-----------------------------------------------------------------------------
                                        (0078) _LED_1_On:
                                        (0079)  LED_1_On:
                                        (0080)    mov  A,0x01
                                        (0081)    jmp  LED_1_Switch 
                                        (0082) 
                                        (0083) _LED_1_Start:
                                        (0084)  LED_1_Start:
                                        (0085) _LED_1_Stop:
                                        (0086)  LED_1_Stop:
                                        (0087) _LED_1_Off:
                                        (0088)  LED_1_Off:
04FE: 50 00    MOV   A,0x0              (0089)    mov  A,0x00
                                        (0090) 
                                        (0091) _LED_1_Switch:
                                        (0092)  LED_1_Switch:
                                        (0093)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0094)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0095)    RAM_SETPAGE_CUR >Port_3_Data_SHADE
                                        (0096) 
0500: 29 00    OR    A,0x0              (0097)    or   A,0x00                                   ; Check mode
0502: A0 06    JZ    0x0509             (0098)    jz   .Turn_Off_LED
                                        (0099) 
                                        (0100) .Turn_On_LED:
                                        (0101) IF(0)                                            ; Active High Digit Drive
                                        (0102)    or   [Port_3_Data_SHADE],LED_1_PinMask
                                        (0103) ELSE                                             ; Active Low Digit Drive
0504: 26 25 FE AND   [0x25],0xFE        (0104)    and  [Port_3_Data_SHADE],~LED_1_PinMask
                                        (0105) ENDIF
0507: 80 04    JMP   0x050C             (0106)    jmp  .Switch_LED
                                        (0107) 
                                        (0108) .Turn_Off_LED:
                                        (0109) IF(0)                      ; Active High Digit Drive
                                        (0110)    and  [Port_3_Data_SHADE],~LED_1_PinMask
                                        (0111) ELSE                              ; Active Low Digit Drive
0509: 2E 25 01 OR    [0x25],0x1         (0112)    or   [Port_3_Data_SHADE],LED_1_PinMask
                                        (0113) ENDIF
                                        (0114) 
                                        (0115) .Switch_LED:
050C: 51 25    MOV   A,[0x25]           (0116)    mov  A,[Port_3_Data_SHADE]
050E: 60 0C    MOV   REG[0xC],A         (0117)    mov  reg[LED_1_PortDR],A
                                        (0118) 
                                        (0119)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0120)    RAM_EPILOGUE RAM_USE_CLASS_4
0510: 7F       RET                      (0121)    ret
                                        (0122) .ENDSECTION
                                        (0123) 
                                        (0124) 
                                        (0125) 
                                        (0126) .SECTION
                                        (0127) ;-----------------------------------------------------------------------------
                                        (0128) ;  FUNCTION NAME: LED_1_Invert(void)
                                        (0129) ;
                                        (0130) ;  DESCRIPTION:
                                        (0131) ;     Invert state of LED                               
                                        (0132) ;
                                        (0133) ;-----------------------------------------------------------------------------
                                        (0134) ;
                                        (0135) ;  ARGUMENTS: none
                                        (0136) ;
                                        (0137) ;  RETURNS:  none
                                        (0138) ;
                                        (0139) ;  SIDE EFFECTS:
                                        (0140) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0141) ;
                                        (0142) ;-----------------------------------------------------------------------------
                                        (0143) _LED_1_Invert:
                                        (0144)  LED_1_Invert:
                                        (0145)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0146)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0147)    RAM_SETPAGE_CUR >Port_3_Data_SHADE
                                        (0148) 
0511: 36 25 01 XOR   [0x25],0x1         (0149)    xor  [Port_3_Data_SHADE],LED_1_PinMask
0514: 51 25    MOV   A,[0x25]           (0150)    mov  A,[Port_3_Data_SHADE]
0516: 60 0C    MOV   REG[0xC],A         (0151)    mov  reg[LED_1_PortDR],A
                                        (0152) 
                                        (0153)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0154)    RAM_EPILOGUE RAM_USE_CLASS_4
0518: 7F       RET                      (0155)    ret
                                        (0156) .ENDSECTION
                                        (0157) 
                                        (0158) .SECTION
                                        (0159) ;-----------------------------------------------------------------------------
                                        (0160) ;  FUNCTION NAME: LED_1_GetState(void)
                                        (0161) ;
                                        (0162) ;  DESCRIPTION:
                                        (0163) ;     Get state of LED
                                        (0164) ;
                                        (0165) ;-----------------------------------------------------------------------------
                                        (0166) ;
                                        (0167) ;  ARGUMENTS: none
                                        (0168) ;
                                        (0169) ;  RETURNS:  
                                        (0170) ;    State of LED   1 = ON,  0 = OFF
                                        (0171) ;
                                        (0172) ;  SIDE EFFECTS:
                                        (0173) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0174) ;
                                        (0175) ;-----------------------------------------------------------------------------
                                        (0176) _LED_1_GetState:
                                        (0177)  LED_1_GetState:
                                        (0178)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0179)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0180)    RAM_SETPAGE_CUR >Port_3_Data_SHADE
                                        (0181) 
                                        (0182)    mov   A,[Port_3_Data_SHADE]         ; Get shade value
                                        (0183) IF(0)                                  ; Active High Digit Drive
                                        (0184)    // Nothing for now
                                        (0185) ELSE                                   ; Active Low Digit Drive
                                        (0186)    cpl   A                             ; Invert bit if Active low
                                        (0187) ENDIF
                                        (0188)    and   A,LED_1_PinMask               ; Mask off the trash
                                        (0189)    jz    .End_LED_GS                   ; If zero, we're done
                                        (0190)    mov   A,0x01                        ; Return a 1 no mater what the mask is.
                                        (0191) 
                                        (0192) .End_LED_GS:
                                        (0193)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0194)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0195)    ret
                                        (0196) .ENDSECTION
FILE: lib\e2prom_1.asm                  (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   E2PROM_1.asm
                                        (0004) ;;  Version: 1.7, Updated on 2015/3/4 at 22:26:11
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: EEPROM emulation User Module implementation file.
                                        (0008) ;;
                                        (0009) ;;     Routines in this file perform E2PROM_1 User Module Read and
                                        (0010) ;;     Write operations.
                                        (0011) ;;
                                        (0012) ;;     They provide a layer of abstraction on top of the E2PROMLIB.asm routines
                                        (0013) ;;     to allow instancing of the EEPROM devices.  Together the E2PROM and
                                        (0014) ;;     E2PROMLIB algorithms emulate a byte-wise EEPROM device on a block oriented
                                        (0015) ;;     flash architecture.
                                        (0016) ;;
                                        (0017) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0018) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0019) ;;        This means it is the caller's responsibility to preserve any values
                                        (0020) ;;        in the X and A registers that are still needed after the API functions
                                        (0021) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0022) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0023) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0024) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0025) ;;-----------------------------------------------------------------------------
                                        (0026) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0027) ;;*****************************************************************************
                                        (0028) ;;*****************************************************************************
                                        (0029) 
                                        (0030) ;Preset CPU_EQUATE for CY8C25/26xxx identification
                                        (0031) CPU_F:   equ   0
                                        (0032) 
                                        (0033) include "m8c.inc"
                                        (0034) include "E2PROM_1.inc"
                                        (0035) include "memory.inc"
                                        (0036) 
                                        (0037) ;-------------------------------------------------------------------
                                        (0038) ;  Declare the functions global for both assembler and C compiler.
                                        (0039) ;
                                        (0040) ;  Note that there are two names for each API. First name is
                                        (0041) ;  assembler reference. Name with underscore is name refence for
                                        (0042) ;  C compiler.  Calling function in C source code does not require
                                        (0043) ;  the underscore.
                                        (0044) ;-------------------------------------------------------------------
                                        (0045) 
                                        (0046) ;-----------------------------------------------
                                        (0047) ;  Global Symbols
                                        (0048) ;-----------------------------------------------
                                        (0049) 
                                        (0050) export   E2PROM_1_Start
                                        (0051) export  _E2PROM_1_Start
                                        (0052) export   E2PROM_1_Stop
                                        (0053) export  _E2PROM_1_Stop
                                        (0054) export   E2PROM_1_bE2Write
                                        (0055) export  _E2PROM_1_bE2Write
                                        (0056) export   E2PROM_1_E2Read
                                        (0057) export  _E2PROM_1_E2Read
                                        (0058) 
                                        (0059) export   E2PROM_1_RESERVED
                                        (0060) 
                                        (0061) ;-----------------------------------------------------------------
                                        (0062) ;  Allocate the E2PROM_1 EEPROM device in Flash memory
                                        (0063) ;     This will allow the linker to perform memory collision
                                        (0064) ;     checking and the EEPROM device will be displayed in the
                                        (0065) ;     map file.
                                        (0066) ;     Note that this memory region can also be accessed from "C".
                                        (0067) ;-----------------------------------------------------------------
                                        (0068) AREA  E2PROM_1_AREA   (ROM,ABS,CON)
                                        (0069)    ORG   E2PROM_1_START_ADDR
                                        (0070) 
                                        (0071) _E2PROM_1_RESERVED::
                                        (0072)  E2PROM_1_RESERVED::     blkb     40h
                                        (0073) 
                                        (0074) 
                                        (0075) AREA  UserModules (ROM,REL)
                                        (0076) 
                                        (0077) ;-----------------------------------------------------------------------------
                                        (0078) ;  FUNCTION NAME: E2PROM_1_Start
                                        (0079) ;
                                        (0080) ;  DESCRIPTION:
                                        (0081) ;     Start routine for the E2PROM_1 user module.  This routine is
                                        (0082) ;     a place holder for conformance and consistency.
                                        (0083) ;-----------------------------------------------------------------------------
                                        (0084) ;
                                        (0085) ;  ARGUMENTS:
                                        (0086) ;     None
                                        (0087) ;
                                        (0088) ;  RETURNS:
                                        (0089) ;     None
                                        (0090) ;
                                        (0091) ;  SIDE EFFECTS: 
                                        (0092) ;    The A and X registers may be modified by this or future implementations
                                        (0093) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0094) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0095) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0096) ;    functions.
                                        (0097) ;
                                        (0098) .SECTION
                                        (0099) 
                                        (0100)  E2PROM_1_Start:
                                        (0101) _E2PROM_1_Start:
                                        (0102)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0103)    RAM_EPILOGUE RAM_USE_CLASS_1
0519: 7F       RET                      (0104)    ret
                                        (0105) 
                                        (0106) .ENDSECTION
                                        (0107) 
                                        (0108) 
                                        (0109) ;-----------------------------------------------------------------------------
                                        (0110) ;  FUNCTION NAME: E2PROM_1_Stop
                                        (0111) ;
                                        (0112) ;  DESCRIPTION:
                                        (0113) ;     Stop routine for the E2PROM_1 user module.  This routine is
                                        (0114) ;     a place holder for conformance and consistency.
                                        (0115) ;
                                        (0116) ;-----------------------------------------------------------------------------
                                        (0117) ;
                                        (0118) ;  ARGUMENTS:
                                        (0119) ;     None
                                        (0120) ;
                                        (0121) ;  RETURNS:
                                        (0122) ;     None
                                        (0123) ;
                                        (0124) ;  SIDE EFFECTS: 
                                        (0125) ;    The A and X registers may be modified by this or future implementations
                                        (0126) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0127) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0128) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0129) ;    functions.
                                        (0130) ;
                                        (0131) .SECTION
                                        (0132) 
                                        (0133)  E2PROM_1_Stop:
                                        (0134) _E2PROM_1_Stop:
                                        (0135)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0136)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0137)    ret
                                        (0138) 
                                        (0139) .ENDSECTION
                                        (0140) 
                                        (0141) 
                                        (0142) ;-----------------------------------------------------------------------------
                                        (0143) ;  FUNCTION NAME: E2PROM_1_E2Write
                                        (0144) ;
                                        (0145) ;  DESCRIPTION:
                                        (0146) ;     Writes the specified E2PROM data at the wAddr and wByteCount from RAM into
                                        (0147) ;     Flash into the defined E2PROM instance.
                                        (0148) ;
                                        (0149) ;     Prototype in C is:
                                        (0150) ;
                                        (0151) ;        #pragma  fastcall16 E2Write
                                        (0152) ;        void E2PROM_1_bE2Write( WORD wAddr, BYTE * pbData, WORD wByteCount,
                                        (0153) ;                                        CHAR cTemperature );
                                        (0154) ;
                                        (0155) ;     Easiest method to call from assembly is as follows:
                                        (0156) ;           push  X                    ; push X only if X needs to be perserved
                                        (0157) ;           mov   X, SP
                                        (0158) ;           push  <cTemperature>
                                        (0159) ;           push  <wByteCount>
                                        (0160) ;           push  <wByteCount+1>
                                        (0161) ;           push  <pbDataDest>                  
                                        (0162) ;           push  <pbDataDest+1>
                                        (0163) ;           push  <wAddr>
                                        (0164) ;           push  <wAddr+1>
                                        (0165) ;           call  E2PROM_1_bE2Write
                                        (0166) ;           add   SP, -E2_RD_ARG_STACK_FRAME_SIZE
                                        (0167) ;           pop   X                    ; restore X only if it was saved above
                                        (0168) ;
                                        (0169) ;           where <> refers to any addressing mode or number of instructions to
                                        (0170) ;              place the referenced data on the stack frame.
                                        (0171) ;
                                        (0172) ;     Other method is to create a stack frame using the defined equates and
                                        (0173) ;     load them into the stack frame using [X+E2_WR_ARG_*] offset addressing mode.
                                        (0174) ;     If this method is used in the LMM (large memory model) then make sure
                                        (0175) ;     that the index page tracks the stack page or is set to the same page
                                        (0176) ;     as the stack page.
                                        (0177) ;
                                        (0178) ;-----------------------------------------------------------------------------
                                        (0179) ;
                                        (0180) ;  ARGUMENTS:
                                        (0181) ;     wAddr:         WORD   - relative OFFSET in defined E2PROM to write data
                                        (0182) ;     pbData:        BYTE * - pointer to the RAM buffer of data to write
                                        (0183) ;     wByteCount:    WORD   - number of bytes to write into E2PROM
                                        (0184) ;     cTemperature:  CHAR   - temperature in degrees celsius
                                        (0185) ;
                                        (0186) ;  RETURNS:    E2PROM_1_NOERROR, E2PROM_1_FAILURE, or
                                        (0187) ;              E2PROM_1_STACKOVERFLOW
                                        (0188) ;
                                        (0189) ;  SIDE EFFECTS: 
                                        (0190) ;    If a partial block is to be saved to flash, then a 64 byte buffer
                                        (0191) ;    is temporary allocated.
                                        (0192) ;
                                        (0193) ;    The A and X registers may be modified by this or future implementations
                                        (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0197) ;    functions.
                                        (0198) ;          
                                        (0199) ;    Currently only the page pointer registers listed below are modified:
                                        (0200) ;       CUR_PP 
                                        (0201) ;       IDX_PP
                                        (0202) ;       MVW_PP
                                        (0203) ;                
                                        (0204) ;     REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0205) ;------------------------------------------------------------------------------
                                        (0206) .SECTION
                                        (0207) 
                                        (0208)  E2PROM_1_bE2Write::
                                        (0209) _E2PROM_1_bE2Write::
                                        (0210) 
                                        (0211) ;  RAM_PROLOGUE RAM_PROXY_CLASS_4 RAM_USE_CLASS_2  -->  implemented in E2PROMLIB  
                                        (0212) ;  Save the Flag register to perserve the native paging mode
                                        (0213) IF (CPU_F)     ;only save CPU flag if NOT CY8C25/26xxx PSoC devices
051A: 5D F7    MOV   A,REG[0xF7]        (0214)    mov   A, reg[CPU_F]                            
051C: 08       PUSH  A                  (0215)    push  A
                                        (0216) ENDIF
051D: 50 00    MOV   A,0x0              (0217)    mov   A, >E2PROM_1_START_BLOCK          ; push the FirstBlockID - MSB
051F: 08       PUSH  A                  (0218)    push  A
0520: 50 7F    MOV   A,0x7F             (0219)    mov   A, <E2PROM_1_START_BLOCK          ; push the FirstBlockID - LSB
0522: 08       PUSH  A                  (0220)    push  A
0523: 7D 05 98 LJMP  _bE2Write          (0221)    ljmp  bE2Write                                  ; jmp to E2PROMLIB 
                                        (0222) 
                                        (0223) 
                                        (0224) ; NOTE that return will be done by a RETI instruction to restore the orginal paging
                                        (0225) ;      mode and flag status.
                                        (0226) 
                                        (0227) .ENDSECTION
                                        (0228) 
                                        (0229) 
                                        (0230) ;-----------------------------------------------------------------------------
                                        (0231) ;  FUNCTION NAME: E2PROM_1_E2Read
                                        (0232) ;
                                        (0233) ;  DESCRIPTION:
                                        (0234) ;     Reads the specified E2PROM data at offset=wAddr for wByteCount bytes  and
                                        (0235) ;     places the data read into the RAM buffer pbDataDest.
                                        (0236) ;
                                        (0237) ;     Prototype in C is:
                                        (0238) ;
                                        (0239) ;        #pragma  fastcall16 E2Read
                                        (0240) ;        void E2PROM_1_E2Read( WORD wAddr, BYTE * pbDataDest, WORD wByteCount );
                                        (0241) ;
                                        (0242) ;     Easiest method to call from assembly is as follows:
                                        (0243) ;           push  X                             ; only if X needs to be preserved
                                        (0244) ;           mov   X, SP
                                        (0245) ;           push  <wByteCount>
                                        (0246) ;           push  <wByteCount+1>
                                        (0247) ;           push  <pbDataDest
                                        (0248) ;           push  <pbDataDest+1>
                                        (0249) ;           push  <wAddr>
                                        (0250) ;           push  <wAddr+1>
                                        (0251) ;           call  E2PROM_1_E2Read
                                        (0252) ;           add   SP, -E2_RD_ARG_STACK_FRAME_SIZE
                                        (0253) ;           pop   X                             ; restore only if X needs to be preserved
                                        (0254) ;
                                        (0255) ;           where <> refers to any addressing mode or number of instructions to
                                        (0256) ;              place the referenced data on the stack frame.
                                        (0257) ;
                                        (0258) ;     Other method is to create a stack frame using the defined equates and
                                        (0259) ;     load them into the stack frame using [X+E2_WR_ARG_*] offset addressing mode.
                                        (0260) ;     If this method is used in the LMM (large memory model) then make sure
                                        (0261) ;     that the index page tracks the stack page or is set to the same page
                                        (0262) ;     as the stack page.
                                        (0263) ;
                                        (0264) ;-----------------------------------------------------------------------------
                                        (0265) ;
                                        (0266) ;  ARGUMENTS:
                                        (0267) ;     wAddr:         WORD   - relative OFFSET in defined E2PROM to read data
                                        (0268) ;     pbDataDest:    BYTE * - pointer to the RAM buffer to place read data
                                        (0269) ;     wByteCount:    WORD   - number of bytes to read from E2PROM
                                        (0270) ;
                                        (0271) ;  RETURNS:       none
                                        (0272) ;
                                        (0273) ;  SIDE EFFECTS:
                                        (0274) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED 
                                        (0275) ;    AS MAY THE PAGE POINTER REGISTERS! 
                                        (0276) ;    
                                        (0277) ;    In the large memory model currently only the page
                                        (0278) ;    pointer registers listed below are modified.  This does
                                        (0279) ;    not guarantee that in future implementations of this
                                        (0280) ;    function other page pointer registers will not be
                                        (0281) ;    modified.
                                        (0282) ;    
                                        (0283) ;    Page Pointer Registers Modified:
                                        (0284) ;          CUR_PP
                                        (0285) ;          MVW_PP 
                                        (0286) ;
                                        (0287) ;-----------------------------------------------------------------------------
                                        (0288) .SECTION
                                        (0289) 
                                        (0290)  E2PROM_1_E2Read::
                                        (0291) _E2PROM_1_E2Read::
                                        (0292) ;  RAM_PROLOGUE RAM_PROXY_CLASS_NULL RAM_USE_CLASS_4  -->  implemented in E2PROMLIB  
                                        (0293) ;  Save the Flag register to perserve the native paging mode
                                        (0294) IF (CPU_F)     ;only save CPU flag if NOT CY8C25/26xxx PSoC devices
0526: 5D F7    MOV   A,REG[0xF7]        (0295)    mov   A, reg[CPU_F]                            
0528: 08       PUSH  A                  (0296)    push  A
                                        (0297) ENDIF
                                        (0298) 
                                        (0299) ;  Load the Block ID into X and A
0529: 50 00    MOV   A,0x0              (0300)    mov   A, >E2PROM_1_START_BLOCK       
052B: 5C       MOV   X,A                (0301)    mov   X, A
052C: 50 7F    MOV   A,0x7F             (0302)    mov   A, <E2PROM_1_START_BLOCK
052E: 7D 07 2E LJMP  _E2Read            (0303)    ljmp  E2Read
                                        (0304) 
                                        (0305) ; NOTE that return will be done by a RETI instruction to restore the orginal paging
                                        (0306) ;      mode and flag status.
                                        (0307) 
                                        (0308) 
                                        (0309) .ENDSECTION
                                        (0310) 
                                        (0311) ; End of File
FILE: lib\cs_pin.asm                    (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   CS_PIN.asm
                                        (0004) ;;  Version: 2.00, Updated on 2015/3/4 at 22:26:37
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: LED user module.
                                        (0008) ;;
                                        (0009) ;;
                                        (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0012) ;;        This means it is the caller's responsibility to preserve any values
                                        (0013) ;;        in the X and A registers that are still needed after the API functions
                                        (0014) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0015) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0017) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0018) ;;-----------------------------------------------------------------------------
                                        (0019) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0020) ;;*****************************************************************************
                                        (0021) ;;*****************************************************************************
                                        (0022) 
                                        (0023) include "CS_PIN.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) export _CS_PIN_Start
                                        (0027) export  CS_PIN_Start
                                        (0028) 
                                        (0029) export _CS_PIN_Stop
                                        (0030) export  CS_PIN_Stop
                                        (0031) 
                                        (0032) export _CS_PIN_On
                                        (0033) export  CS_PIN_On
                                        (0034) 
                                        (0035) export _CS_PIN_Off
                                        (0036) export  CS_PIN_Off
                                        (0037) 
                                        (0038) export _CS_PIN_Switch
                                        (0039) export  CS_PIN_Switch
                                        (0040) 
                                        (0041) export _CS_PIN_Invert
                                        (0042) export  CS_PIN_Invert
                                        (0043) 
                                        (0044) export _CS_PIN_GetState
                                        (0045) export  CS_PIN_GetState
                                        (0046) 
                                        (0047) 
                                        (0048) AREA UserModules (ROM, REL)
                                        (0049) 
                                        (0050) 
                                        (0051) .SECTION
                                        (0052) ;-----------------------------------------------------------------------------
                                        (0053) ;  FUNCTION NAME: CS_PIN_Start(void)
                                        (0054) ;  FUNCTION NAME: CS_PIN_Stop(void)
                                        (0055) ;
                                        (0056) ;  FUNCTION NAME: CS_PIN_Switch(void)
                                        (0057) ;
                                        (0058) ;  DESCRIPTION: ( Switch )
                                        (0059) ;     Turn LED on or off     
                                        (0060) ;
                                        (0061) ;  DESCRIPTION: ( Start, Stop )
                                        (0062) ;     Turn LED off                       
                                        (0063) ;
                                        (0064) ;-----------------------------------------------------------------------------
                                        (0065) ;
                                        (0066) ;  ARGUMENTS:  ( Switch )
                                        (0067) ;     A => If 0, turn off LED, if > 0 turn on LED
                                        (0068) ;
                                        (0069) ;  ARGUMENTS:  ( Start, Stop )
                                        (0070) ;      None
                                        (0071) ;
                                        (0072) ;  RETURNS:  none
                                        (0073) ;
                                        (0074) ;  SIDE EFFECTS:
                                        (0075) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0076) ;
                                        (0077) ;-----------------------------------------------------------------------------
                                        (0078) _CS_PIN_On:
                                        (0079)  CS_PIN_On:
0531: 50 01    MOV   A,0x1              (0080)    mov  A,0x01
0533: 80 03    JMP   _CS_PIN_Switch     (0081)    jmp  CS_PIN_Switch 
                                        (0082) 
                                        (0083) _CS_PIN_Start:
                                        (0084)  CS_PIN_Start:
                                        (0085) _CS_PIN_Stop:
                                        (0086)  CS_PIN_Stop:
                                        (0087) _CS_PIN_Off:
                                        (0088)  CS_PIN_Off:
0535: 50 00    MOV   A,0x0              (0089)    mov  A,0x00
                                        (0090) 
                                        (0091) _CS_PIN_Switch:
                                        (0092)  CS_PIN_Switch:
                                        (0093)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0094)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0095)    RAM_SETPAGE_CUR >Port_0_Data_SHADE
                                        (0096) 
0537: 29 00    OR    A,0x0              (0097)    or   A,0x00                                   ; Check mode
0539: A0 06    JZ    0x0540             (0098)    jz   .Turn_Off_LED
                                        (0099) 
                                        (0100) .Turn_On_LED:
                                        (0101) IF(1)                                            ; Active High Digit Drive
053B: 2E 23 80 OR    [0x23],0x80        (0102)    or   [Port_0_Data_SHADE],CS_PIN_PinMask
                                        (0103) ELSE                                             ; Active Low Digit Drive
                                        (0104)    and  [Port_0_Data_SHADE],~CS_PIN_PinMask
                                        (0105) ENDIF
053E: 80 04    JMP   0x0543             (0106)    jmp  .Switch_LED
                                        (0107) 
                                        (0108) .Turn_Off_LED:
                                        (0109) IF(1)                      ; Active High Digit Drive
0540: 26 23 7F AND   [0x23],0x7F        (0110)    and  [Port_0_Data_SHADE],~CS_PIN_PinMask
                                        (0111) ELSE                              ; Active Low Digit Drive
                                        (0112)    or   [Port_0_Data_SHADE],CS_PIN_PinMask
                                        (0113) ENDIF
                                        (0114) 
                                        (0115) .Switch_LED:
0543: 51 23    MOV   A,[0x23]           (0116)    mov  A,[Port_0_Data_SHADE]
0545: 60 00    MOV   REG[0x0],A         (0117)    mov  reg[CS_PIN_PortDR],A
                                        (0118) 
                                        (0119)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0120)    RAM_EPILOGUE RAM_USE_CLASS_4
0547: 7F       RET                      (0121)    ret
                                        (0122) .ENDSECTION
                                        (0123) 
                                        (0124) 
                                        (0125) 
                                        (0126) .SECTION
                                        (0127) ;-----------------------------------------------------------------------------
                                        (0128) ;  FUNCTION NAME: CS_PIN_Invert(void)
                                        (0129) ;
                                        (0130) ;  DESCRIPTION:
                                        (0131) ;     Invert state of LED                               
                                        (0132) ;
                                        (0133) ;-----------------------------------------------------------------------------
                                        (0134) ;
                                        (0135) ;  ARGUMENTS: none
                                        (0136) ;
                                        (0137) ;  RETURNS:  none
                                        (0138) ;
                                        (0139) ;  SIDE EFFECTS:
                                        (0140) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0141) ;
                                        (0142) ;-----------------------------------------------------------------------------
                                        (0143) _CS_PIN_Invert:
                                        (0144)  CS_PIN_Invert:
                                        (0145)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0146)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0147)    RAM_SETPAGE_CUR >Port_0_Data_SHADE
                                        (0148) 
                                        (0149)    xor  [Port_0_Data_SHADE],CS_PIN_PinMask
                                        (0150)    mov  A,[Port_0_Data_SHADE]
                                        (0151)    mov  reg[CS_PIN_PortDR],A
                                        (0152) 
                                        (0153)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0154)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0155)    ret
                                        (0156) .ENDSECTION
                                        (0157) 
                                        (0158) .SECTION
                                        (0159) ;-----------------------------------------------------------------------------
                                        (0160) ;  FUNCTION NAME: CS_PIN_GetState(void)
                                        (0161) ;
                                        (0162) ;  DESCRIPTION:
                                        (0163) ;     Get state of LED
                                        (0164) ;
                                        (0165) ;-----------------------------------------------------------------------------
                                        (0166) ;
                                        (0167) ;  ARGUMENTS: none
                                        (0168) ;
                                        (0169) ;  RETURNS:  
                                        (0170) ;    State of LED   1 = ON,  0 = OFF
                                        (0171) ;
                                        (0172) ;  SIDE EFFECTS:
                                        (0173) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0174) ;
                                        (0175) ;-----------------------------------------------------------------------------
                                        (0176) _CS_PIN_GetState:
                                        (0177)  CS_PIN_GetState:
                                        (0178)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0179)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0180)    RAM_SETPAGE_CUR >Port_0_Data_SHADE
                                        (0181) 
                                        (0182)    mov   A,[Port_0_Data_SHADE]         ; Get shade value
                                        (0183) IF(1)                                  ; Active High Digit Drive
                                        (0184)    // Nothing for now
                                        (0185) ELSE                                   ; Active Low Digit Drive
                                        (0186)    cpl   A                             ; Invert bit if Active low
                                        (0187) ENDIF
                                        (0188)    and   A,CS_PIN_PinMask              ; Mask off the trash
                                        (0189)    jz    .End_LED_GS                   ; If zero, we're done
                                        (0190)    mov   A,0x01                        ; Return a 1 no mater what the mask is.
                                        (0191) 
                                        (0192) .End_LED_GS:
                                        (0193)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0194)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0195)    ret
                                        (0196) .ENDSECTION
FILE: lib\counter16_1int.asm            (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: Counter16_1INT.asm
                                        (0004) ;;   Version: 2.5, Updated on 2015/3/4 at 22:23:43
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: Counter16 Interrupt Service Routine
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "memory.inc"
                                        (0015) include "Counter16_1.inc"
                                        (0016) 
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export  _Counter16_1_ISR
                                        (0022) 
                                        (0023) 
                                        (0024) AREA InterruptRAM (RAM,REL,CON)
                                        (0025) 
                                        (0026) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0027) ;---------------------------------------------------
                                        (0028) ; Insert your custom declarations below this banner
                                        (0029) ;---------------------------------------------------
                                        (0030) 
                                        (0031) ;------------------------
                                        (0032) ; Includes
                                        (0033) ;------------------------
                                        (0034) 
                                        (0035) 	
                                        (0036) ;------------------------
                                        (0037) ;  Constant Definitions
                                        (0038) ;------------------------
                                        (0039) 
                                        (0040) 
                                        (0041) ;------------------------
                                        (0042) ; Variable Allocation
                                        (0043) ;------------------------
                                        (0044) 
                                        (0045) 
                                        (0046) ;---------------------------------------------------
                                        (0047) ; Insert your custom declarations above this banner
                                        (0048) ;---------------------------------------------------
                                        (0049) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0050) 
                                        (0051) 
                                        (0052) AREA UserModules (ROM, REL)
                                        (0053) 
                                        (0054) ;-----------------------------------------------------------------------------
                                        (0055) ;  FUNCTION NAME: _Counter16_1_ISR
                                        (0056) ;
                                        (0057) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0058) ;
                                        (0059) ;-----------------------------------------------------------------------------
                                        (0060) ;
                                        (0061) 
                                        (0062) _Counter16_1_ISR:
                                        (0063) 
                                        (0064)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0065)    ;---------------------------------------------------
                                        (0066)    ; Insert your custom assembly code below this banner
                                        (0067)    ;---------------------------------------------------
                                        (0068)    ;   NOTE: interrupt service routines must preserve
                                        (0069)    ;   the values of the A and X CPU registers.
                                        (0070)    
                                        (0071)    ;---------------------------------------------------
                                        (0072)    ; Insert your custom assembly code above this banner
                                        (0073)    ;---------------------------------------------------
                                        (0074)    
                                        (0075)    ;---------------------------------------------------
                                        (0076)    ; Insert a lcall to a C function below this banner
                                        (0077)    ; and un-comment the lines between these banners
                                        (0078)    ;---------------------------------------------------
                                        (0079)    
                                        (0080)    ;PRESERVE_CPU_CONTEXT
0548: 7D 1C E6 LJMP  _Counter16_1_Interrupt(0081)    ljmp _Counter16_1_Interrupt
                                        (0082)    ;RESTORE_CPU_CONTEXT
                                        (0083)    
                                        (0084)    ;---------------------------------------------------
                                        (0085)    ; Insert a lcall to a C function above this banner
                                        (0086)    ; and un-comment the lines between these banners
                                        (0087)    ;---------------------------------------------------
                                        (0088)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0089) 
054B: 7E       RETI                     (0090)    reti
                                        (0091) 
                                        (0092) 
                                        (0093) ; end of file Counter16_1INT.asm
FILE: lib\counter16_1.asm               (0001) ;;*****************************************************************************
054C: 43 E1 02 OR    REG[0xE1],0x2      (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: Counter16_1.asm
                                        (0004) ;;   Version: 2.5, Updated on 2015/3/4 at 22:23:43
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: Counter16 User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "memory.inc"
                                        (0024) include "Counter16_1.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export  Counter16_1_EnableInt
                                        (0030) export _Counter16_1_EnableInt
                                        (0031) export  Counter16_1_DisableInt
                                        (0032) export _Counter16_1_DisableInt
                                        (0033) export  Counter16_1_Start
                                        (0034) export _Counter16_1_Start
                                        (0035) export  Counter16_1_Stop
                                        (0036) export _Counter16_1_Stop
                                        (0037) export  Counter16_1_WritePeriod
                                        (0038) export _Counter16_1_WritePeriod
                                        (0039) export  Counter16_1_WriteCompareValue
                                        (0040) export _Counter16_1_WriteCompareValue
                                        (0041) export  Counter16_1_wReadCompareValue
                                        (0042) export _Counter16_1_wReadCompareValue
                                        (0043) export  Counter16_1_wReadCounter
                                        (0044) export _Counter16_1_wReadCounter
                                        (0045) 
                                        (0046) ; The following functions are deprecated and subject to omission in future releases
                                        (0047) ;
                                        (0048) export  wCounter16_1_ReadCompareValue  ; deprecated
                                        (0049) export _wCounter16_1_ReadCompareValue  ; deprecated
                                        (0050) export  wCounter16_1_ReadCounter       ; deprecated
                                        (0051) export _wCounter16_1_ReadCounter       ; deprecated
                                        (0052) 
                                        (0053) ;-----------------------------------------------
                                        (0054) ;  Constant Definitions
                                        (0055) ;-----------------------------------------------
                                        (0056) INPUT_REG_NULL:                equ 0x00    ; Clear the input register
                                        (0057) 
                                        (0058) 
                                        (0059) AREA UserModules (ROM, REL)
                                        (0060) 
                                        (0061) .SECTION
                                        (0062) ;-----------------------------------------------------------------------------
                                        (0063) ;  FUNCTION NAME: Counter16_1_EnableInt
                                        (0064) ;
                                        (0065) ;  DESCRIPTION:
                                        (0066) ;     Enables this counter's interrupt by setting the interrupt enable mask bit
                                        (0067) ;     associated with this User Module. This function has no effect until and
                                        (0068) ;     unless the global interrupts are enabled (for example by using the
                                        (0069) ;     macro M8C_EnableGInt).
                                        (0070) ;-----------------------------------------------------------------------------
                                        (0071) ;
                                        (0072) ;  ARGUMENTS:    None.
                                        (0073) ;  RETURNS:      Nothing.
                                        (0074) ;  SIDE EFFECTS: 
                                        (0075) ;    The A and X registers may be modified by this or future implementations
                                        (0076) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0077) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0078) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0079) ;    functions.
                                        (0080) ;
                                        (0081)  Counter16_1_EnableInt:
                                        (0082) _Counter16_1_EnableInt:
                                        (0083)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0084)    Counter16_1_EnableInt_M
                                        (0085)    RAM_EPILOGUE RAM_USE_CLASS_1
054F: 7F       RET                      (0086)    ret
0550: 43 23 01 OR    REG[0x23],0x1      
                                        (0087) 
                                        (0088) .ENDSECTION
                                        (0089) 
                                        (0090) .SECTION
                                        (0091) ;-----------------------------------------------------------------------------
                                        (0092) ;  FUNCTION NAME: Counter16_1_DisableInt
                                        (0093) ;
                                        (0094) ;  DESCRIPTION:
                                        (0095) ;     Disables this counter's interrupt by clearing the interrupt enable
                                        (0096) ;     mask bit associated with this User Module.
                                        (0097) ;-----------------------------------------------------------------------------
                                        (0098) ;
                                        (0099) ;  ARGUMENTS:    None
                                        (0100) ;  RETURNS:      Nothing
                                        (0101) ;  SIDE EFFECTS: 
                                        (0102) ;    The A and X registers may be modified by this or future implementations
                                        (0103) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0104) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0105) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0106) ;    functions.
                                        (0107) ;
                                        (0108)  Counter16_1_DisableInt:
                                        (0109) _Counter16_1_DisableInt:
                                        (0110)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0111)    Counter16_1_DisableInt_M
                                        (0112)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0113)    ret
                                        (0114) 
                                        (0115) 
                                        (0116) .ENDSECTION
                                        (0117) 
                                        (0118) .SECTION
                                        (0119) ;-----------------------------------------------------------------------------
                                        (0120) ;  FUNCTION NAME: Counter16_1_Start
                                        (0121) ;
                                        (0122) ;  DESCRIPTION:
                                        (0123) ;     Sets the start bit in the Control register of this user module.  The
                                        (0124) ;     counter will begin counting on the next input clock as soon as the
                                        (0125) ;     enable input is asserted high.
                                        (0126) ;-----------------------------------------------------------------------------
                                        (0127) ;
                                        (0128) ;  ARGUMENTS:    None
                                        (0129) ;  RETURNS:      Nothing
                                        (0130) ;  SIDE EFFECTS: 
                                        (0131) ;    The A and X registers may be modified by this or future implementations
                                        (0132) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0133) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0134) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0135) ;    functions.
                                        (0136) ;
                                        (0137)  Counter16_1_Start:
                                        (0138) _Counter16_1_Start:
                                        (0139)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0140)    Counter16_1_Start_M
                                        (0141)    RAM_EPILOGUE RAM_USE_CLASS_1
0553: 7F       RET                      (0142)    ret
0554: 41 23 FE AND   REG[0x23],0xFE     
                                        (0143) 
                                        (0144) 
                                        (0145) .ENDSECTION
                                        (0146) 
                                        (0147) .SECTION
                                        (0148) ;-----------------------------------------------------------------------------
                                        (0149) ;  FUNCTION NAME: Counter16_1_Stop
                                        (0150) ;
                                        (0151) ;  DESCRIPTION:
                                        (0152) ;     Disables counter operation by clearing the start bit in the Control
                                        (0153) ;     register of the LSB block.
                                        (0154) ;-----------------------------------------------------------------------------
                                        (0155) ;
                                        (0156) ;  ARGUMENTS:    None
                                        (0157) ;  RETURNS:      Nothing
                                        (0158) ;  SIDE EFFECTS: 
                                        (0159) ;    The A and X registers may be modified by this or future implementations
                                        (0160) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0161) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0162) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0163) ;    functions.
                                        (0164) ;
                                        (0165)  Counter16_1_Stop:
                                        (0166) _Counter16_1_Stop:
                                        (0167)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0168)    Counter16_1_Stop_M
                                        (0169)    RAM_EPILOGUE RAM_USE_CLASS_1
0557: 7F       RET                      (0170)    ret
                                        (0171) 
                                        (0172) 
                                        (0173) .ENDSECTION
                                        (0174) 
                                        (0175) .SECTION
                                        (0176) ;-----------------------------------------------------------------------------
                                        (0177) ;  FUNCTION NAME: Counter16_1_WritePeriod
                                        (0178) ;
                                        (0179) ;  DESCRIPTION:
                                        (0180) ;     Write the 16-bit period value into the Period register (DR1).
                                        (0181) ;-----------------------------------------------------------------------------
                                        (0182) ;
                                        (0183) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                        (0184) ;  RETURNS:   Nothing
                                        (0185) ;  SIDE EFFECTS:
                                        (0186) ;    If the counter user module is stopped, then this value will also be
                                        (0187) ;    latched into the Count registers (DR0).
                                        (0188) ;     
                                        (0189) ;    The A and X registers may be modified by this or future implementations
                                        (0190) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0191) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0192) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0193) ;    functions.
                                        (0194) ;
                                        (0195)  Counter16_1_WritePeriod:
                                        (0196) _Counter16_1_WritePeriod:
                                        (0197)    RAM_PROLOGUE RAM_USE_CLASS_1
0558: 60 21    MOV   REG[0x21],A        (0198)    mov   reg[Counter16_1_PERIOD_LSB_REG], A
055A: 5B       MOV   A,X                (0199)    mov   A, X
055B: 60 25    MOV   REG[0x25],A        (0200)    mov   reg[Counter16_1_PERIOD_MSB_REG], A
                                        (0201)    RAM_EPILOGUE RAM_USE_CLASS_1
055D: 7F       RET                      (0202)    ret
                                        (0203) 
                                        (0204) 
                                        (0205) .ENDSECTION
                                        (0206) 
                                        (0207) .SECTION
                                        (0208) ;-----------------------------------------------------------------------------
                                        (0209) ;  FUNCTION NAME: Counter16_1_WriteCompareValue
                                        (0210) ;
                                        (0211) ;  DESCRIPTION:
                                        (0212) ;     Writes compare value into the Compare register (DR2).
                                        (0213) ;-----------------------------------------------------------------------------
                                        (0214) ;
                                        (0215) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
                                        (0216) ;  RETURNS:      Nothing
                                        (0217) ;  SIDE EFFECTS: 
                                        (0218) ;    The A and X registers may be modified by this or future implementations
                                        (0219) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0220) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0221) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0222) ;    functions.
                                        (0223) ;
                                        (0224)  Counter16_1_WriteCompareValue:
                                        (0225) _Counter16_1_WriteCompareValue:
                                        (0226)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0227)    mov   reg[Counter16_1_COMPARE_LSB_REG], A
                                        (0228)    mov   A, X
                                        (0229)    mov   reg[Counter16_1_COMPARE_MSB_REG], A
                                        (0230)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0231)    ret
                                        (0232) 
                                        (0233) 
                                        (0234) .ENDSECTION
                                        (0235) 
                                        (0236) .SECTION
                                        (0237) ;-----------------------------------------------------------------------------
                                        (0238) ;  FUNCTION NAME: Counter16_1_wReadCompareValue
                                        (0239) ;
                                        (0240) ;  DESCRIPTION:
                                        (0241) ;     Reads the Compare registers.
                                        (0242) ;-----------------------------------------------------------------------------
                                        (0243) ;
                                        (0244) ;  ARGUMENTS:    None
                                        (0245) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                        (0246) ;  SIDE EFFECTS: 
                                        (0247) ;    The A and X registers may be modified by this or future implementations
                                        (0248) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0249) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0250) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0251) ;    functions.
                                        (0252) ;
                                        (0253)  Counter16_1_wReadCompareValue:
                                        (0254) _Counter16_1_wReadCompareValue:
                                        (0255)  wCounter16_1_ReadCompareValue:                  ; this name deprecated
                                        (0256) _wCounter16_1_ReadCompareValue:                  ; this name deprecated
                                        (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0258)    mov   A, reg[Counter16_1_COMPARE_MSB_REG]
                                        (0259)    mov   X, A
                                        (0260)    mov   A, reg[Counter16_1_COMPARE_LSB_REG]
                                        (0261)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0262)    ret
                                        (0263) 
                                        (0264) 
                                        (0265) .ENDSECTION
                                        (0266) 
                                        (0267) .SECTION
                                        (0268) ;-----------------------------------------------------------------------------
                                        (0269) ;  FUNCTION NAME: Counter16_1_wReadCounter
                                        (0270) ;
                                        (0271) ;  DESCRIPTION:
                                        (0272) ;     Returns the value in the Count register (DR0), preserving the value in
                                        (0273) ;     the compare register (DR2). Interrupts are prevented during the transfer
                                        (0274) ;     from the Count to the Compare registers by holding the clock low in
                                        (0275) ;     the MSB PSoC block.
                                        (0276) ;-----------------------------------------------------------------------------
                                        (0277) ;
                                        (0278) ;  ARGUMENTS: None
                                        (0279) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                        (0280) ;  SIDE EFFECTS:
                                        (0281) ;     1) The user module is stopped momentarily and one or more counts may be missed.
                                        (0282) ;     2) The A and X registers may be modified by this or future implementations
                                        (0283) ;        of this function.  The same is true for all RAM page pointer registers in
                                        (0284) ;        the Large Memory Model.  When necessary, it is the calling function's
                                        (0285) ;        responsibility to perserve their values across calls to fastcall16 
                                        (0286) ;        functions.
                                        (0287) ;
                                        (0288)  Counter16_1_wReadCounter:
                                        (0289) _Counter16_1_wReadCounter:
                                        (0290)  wCounter16_1_ReadCounter:                       ; this name deprecated
                                        (0291) _wCounter16_1_ReadCounter:                       ; this name deprecated
                                        (0292) 
                                        (0293)    bOrigCompareValue:      EQU   0                  ; Frame offset to temp Compare store
                                        (0294)    bOrigControlReg:        EQU   2                  ; Frame offset to temp CR0     store
                                        (0295)    bOrigClockSetting:      EQU   3                  ; Frame offset to temp Input   store
                                        (0296)    wCounter:               EQU   4                  ; Frame offset to temp Count   store
                                        (0297)    STACK_FRAME_SIZE:       EQU   6                  ; max stack frame size is 6 bytes
                                        (0298) 
                                        (0299)    RAM_PROLOGUE RAM_USE_CLASS_2
055E: 4F       MOV   X,SP               (0300)    mov   X, SP                                      ; X <-  stack frame pointer
055F: 5D 26    MOV   A,REG[0x26]        (0301)    mov   A, reg[Counter16_1_COMPARE_MSB_REG]     ; Save the Compare register on the stack
0561: 08       PUSH  A                  (0302)    push  A                                          ;
0562: 5D 22    MOV   A,REG[0x22]        (0303)    mov   A, reg[Counter16_1_COMPARE_LSB_REG]     ;
0564: 08       PUSH  A                  (0304)    push  A                                          ;   -stack frame now 2 bytes-
0565: 5D 23    MOV   A,REG[0x23]        (0305)    mov   A, reg[Counter16_1_CONTROL_LSB_REG]     ; Save CR0 (running or stopped state)
0567: 08       PUSH  A                  (0306)    push  A                                          ;   -stack frame now 3 bytes-
0568: 41 23 FE AND   REG[0x23],0xFE     
056B: 71 10    OR    F,0x10             
                                        (0307)    Counter16_1_Stop_M                            ; Disable (stop) the Counter if running
                                        (0308)    M8C_SetBank1                                     ;
056D: 5D 21    MOV   A,REG[0x21]        (0309)    mov   A, reg[Counter16_1_INPUT_LSB_REG]       ; save the LSB clock input setting
056F: 08       PUSH  A                  (0310)    push  A                                          ;   on the stack (now 4 bytes) and ...
                                        (0311)                                                     ;   hold the clock low:
0570: 62 21 00 MOV   REG[0x21],0x0      (0312)    mov   reg[Counter16_1_INPUT_LSB_REG], INPUT_REG_NULL
0573: 70 EF    AND   F,0xEF             
                                        (0313)    M8C_SetBank0                                     ; Extract the Count via DR2 register
0575: 5D 24    MOV   A,REG[0x24]        (0314)    mov   A, reg[Counter16_1_COUNTER_MSB_REG]     ; DR2 <- DR0 (in the MSB block)
0577: 5D 26    MOV   A,REG[0x26]        (0315)    mov   A, reg[Counter16_1_COMPARE_MSB_REG]     ; Stash the Count MSB on the stack
0579: 08       PUSH  A                  (0316)    push  A                                          ;   -stack frame is now 5 bytes
057A: 5D 20    MOV   A,REG[0x20]        (0317)    mov   A, reg[Counter16_1_COUNTER_LSB_REG]     ; DR2 <- DR0 (in the LSB block)
057C: 5D 22    MOV   A,REG[0x22]        (0318)    mov   A, reg[Counter16_1_COMPARE_LSB_REG]     ; Stash the Count LSB on the stack
057E: 08       PUSH  A                  (0319)    push  A                                          ;   -stack frame is now 6 bytes-
057F: 52 00    MOV   A,[X+0]            (0320)    mov   A, [X+bOrigCompareValue]                   ; Restore the Compare MSB register
0581: 60 26    MOV   REG[0x26],A        (0321)    mov   reg[Counter16_1_COMPARE_MSB_REG], A     ;
0583: 52 01    MOV   A,[X+1]            (0322)    mov   A, [X+bOrigCompareValue+1]                 ; Restore the Compare LSB register
0585: 60 22    MOV   REG[0x22],A        (0323)    mov   reg[Counter16_1_COMPARE_LSB_REG], A     ;
0587: 71 10    OR    F,0x10             
                                        (0324)    M8C_SetBank1                                     ; ---Restore the counter operation
0589: 52 03    MOV   A,[X+3]            (0325)    mov   A, [X+bOrigClockSetting]                   ; Grab the LSB clock setting...
058B: 60 21    MOV   REG[0x21],A        (0326)    mov   reg[Counter16_1_INPUT_LSB_REG], A       ;   and restore it
058D: 70 EF    AND   F,0xEF             
                                        (0327)    M8C_SetBank0                                     ; Now re-enable (start) the counter
058F: 52 02    MOV   A,[X+2]            (0328)    mov   A, [X+bOrigControlReg]                     ;   if it was running when
0591: 60 23    MOV   REG[0x23],A        (0329)    mov   reg[Counter16_1_CONTROL_LSB_REG], A     ;   this function was first called
0593: 18       POP   A                  (0330)    pop   A                                          ; Setup the return value
0594: 20       POP   X                  (0331)    pop   X                                          ;
0595: 38 FC    ADD   SP,0xFC            (0332)    ADD   SP, -(STACK_FRAME_SIZE-2)                  ; Zap remainder of stack frame
                                        (0333)    RAM_EPILOGUE RAM_USE_CLASS_2
0597: 7F       RET                      (0334)    ret
                                        (0335) 
                                        (0336) .ENDSECTION
                                        (0337) 
                                        (0338) ; End of File Counter16_1.asm
_bE2Write:
    0598: 62 D0 00 MOV   REG[0xD0],0x0
    059B: 4F       MOV   X,SP
    059C: 4B       SWAP  A,X
    059D: 39 EA    CMP   A,0xEA
    059F: C0 06    JC    0x05A6
    05A1: 50 FE    MOV   A,0xFE
    05A3: 38 FE    ADD   SP,0xFE
    05A5: 7E       RETI  
    05A6: 4F       MOV   X,SP
    05A7: 79       DEC   X
    05A8: 79       DEC   X
    05A9: 38 09    ADD   SP,0x9
    05AB: 56 08 00 MOV   [X+8],0x0
    05AE: 52 FB    MOV   A,[X-5]
    05B0: 08       PUSH  A
    05B1: 52 FC    MOV   A,[X-4]
    05B3: 08       PUSH  A
    05B4: 69 FB    ASR   [X-5]
    05B6: 6F FC    RRC   [X-4]
    05B8: 69 FB    ASR   [X-5]
    05BA: 6F FC    RRC   [X-4]
    05BC: 69 FB    ASR   [X-5]
    05BE: 6F FC    RRC   [X-4]
    05C0: 69 FB    ASR   [X-5]
    05C2: 6F FC    RRC   [X-4]
    05C4: 69 FB    ASR   [X-5]
    05C6: 6F FC    RRC   [X-4]
    05C8: 69 FB    ASR   [X-5]
    05CA: 6F FC    RRC   [X-4]
    05CC: 52 FC    MOV   A,[X-4]
    05CE: 05 01    ADD   [X+1],A
    05D0: 52 FB    MOV   A,[X-5]
    05D2: 0D 00    ADC   [X+0],A
    05D4: 18       POP   A
    05D5: 54 FC    MOV   [X-4],A
    05D7: 18       POP   A
    05D8: 54 FB    MOV   [X-5],A
    05DA: 52 FA    MOV   A,[X-6]
    05DC: 54 03    MOV   [X+3],A
    05DE: 52 F9    MOV   A,[X-7]
    05E0: 54 02    MOV   [X+2],A
    05E2: 52 F6    MOV   A,[X-10]
    05E4: 54 04    MOV   [X+4],A
    05E6: 52 FC    MOV   A,[X-4]
    05E8: 21 3F    AND   A,0x3F
    05EA: 54 09    MOV   [X+9],A
    05EC: 50 40    MOV   A,0x40
    05EE: 13 09    SUB   A,[X+9]
    05F0: 54 0A    MOV   [X+10],A
    05F2: 52 F7    MOV   A,[X-9]
    05F4: B0 09    JNZ   0x05FE
    05F6: 52 F8    MOV   A,[X-8]
    05F8: 3B 0A    CMP   A,[X+10]
    05FA: D0 03    JNC   0x05FE
    05FC: 54 0A    MOV   [X+10],A
    05FE: 3D 0A 40 CMP   [X+10],0x40
    0601: B0 1C    JNZ   0x061E
    0603: 56 08 FF MOV   [X+8],0xFF
    0606: 10       PUSH  X
    0607: 5B       MOV   A,X
    0608: 01 01    ADD   A,0x1
    060A: 5C       MOV   X,A
    060B: 5D D1    MOV   A,REG[0xD1]
    060D: 70 3F    AND   F,0x3F
    060F: 71 C0    OR    F,0xC0
    0611: 7C 07 94 LCALL _bFlashWriteBlock
    0614: 20       POP   X
    0615: 39 00    CMP   A,0x0
    0617: A0 4D    JZ    0x0665
    0619: 56 08 00 MOV   [X+8],0x0
    061C: 80 1D    JMP   0x063A
    061E: 52 03    MOV   A,[X+3]
    0620: 54 FA    MOV   [X-6],A
    0622: 52 02    MOV   A,[X+2]
    0624: 54 F9    MOV   [X-7],A
    0626: 90 46    CALL  0x066E
    0628: 52 08    MOV   A,[X+8]
    062A: 39 FF    CMP   A,0xFF
    062C: A0 38    JZ    0x0665
    062E: 39 FE    CMP   A,0xFE
    0630: A0 34    JZ    0x0665
    0632: 52 FA    MOV   A,[X-6]
    0634: 54 03    MOV   [X+3],A
    0636: 52 F9    MOV   A,[X-7]
    0638: 54 02    MOV   [X+2],A
    063A: 52 F8    MOV   A,[X-8]
    063C: 13 0A    SUB   A,[X+10]
    063E: 54 F8    MOV   [X-8],A
    0640: D0 03    JNC   0x0644
    0642: 7B F7    DEC   [X-9]
    0644: 52 F8    MOV   A,[X-8]
    0646: 2B F7    OR    A,[X-9]
    0648: A0 1C    JZ    0x0665
    064A: 77 01    INC   [X+1]
    064C: 0F 00 00 ADC   [X+0],0x0
    064F: 52 03    MOV   A,[X+3]
    0651: 03 0A    ADD   A,[X+10]
    0653: 54 03    MOV   [X+3],A
    0655: D0 03    JNC   0x0659
    0657: 77 02    INC   [X+2]
    0659: 52 FC    MOV   A,[X-4]
    065B: 03 0A    ADD   A,[X+10]
    065D: 54 FC    MOV   [X-4],A
    065F: DF 86    JNC   0x05E6
    0661: 77 FB    INC   [X-5]
    0663: 8F 82    JMP   0x05E6
    0665: 52 08    MOV   A,[X+8]
    0667: 38 F5    ADD   SP,0xF5
    0669: 70 3F    AND   F,0x3F
    066B: 71 C0    OR    F,0xC0
    066D: 7E       RETI  
    066E: 5B       MOV   A,X
    066F: 4F       MOV   X,SP
    0670: 4B       SWAP  A,X
    0671: 39 A0    CMP   A,0xA0
    0673: C0 05    JC    0x0679
    0675: 56 08 FE MOV   [X+8],0xFE
    0678: 7F       RET   
    0679: 38 44    ADD   SP,0x44
    067B: 52 09    MOV   A,[X+9]
    067D: 03 0A    ADD   A,[X+10]
    067F: 54 0D    MOV   [X+13],A
    0681: 52 09    MOV   A,[X+9]
    0683: A0 22    JZ    0x06A6
    0685: 10       PUSH  X
    0686: 50 00    MOV   A,0x0
    0688: 08       PUSH  A
    0689: 52 09    MOV   A,[X+9]
    068B: 08       PUSH  A
    068C: 5D D1    MOV   A,REG[0xD1]
    068E: 08       PUSH  A
    068F: 5B       MOV   A,X
    0690: 01 0E    ADD   A,0xE
    0692: 08       PUSH  A
    0693: 50 00    MOV   A,0x0
    0695: 08       PUSH  A
    0696: 08       PUSH  A
    0697: 52 00    MOV   A,[X+0]
    0699: 08       PUSH  A
    069A: 52 01    MOV   A,[X+1]
    069C: 20       POP   X
    069D: 70 3F    AND   F,0x3F
    069F: 71 C0    OR    F,0xC0
    06A1: 90 84    CALL  0x0727
    06A3: 38 FA    ADD   SP,0xFA
    06A5: 20       POP   X
    06A6: 3D 0D 40 CMP   [X+13],0x40
    06A9: D0 28    JNC   0x06D2
    06AB: 10       PUSH  X
    06AC: 50 00    MOV   A,0x0
    06AE: 08       PUSH  A
    06AF: 50 40    MOV   A,0x40
    06B1: 13 0D    SUB   A,[X+13]
    06B3: 08       PUSH  A
    06B4: 5D D1    MOV   A,REG[0xD1]
    06B6: 08       PUSH  A
    06B7: 5B       MOV   A,X
    06B8: 01 0E    ADD   A,0xE
    06BA: 0B 0D    ADC   A,[X+13]
    06BC: 08       PUSH  A
    06BD: 50 00    MOV   A,0x0
    06BF: 08       PUSH  A
    06C0: 52 0D    MOV   A,[X+13]
    06C2: 08       PUSH  A
    06C3: 52 00    MOV   A,[X+0]
    06C5: 08       PUSH  A
    06C6: 52 01    MOV   A,[X+1]
    06C8: 20       POP   X
    06C9: 70 3F    AND   F,0x3F
    06CB: 71 C0    OR    F,0xC0
    06CD: 90 58    CALL  0x0727
    06CF: 38 FA    ADD   SP,0xFA
    06D1: 20       POP   X
    06D2: 5B       MOV   A,X
    06D3: 03 09    ADD   A,[X+9]
    06D5: 01 0E    ADD   A,0xE
    06D7: 53 FC    MOV   [_ramareas_end+101],A
    06D9: 5D D1    MOV   A,REG[0xD1]
    06DB: 60 D5    MOV   REG[0xD5],A
    06DD: 52 03    MOV   A,[X+3]
    06DF: 53 FA    MOV   [_ramareas_end+99],A
    06E1: 52 02    MOV   A,[X+2]
    06E3: 60 D4    MOV   REG[0xD4],A
    06E5: 52 0D    MOV   A,[X+13]
    06E7: 13 09    SUB   A,[X+9]
    06E9: 53 FF    MOV   [_ramareas_end+104],A
    06EB: 3E FA    MVI   A,[_ramareas_end+99]
    06ED: 3F FC    MVI   [_ramareas_end+101],A
    06EF: 51 FA    MOV   A,[_ramareas_end+99]
    06F1: B0 06    JNZ   0x06F8
    06F3: 5D D4    MOV   A,REG[0xD4]
    06F5: 74       INC   A
    06F6: 60 D4    MOV   REG[0xD4],A
    06F8: 7A FF    DEC   [_ramareas_end+104]
    06FA: BF F0    JNZ   0x06EB
    06FC: 52 03    MOV   A,[X+3]
    06FE: 08       PUSH  A
    06FF: 5B       MOV   A,X
    0700: 01 0E    ADD   A,0xE
    0702: 54 03    MOV   [X+3],A
    0704: 5D D1    MOV   A,REG[0xD1]
    0706: 54 02    MOV   [X+2],A
    0708: 56 08 FF MOV   [X+8],0xFF
    070B: 10       PUSH  X
    070C: 5B       MOV   A,X
    070D: 01 01    ADD   A,0x1
    070F: 5C       MOV   X,A
    0710: 5D D1    MOV   A,REG[0xD1]
    0712: 70 3F    AND   F,0x3F
    0714: 71 C0    OR    F,0xC0
    0716: 7C 07 94 LCALL _bFlashWriteBlock
    0719: 20       POP   X
    071A: 39 00    CMP   A,0x0
    071C: A0 04    JZ    0x0721
    071E: 56 08 00 MOV   [X+8],0x0
    0721: 18       POP   A
    0722: 54 03    MOV   [X+3],A
    0724: 38 BC    ADD   SP,0xBC
    0726: 7F       RET   
    0727: 53 F8    MOV   [_ramareas_end+97],A
    0729: 5D F7    MOV   A,REG[0xF7]
    072B: 08       PUSH  A
    072C: 51 F8    MOV   A,[_ramareas_end+97]
_E2Read:
    072E: 08       PUSH  A
    072F: 10       PUSH  X
    0730: 62 D0 00 MOV   REG[0xD0],0x0
    0733: 20       POP   X
    0734: 18       POP   A
    0735: 5A F8    MOV   [_ramareas_end+97],X
    0737: 64       ASL   A
    0738: 6B F8    RLC   [_ramareas_end+97]
    073A: 64       ASL   A
    073B: 6B F8    RLC   [_ramareas_end+97]
    073D: 64       ASL   A
    073E: 6B F8    RLC   [_ramareas_end+97]
    0740: 64       ASL   A
    0741: 6B F8    RLC   [_ramareas_end+97]
    0743: 64       ASL   A
    0744: 6B F8    RLC   [_ramareas_end+97]
    0746: 64       ASL   A
    0747: 6B F8    RLC   [_ramareas_end+97]
    0749: 21 C0    AND   A,0xC0
    074B: 53 F9    MOV   [_ramareas_end+98],A
    074D: 4F       MOV   X,SP
    074E: 52 F7    MOV   A,[X-9]
    0750: 2B F8    OR    A,[X-8]
    0752: A0 3B    JZ    0x078E
    0754: 52 F7    MOV   A,[X-9]
    0756: 53 FE    MOV   [_ramareas_end+103],A
    0758: 52 F8    MOV   A,[X-8]
    075A: 53 FF    MOV   [_ramareas_end+104],A
    075C: 76 FE    INC   [_ramareas_end+103]
    075E: 52 FA    MOV   A,[X-6]
    0760: 53 FD    MOV   [_ramareas_end+102],A
    0762: 52 F9    MOV   A,[X-7]
    0764: 60 D5    MOV   REG[0xD5],A
    0766: 51 F9    MOV   A,[_ramareas_end+98]
    0768: 05 FC    ADD   [X-4],A
    076A: 51 F8    MOV   A,[_ramareas_end+97]
    076C: 0D FB    ADC   [X-5],A
    076E: 52 FB    MOV   A,[X-5]
    0770: 59 FC    MOV   X,[X-4]
    0772: 08       PUSH  A
    0773: 28       ROMX  
    0774: 3F FD    MVI   [_ramareas_end+102],A
    0776: 18       POP   A
    0777: 75       INC   X
    0778: B0 02    JNZ   0x077B
    077A: 74       INC   A
    077B: 08       PUSH  A
    077C: 51 FD    MOV   A,[_ramareas_end+102]
    077E: B0 06    JNZ   0x0785
    0780: 5D D5    MOV   A,REG[0xD5]
    0782: 74       INC   A
    0783: 60 D5    MOV   REG[0xD5],A
    0785: 18       POP   A
    0786: 7A FF    DEC   [_ramareas_end+104]
    0788: BF E9    JNZ   0x0772
    078A: 7A FE    DEC   [_ramareas_end+103]
    078C: BF E5    JNZ   0x0772
    078E: 70 3F    AND   F,0x3F
    0790: 71 C0    OR    F,0xC0
    0792: 7E       RETI  
    0793: 30       HALT  
_bFlashWriteBlock:
    0794: 62 D0 00 MOV   REG[0xD0],0x0
    0797: 53 F8    MOV   [_ramareas_end+97],A
    0799: 5D F7    MOV   A,REG[0xF7]
    079B: 08       PUSH  A
    079C: 21 C0    AND   A,0xC0
    079E: B0 07    JNZ   0x07A6
    07A0: 56 01 00 MOV   [X+1],0x0
    07A3: 55 F8 00 MOV   [_ramareas_end+97],0x0
    07A6: 51 F8    MOV   A,[_ramareas_end+97]
    07A8: 70 3F    AND   F,0x3F
    07AA: 71 80    OR    F,0x80
    07AC: 60 D3    MOV   REG[0xD3],A
    07AE: 55 FD 01 MOV   [_ramareas_end+102],0x1
    07B1: 3C FD 01 CMP   [_ramareas_end+102],0x1
    07B4: B0 E2    JNZ   0x0897
    07B6: 7C 00 F2 LCALL 0x00F2
    07B9: 21 06    AND   A,0x6
    07BB: A0 19    JZ    0x07D5
    07BD: 71 10    OR    F,0x10
    07BF: 5D E0    MOV   A,REG[0xE0]
    07C1: 08       PUSH  A
    07C2: 21 F8    AND   A,0xF8
    07C4: 49 FE 10 TST   REG[0xFE],0x10
    07C7: A0 05    JZ    0x07CD
    07C9: 29 02    OR    A,0x2
    07CB: 80 03    JMP   0x07CF
    07CD: 29 00    OR    A,0x0
    07CF: 60 E0    MOV   REG[0xE0],A
    07D1: 70 EF    AND   F,0xEF
    07D3: 80 17    JMP   0x07EB
    07D5: 71 10    OR    F,0x10
    07D7: 5D E0    MOV   A,REG[0xE0]
    07D9: 08       PUSH  A
    07DA: 21 F8    AND   A,0xF8
    07DC: 49 FE 10 TST   REG[0xFE],0x10
    07DF: A0 05    JZ    0x07E5
    07E1: 29 03    OR    A,0x3
    07E3: 80 03    JMP   0x07E7
    07E5: 29 02    OR    A,0x2
    07E7: 60 E0    MOV   REG[0xE0],A
    07E9: 70 EF    AND   F,0xEF
    07EB: 62 E3 00 MOV   REG[0xE3],0x0
    07EE: 65 FD    ASL   [_ramareas_end+102]
    07F0: 3C FD 02 CMP   [_ramareas_end+102],0x2
    07F3: B0 A3    JNZ   0x0897
    07F5: 90 B0    CALL  0x08A7
    07F7: 39 00    CMP   A,0x0
    07F9: A0 09    JZ    0x0803
    07FB: 55 FF 00 MOV   [_ramareas_end+104],0x0
    07FE: 55 FD 10 MOV   [_ramareas_end+102],0x10
    0801: 80 80    JMP   0x0882
    0803: 65 FD    ASL   [_ramareas_end+102]
    0805: 71 10    OR    F,0x10
    0807: 49 E4 08 TST   REG[0xE4],0x8
    080A: A0 05    JZ    0x0810
    080C: 70 EF    AND   F,0xEF
    080E: 80 2E    JMP   0x083D
    0810: 70 EF    AND   F,0xEF
    0812: 62 E3 00 MOV   REG[0xE3],0x0
    0815: 52 00    MOV   A,[X+0]
    0817: 53 FA    MOV   [_ramareas_end+99],A
    0819: 52 04    MOV   A,[X+4]
    081B: 53 FC    MOV   [_ramareas_end+101],A
    081D: 55 FE 56 MOV   [_ramareas_end+103],0x56
    0820: 51 FD    MOV   A,[_ramareas_end+102]
    0822: 39 04    CMP   A,0x4
    0824: B0 72    JNZ   0x0897
    0826: 08       PUSH  A
    0827: 10       PUSH  X
_FlashBlockLocal1:
    0828: 4F       MOV   X,SP
    0829: 5B       MOV   A,X
    082A: 01 03    ADD   A,0x3
    082C: 53 F9    MOV   [_ramareas_end+98],A
    082E: 55 F8 3A MOV   [_ramareas_end+97],0x3A
    0831: 50 03    MOV   A,0x3
    0833: 00       SWI   
    0834: 20       POP   X
    0835: 18       POP   A
    0836: 53 FD    MOV   [_ramareas_end+102],A
    0838: 3C F8 00 CMP   [_ramareas_end+97],0x0
    083B: A0 09    JZ    0x0845
    083D: 55 FF 00 MOV   [_ramareas_end+104],0x0
    0840: 55 FD 10 MOV   [_ramareas_end+102],0x10
    0843: 80 3E    JMP   0x0882
    0845: 62 E3 00 MOV   REG[0xE3],0x0
    0848: 65 FD    ASL   [_ramareas_end+102]
    084A: 52 00    MOV   A,[X+0]
    084C: 53 FA    MOV   [_ramareas_end+99],A
    084E: 52 02    MOV   A,[X+2]
    0850: 53 FB    MOV   [_ramareas_end+100],A
    0852: 52 01    MOV   A,[X+1]
    0854: 60 D4    MOV   REG[0xD4],A
    0856: 52 05    MOV   A,[X+5]
    0858: 53 FC    MOV   [_ramareas_end+101],A
    085A: 55 FE 56 MOV   [_ramareas_end+103],0x56
    085D: 51 FD    MOV   A,[_ramareas_end+102]
    085F: 39 08    CMP   A,0x8
    0861: B0 35    JNZ   0x0897
    0863: 08       PUSH  A
    0864: 10       PUSH  X
_FlashBlockLocal2:
    0865: 4F       MOV   X,SP
    0866: 5B       MOV   A,X
    0867: 01 03    ADD   A,0x3
    0869: 53 F9    MOV   [_ramareas_end+98],A
    086B: 55 F8 3A MOV   [_ramareas_end+97],0x3A
    086E: 50 02    MOV   A,0x2
    0870: 00       SWI   
    0871: 20       POP   X
    0872: 18       POP   A
    0873: 53 FD    MOV   [_ramareas_end+102],A
    0875: 55 FF 01 MOV   [_ramareas_end+104],0x1
    0878: 3C F8 00 CMP   [_ramareas_end+97],0x0
    087B: A0 04    JZ    0x0880
    087D: 55 FF 00 MOV   [_ramareas_end+104],0x0
    0880: 65 FD    ASL   [_ramareas_end+102]
    0882: 3C FD 10 CMP   [_ramareas_end+102],0x10
    0885: B0 11    JNZ   0x0897
    0887: 18       POP   A
    0888: 71 10    OR    F,0x10
    088A: 60 E0    MOV   REG[0xE0],A
    088C: 70 EF    AND   F,0xEF
    088E: 65 FD    ASL   [_ramareas_end+102]
    0890: 51 FF    MOV   A,[_ramareas_end+104]
    0892: 3C FD 20 CMP   [_ramareas_end+102],0x20
    0895: A0 04    JZ    0x089A
    0897: 30       HALT  
    0898: 8F FE    JMP   0x0897
    089A: 62 D0 00 MOV   REG[0xD0],0x0
    089D: 62 D5 00 MOV   REG[0xD5],0x0
    08A0: 62 D4 00 MOV   REG[0xD4],0x0
    08A3: 7E       RETI  
    08A4: 30       HALT  
    08A5: 30       HALT  
    08A6: 30       HALT  
    08A7: 55 FA 03 MOV   [_ramareas_end+99],0x3
    08AA: 62 D5 00 MOV   REG[0xD5],0x0
    08AD: 51 FD    MOV   A,[_ramareas_end+102]
    08AF: 39 02    CMP   A,0x2
    08B1: BF E5    JNZ   0x0897
    08B3: 08       PUSH  A
    08B4: 10       PUSH  X
_FlashBlockLocal3:
    08B5: 4F       MOV   X,SP
    08B6: 5B       MOV   A,X
    08B7: 01 03    ADD   A,0x3
    08B9: 53 F9    MOV   [_ramareas_end+98],A
    08BB: 55 F8 3A MOV   [_ramareas_end+97],0x3A
    08BE: 50 06    MOV   A,0x6
    08C0: 00       SWI   
    08C1: 20       POP   X
    08C2: 3C FF 01 CMP   [_ramareas_end+104],0x1
    08C5: B0 80    JNZ   0x0946
    08C7: 10       PUSH  X
    08C8: 5D D3    MOV   A,REG[0xD3]
    08CA: 08       PUSH  A
    08CB: 52 03    MOV   A,[X+3]
    08CD: 08       PUSH  A
    08CE: 62 D3 00 MOV   REG[0xD3],0x0
    08D1: 21 80    AND   A,0x80
    08D3: B0 05    JNZ   0x08D9
    08D5: 57 FB    MOV   X,0xFB
    08D7: 80 07    JMP   0x08DF
    08D9: 57 F8    MOV   X,0xF8
    08DB: 18       POP   A
    08DC: 73       CPL   A
    08DD: 74       INC   A
    08DE: 08       PUSH  A
    08DF: 18       POP   A
    08E0: 10       PUSH  X
    08E1: 08       PUSH  A
    08E2: 52 00    MOV   A,[X+0]
    08E4: 20       POP   X
    08E5: 90 69    CALL  0x0950
    08E7: 64       ASL   A
    08E8: 5B       MOV   A,X
    08E9: 6A       RLC   A
    08EA: 20       POP   X
    08EB: 08       PUSH  A
    08EC: 5B       MOV   A,X
    08ED: 39 F8    CMP   A,0xF8
    08EF: A0 05    JZ    0x08F5
    08F1: 18       POP   A
    08F2: 73       CPL   A
    08F3: 74       INC   A
    08F4: 08       PUSH  A
    08F5: 18       POP   A
    08F6: 03 01    ADD   A,[X+1]
    08F8: 53 FE    MOV   [_ramareas_end+103],A
    08FA: 52 02    MOV   A,[X+2]
    08FC: 10       PUSH  X
    08FD: 5C       MOV   X,A
    08FE: 51 FE    MOV   A,[_ramareas_end+103]
    0900: 90 4E    CALL  0x0950
    0902: 4B       SWAP  A,X
    0903: 53 FF    MOV   [_ramareas_end+104],A
    0905: 5B       MOV   A,X
    0906: 20       POP   X
    0907: 64       ASL   A
    0908: 6B FF    RLC   [_ramareas_end+104]
    090A: 64       ASL   A
    090B: 6B FF    RLC   [_ramareas_end+104]
    090D: 51 FF    MOV   A,[_ramareas_end+104]
    090F: 5C       MOV   X,A
    0910: 18       POP   A
    0911: 60 D3    MOV   REG[0xD3],A
    0913: 5B       MOV   A,X
    0914: 20       POP   X
    0915: 54 05    MOV   [X+5],A
    0917: 51 FE    MOV   A,[_ramareas_end+103]
    0919: 54 04    MOV   [X+4],A
    091B: 7C 00 F2 LCALL 0x00F2
    091E: 21 06    AND   A,0x6
    0920: A0 07    JZ    0x0928
    0922: 69 04    ASR   [X+4]
    0924: 69 05    ASR   [X+5]
    0926: 80 0D    JMP   0x0934
    0928: 49 FE 10 TST   REG[0xFE],0x10
    092B: A0 10    JZ    0x093C
    092D: 7C 00 F2 LCALL 0x00F2
    0930: 21 04    AND   A,0x4
    0932: B0 09    JNZ   0x093C
    0934: 69 05    ASR   [X+5]
    0936: 77 05    INC   [X+5]
    0938: 69 04    ASR   [X+4]
    093A: 77 04    INC   [X+4]
    093C: 18       POP   A
    093D: 39 02    CMP   A,0x2
    093F: BF 57    JNZ   0x0897
    0941: 53 FD    MOV   [_ramareas_end+102],A
    0943: 50 00    MOV   A,0x0
    0945: 7F       RET   
    0946: 18       POP   A
    0947: 39 02    CMP   A,0x2
    0949: BF 4D    JNZ   0x0897
    094B: 53 FD    MOV   [_ramareas_end+102],A
    094D: 50 01    MOV   A,0x1
    094F: 7F       RET   
    0950: 71 40    OR    F,0x40
    0952: 08       PUSH  A
    0953: 5B       MOV   A,X
    0954: 4F       MOV   X,SP
    0955: 79       DEC   X
    0956: 08       PUSH  A
    0957: 50 00    MOV   A,0x0
    0959: 08       PUSH  A
    095A: 08       PUSH  A
    095B: 52 00    MOV   A,[X+0]
    095D: A0 1C    JZ    0x097A
    095F: 52 01    MOV   A,[X+1]
    0961: A0 18    JZ    0x097A
    0963: 50 08    MOV   A,0x8
    0965: 70 FB    AND   F,0xFB
    0967: 6F 00    RRC   [X+0]
    0969: D0 09    JNC   0x0973
    096B: 08       PUSH  A
    096C: 52 01    MOV   A,[X+1]
    096E: 70 FB    AND   F,0xFB
    0970: 05 02    ADD   [X+2],A
    0972: 18       POP   A
    0973: 6F 02    RRC   [X+2]
    0975: 6F 03    RRC   [X+3]
    0977: 78       DEC   A
    0978: BF EC    JNZ   0x0965
    097A: 52 02    MOV   A,[X+2]
    097C: 08       PUSH  A
    097D: 52 03    MOV   A,[X+3]
    097F: 20       POP   X
    0980: 38 FC    ADD   SP,0xFC
    0982: 70 BF    AND   F,0xBF
    0984: 7F       RET   
FILE: C:\Users\Ralf\DOCUME~1\DSM_SA~1\DSM_SA~1\DSM_SA~1\config.c
(0001) #include "config.h"
(0002) 
(0003) extern CHAR  E2PROM_1_bE2Write(WORD wAddr, BYTE * pbData, WORD wByteCount, CHAR cTemperature);
(0004) extern void  E2PROM_1_E2Read(WORD wAddr, BYTE * pbDataDest, WORD wByteCount);
(0005) 
(0006) 
(0007) RAM_D mem;
(0008) #define buf mem.buf
(0009) 
(0010) void SaveConfig(BYTE options,BYTE Nr)
(0011) {
__UserModules_end|_FlashReadBlock|_SaveConfig|__text_start|_SaveConfig:
  Nr                   --> X-5
  options              --> X-4
    0985: 10       PUSH  X
    0986: 4F       MOV   X,SP
(0012) Nr=Nr&0xF;
    0987: 27 FB 0F AND   [X-5],0xF
(0013) #ifndef DEBUG
(0014) E2PROM_1_E2Read(0,buf,32);
    098A: 10       PUSH  X
    098B: 50 00    MOV   A,0x0
    098D: 08       PUSH  A
    098E: 50 20    MOV   A,0x20
    0990: 08       PUSH  A
    0991: 50 00    MOV   A,0x0
    0993: 08       PUSH  A
    0994: 50 26    MOV   A,0x26
    0996: 08       PUSH  A
    0997: 50 00    MOV   A,0x0
    0999: 08       PUSH  A
    099A: 08       PUSH  A
    099B: 7C 05 26 LCALL _E2PROM_1_E2Read
    099E: 38 FA    ADD   SP,0xFA
    09A0: 20       POP   X
(0015) #endif
(0016) buf[Nr*2]=CONFIG_ID;
    09A1: 52 FB    MOV   A,[X-5]
    09A3: 64       ASL   A
    09A4: 01 26    ADD   A,0x26
    09A6: 53 1C    MOV   [__r1],A
    09A8: 50 21    MOV   A,0x21
    09AA: 3F 1C    MVI   [__r1],A
(0017) buf[Nr*2+1]=options;
    09AC: 52 FB    MOV   A,[X-5]
    09AE: 64       ASL   A
    09AF: 01 27    ADD   A,0x27
    09B1: 53 1C    MOV   [__r1],A
    09B3: 52 FC    MOV   A,[X-4]
    09B5: 3F 1C    MVI   [__r1],A
(0018) #ifndef DEBUG
(0019) E2PROM_1_bE2Write(0,buf,64,25);
    09B7: 10       PUSH  X
    09B8: 50 19    MOV   A,0x19
    09BA: 08       PUSH  A
    09BB: 50 00    MOV   A,0x0
    09BD: 08       PUSH  A
    09BE: 50 40    MOV   A,0x40
    09C0: 08       PUSH  A
    09C1: 50 00    MOV   A,0x0
    09C3: 08       PUSH  A
    09C4: 50 26    MOV   A,0x26
    09C6: 08       PUSH  A
    09C7: 50 00    MOV   A,0x0
    09C9: 08       PUSH  A
    09CA: 08       PUSH  A
    09CB: 7C 05 1A LCALL E2PROM_1_bE2Write|_E2PROM_1_Stop|_E2PROM_1_bE2Write
    09CE: 38 F9    ADD   SP,0xF9
    09D0: 20       POP   X
    09D1: 20       POP   X
    09D2: 7F       RET   
(0020) #endif
(0021) }
(0022) 
(0023) BYTE ReadConfig(BYTE Nr)
(0024) {
_ReadConfig:
  Nr                   --> X-4
    09D3: 10       PUSH  X
    09D4: 4F       MOV   X,SP
(0025) Nr=Nr&0xF;
    09D5: 27 FC 0F AND   [X-4],0xF
(0026) #ifndef DEBUG
(0027) E2PROM_1_E2Read(0,buf,32);
    09D8: 10       PUSH  X
    09D9: 50 00    MOV   A,0x0
    09DB: 08       PUSH  A
    09DC: 50 20    MOV   A,0x20
    09DE: 08       PUSH  A
    09DF: 50 00    MOV   A,0x0
    09E1: 08       PUSH  A
    09E2: 50 26    MOV   A,0x26
    09E4: 08       PUSH  A
    09E5: 50 00    MOV   A,0x0
    09E7: 08       PUSH  A
    09E8: 08       PUSH  A
    09E9: 7C 05 26 LCALL _E2PROM_1_E2Read
    09EC: 38 FA    ADD   SP,0xFA
    09EE: 20       POP   X
(0028) #endif
(0029) if(buf[Nr*2]!=CONFIG_ID)
    09EF: 52 FC    MOV   A,[X-4]
    09F1: 64       ASL   A
    09F2: 01 26    ADD   A,0x26
    09F4: 53 1C    MOV   [__r1],A
    09F6: 3E 1C    MVI   A,[__r1]
    09F8: 39 21    CMP   A,0x21
    09FA: A0 05    JZ    0x0A00
(0030) 	{
(0031) 		return 0;
    09FC: 50 00    MOV   A,0x0
    09FE: 80 0A    JMP   0x0A09
(0032) 	}
(0033) else
(0034) 	{
(0035) 		return buf[Nr*2+1];
    0A00: 52 FC    MOV   A,[X-4]
(0036) 	}
(0037) }
(0038) 
(0039) 
(0040) 
FILE: C:\Users\Ralf\DOCUME~1\DSM_SA~1\DSM_SA~1\DSM_SA~1\cyrf6936.c
(0001) #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
(0002) #include "CYRF6936.h"
(0003) #include "delay.h"
(0004) #include "timer.h"
(0005) 
(0006) volatile BOOL CY_irq;
(0007) 
(0008) //called on a GPIO interrupt
(0009) #pragma interrupt_handler GPIO_ISR
(0010) void GPIO_ISR(void )
(0011) {
_GPIO_ISR:
    0A0B: 08       PUSH  A
    0A0C: 51 1D    MOV   A,[__r0]
    0A0E: 08       PUSH  A
(0012) 	/*if(PRT2DR&Port_2_4_MASK ) //Check if  pin went high
(0013) 	{
(0014) 		CY_irq=TRUE;
(0015) 	}*/
(0016) 	if (PRT0DR&IRQPin_MASK ) //Check if  pin went high
    0A0F: 5D 00    MOV   A,REG[0x0]
    0A11: 53 1D    MOV   [__r0],A
    0A13: 47 1D 40 TST   [__r0],0x40
    0A16: A0 04    JZ    0x0A1B
(0017) 	{
(0018) 		CY_irq=TRUE;
    0A18: 55 46 01 MOV   [CY_irq],0x1
(0019) 	}
    0A1B: 18       POP   A
    0A1C: 53 1D    MOV   [__r0],A
    0A1E: 18       POP   A
    0A1F: 7E       RETI  
(0020) }
(0021) 
(0022) //initialize cyrf chip
(0023) void CYRF_Init(void )
(0024) {
_CYRF_Init:
  i                    --> X+0
    0A20: 10       PUSH  X
    0A21: 4F       MOV   X,SP
    0A22: 38 01    ADD   SP,0x1
(0025) 	BYTE i;
(0026) 	RST_Start();
    0A24: 10       PUSH  X
    0A25: 7C 04 EB LCALL _RST_Stop|_RST_Start|RST_Start|_RST_Off|RST_Stop|RST_Off
(0027) 	CS_PIN_Start();
    0A28: 7C 05 35 LCALL CS_PIN_Start|_CS_PIN_Off|CS_PIN_Stop|_CS_PIN_Stop|_CS_PIN_Start|CS_PIN_Off
(0028) 	SPIM_1_Start(SPIM_1_SPIM_MODE_0 | SPIM_1_SPIM_MSB_FIRST);
    0A2B: 50 00    MOV   A,0x0
    0A2D: 7C 04 89 LCALL _SPIM_1_EnableInt|_SPIM_1_Start|SPIM_1_Start|_SPIM_1_DisableInt
(0029) 	//manua inline
(0030) 	//CYRF_Reset();
(0031) 	//reset cyrf chip
(0032) 	//void CYRF_Reset(void)
(0033) 	{
(0034) 	    RS_HI();
    0A30: 7C 04 E7 LCALL _RST_On|_RX8_1_cReadChar|_RX8_1_iReadChar|RST_On
(0035) 		CS_HI();
    0A33: 7C 05 31 LCALL _CS_PIN_On
    0A36: 20       POP   X
(0036) 	    Timer_Wait_ms(10);
    0A37: 50 0A    MOV   A,0xA
    0A39: 08       PUSH  A
    0A3A: 7C 1B FF LCALL _Timer_Wait_ms
    0A3D: 38 FF    ADD   SP,0xFF
(0037) 	    RS_LO();
    0A3F: 10       PUSH  X
    0A40: 7C 04 EB LCALL _RST_Stop|_RST_Start|RST_Start|_RST_Off|RST_Stop|RST_Off
    0A43: 20       POP   X
(0038) 	    Timer_Wait_ms(100);
    0A44: 50 64    MOV   A,0x64
    0A46: 08       PUSH  A
    0A47: 7C 1B FF LCALL _Timer_Wait_ms
(0039) 	}
(0040)     i = 100;
    0A4A: 56 00 64 MOV   [X+0],0x64
(0041)     CYRF_WriteRegister(CYRF_XACT_CFG, (CYRF_ACK_TO_12x));
    0A4D: 50 02    MOV   A,0x2
    0A4F: 08       PUSH  A
    0A50: 50 0F    MOV   A,0xF
    0A52: 08       PUSH  A
    0A53: 90 13    CALL  _CYRF_WriteRegister
    0A55: 38 FD    ADD   SP,0xFD
(0042)     Delay50uTimes(100);
    0A57: 10       PUSH  X
    0A58: 50 64    MOV   A,0x64
    0A5A: 7C 0C 44 LCALL _Delay50uTimes
    0A5D: 20       POP   X
(0043) 	M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO); 
    0A5E: 43 E0 20 OR    REG[0xE0],0x20
(0044) 	CY_irq=FALSE;;
    0A61: 55 46 00 MOV   [CY_irq],0x0
    0A64: 38 FF    ADD   SP,0xFF
    0A66: 20       POP   X
    0A67: 7F       RET   
(0045) }
(0046) 
(0047) 
(0048) //write a singel register
(0049) void CYRF_WriteRegister(BYTE reg, BYTE val)
(0050) {
_CYRF_WriteRegister:
  val                  --> X-5
  reg                  --> X-4
    0A68: 10       PUSH  X
    0A69: 4F       MOV   X,SP
(0051) CYRF_WriteRegisterMultiD(reg,&val,1);
    0A6A: 50 01    MOV   A,0x1
    0A6C: 08       PUSH  A
    0A6D: 5A 1C    MOV   [__r1],X
    0A6F: 16 1C 05 SUB   [__r1],0x5
    0A72: 51 1D    MOV   A,[__r0]
    0A74: 08       PUSH  A
    0A75: 51 1C    MOV   A,[__r1]
    0A77: 08       PUSH  A
    0A78: 52 FC    MOV   A,[X-4]
    0A7A: 08       PUSH  A
    0A7B: 90 69    CALL  _CYRF_WriteRegisterMultiD
    0A7D: 38 FC    ADD   SP,0xFC
    0A7F: 20       POP   X
    0A80: 7F       RET   
(0052) }
(0053) 
(0054) 
(0055) //write a single register cnt times
(0056) void CYRF_WriteRegisterMulti(BYTE reg,BYTE const data[] , BYTE cnt)
(0057) {
_CYRF_WriteRegisterMulti:
  n                    --> X+0
  cnt                  --> X-7
  data                 --> X-6
  reg                  --> X-4
    0A81: 10       PUSH  X
    0A82: 4F       MOV   X,SP
    0A83: 38 01    ADD   SP,0x1
(0058) 	BYTE n;
(0059)     CS_LO();
    0A85: 10       PUSH  X
    0A86: 7C 05 35 LCALL CS_PIN_Start|_CS_PIN_Off|CS_PIN_Stop|_CS_PIN_Stop|_CS_PIN_Start|CS_PIN_Off
    0A89: 20       POP   X
(0060) 	//wait for buffer empty
(0061) 	while( ! (SPIM_1_bReadStatus() & SPIM_1_SPIM_TX_BUFFER_EMPTY ) );
    0A8A: 10       PUSH  X
    0A8B: 7C 04 94 LCALL _SPIM_1_bReadStatus|_bSPIM_1_ReadStatus|SPIM_1_bReadStatus|bSPIM_1_ReadStatus
    0A8E: 20       POP   X
    0A8F: 53 1D    MOV   [__r0],A
    0A91: 47 1D 10 TST   [__r0],0x10
    0A94: AF F5    JZ    0x0A8A
(0062) 	//write address
(0063) 	SPIM_1_SendTxData(CYRF_WRITE_BIT|reg);
    0A96: 52 FC    MOV   A,[X-4]
    0A98: 29 80    OR    A,0x80
    0A9A: 10       PUSH  X
    0A9B: 7C 04 8E LCALL _SPIM_1_SendTxData|_SPIM_1_Stop|SPIM_1_SendTxData
    0A9E: 20       POP   X
(0064)     for(n = 0; n < cnt; n++)
    0A9F: 56 00 00 MOV   [X+0],0x0
    0AA2: 80 28    JMP   0x0ACB
(0065)     {
(0066) 		//wait for buffer empty
(0067) 		while( ! (SPIM_1_bReadStatus() & SPIM_1_SPIM_TX_BUFFER_EMPTY ) );
    0AA4: 10       PUSH  X
    0AA5: 7C 04 94 LCALL _SPIM_1_bReadStatus|_bSPIM_1_ReadStatus|SPIM_1_bReadStatus|bSPIM_1_ReadStatus
    0AA8: 20       POP   X
    0AA9: 53 1D    MOV   [__r0],A
    0AAB: 47 1D 10 TST   [__r0],0x10
    0AAE: AF F5    JZ    0x0AA4
(0068) 	    //write data
(0069) 		SPIM_1_SendTxData(data[n]);
    0AB0: 52 00    MOV   A,[X+0]
    0AB2: 53 1C    MOV   [__r1],A
    0AB4: 55 1D 00 MOV   [__r0],0x0
    0AB7: 52 FB    MOV   A,[X-5]
    0AB9: 04 1C    ADD   [__r1],A
    0ABB: 52 FA    MOV   A,[X-6]
    0ABD: 0C 1D    ADC   [__r0],A
    0ABF: 51 1D    MOV   A,[__r0]
    0AC1: 10       PUSH  X
    0AC2: 58 1C    MOV   X,[__r1]
    0AC4: 28       ROMX  
    0AC5: 7C 04 8E LCALL _SPIM_1_SendTxData|_SPIM_1_Stop|SPIM_1_SendTxData
    0AC8: 20       POP   X
(0070)     }
    0AC9: 77 00    INC   [X+0]
    0ACB: 52 00    MOV   A,[X+0]
    0ACD: 3B F9    CMP   A,[X-7]
    0ACF: CF D4    JC    0x0AA4
(0071) 	while( ! (SPIM_1_bReadStatus() & SPIM_1_SPIM_SPI_COMPLETE ) );
    0AD1: 10       PUSH  X
    0AD2: 7C 04 94 LCALL _SPIM_1_bReadStatus|_bSPIM_1_ReadStatus|SPIM_1_bReadStatus|bSPIM_1_ReadStatus
    0AD5: 20       POP   X
    0AD6: 53 1D    MOV   [__r0],A
    0AD8: 47 1D 20 TST   [__r0],0x20
    0ADB: AF F5    JZ    0x0AD1
(0072) 	CS_HI();
    0ADD: 10       PUSH  X
    0ADE: 7C 05 31 LCALL _CS_PIN_On
    0AE1: 20       POP   X
    0AE2: 38 FF    ADD   SP,0xFF
    0AE4: 20       POP   X
    0AE5: 7F       RET   
(0073) }
(0074) void CYRF_WriteRegisterMultiD(BYTE reg, BYTE data[], BYTE cnt)
(0075) {
_CYRF_WriteRegisterMultiD:
  n                    --> X+0
  cnt                  --> X-7
  data                 --> X-6
  reg                  --> X-4
    0AE6: 10       PUSH  X
    0AE7: 4F       MOV   X,SP
    0AE8: 38 01    ADD   SP,0x1
(0076) 	BYTE n;
(0077)     CS_LO();
    0AEA: 10       PUSH  X
    0AEB: 7C 05 35 LCALL CS_PIN_Start|_CS_PIN_Off|CS_PIN_Stop|_CS_PIN_Stop|_CS_PIN_Start|CS_PIN_Off
    0AEE: 20       POP   X
(0078) 	//wait for buffer empty
(0079) 	while( ! (SPIM_1_bReadStatus() & SPIM_1_SPIM_TX_BUFFER_EMPTY ) );
    0AEF: 10       PUSH  X
    0AF0: 7C 04 94 LCALL _SPIM_1_bReadStatus|_bSPIM_1_ReadStatus|SPIM_1_bReadStatus|bSPIM_1_ReadStatus
    0AF3: 20       POP   X
    0AF4: 53 1D    MOV   [__r0],A
    0AF6: 47 1D 10 TST   [__r0],0x10
    0AF9: AF F5    JZ    0x0AEF
(0080) 	//write address
(0081) 	SPIM_1_SendTxData(CYRF_WRITE_BIT|reg);
    0AFB: 52 FC    MOV   A,[X-4]
    0AFD: 29 80    OR    A,0x80
    0AFF: 10       PUSH  X
    0B00: 7C 04 8E LCALL _SPIM_1_SendTxData|_SPIM_1_Stop|SPIM_1_SendTxData
    0B03: 20       POP   X
(0082)     for(n = 0; n < cnt; n++)
    0B04: 56 00 00 MOV   [X+0],0x0
    0B07: 80 1E    JMP   0x0B26
(0083)     {
(0084) 		//wait for buffer empty
(0085) 		while( ! (SPIM_1_bReadStatus() & SPIM_1_SPIM_TX_BUFFER_EMPTY ) );
    0B09: 10       PUSH  X
    0B0A: 7C 04 94 LCALL _SPIM_1_bReadStatus|_bSPIM_1_ReadStatus|SPIM_1_bReadStatus|bSPIM_1_ReadStatus
    0B0D: 20       POP   X
    0B0E: 53 1D    MOV   [__r0],A
    0B10: 47 1D 10 TST   [__r0],0x10
    0B13: AF F5    JZ    0x0B09
(0086) 	    //write data
(0087) 		SPIM_1_SendTxData(data[n]);
    0B15: 52 00    MOV   A,[X+0]
    0B17: 53 1C    MOV   [__r1],A
    0B19: 52 FB    MOV   A,[X-5]
    0B1B: 04 1C    ADD   [__r1],A
    0B1D: 3E 1C    MVI   A,[__r1]
    0B1F: 10       PUSH  X
    0B20: 7C 04 8E LCALL _SPIM_1_SendTxData|_SPIM_1_Stop|SPIM_1_SendTxData
    0B23: 20       POP   X
(0088)     }
    0B24: 77 00    INC   [X+0]
    0B26: 52 00    MOV   A,[X+0]
    0B28: 3B F9    CMP   A,[X-7]
    0B2A: CF DE    JC    0x0B09
(0089) 	while( ! (SPIM_1_bReadStatus() & SPIM_1_SPIM_SPI_COMPLETE ) );
    0B2C: 10       PUSH  X
    0B2D: 7C 04 94 LCALL _SPIM_1_bReadStatus|_bSPIM_1_ReadStatus|SPIM_1_bReadStatus|bSPIM_1_ReadStatus
    0B30: 20       POP   X
    0B31: 53 1D    MOV   [__r0],A
    0B33: 47 1D 20 TST   [__r0],0x20
    0B36: AF F5    JZ    0x0B2C
(0090) 	CS_HI();
    0B38: 10       PUSH  X
    0B39: 7C 05 31 LCALL _CS_PIN_On
    0B3C: 20       POP   X
    0B3D: 38 FF    ADD   SP,0xFF
    0B3F: 20       POP   X
    0B40: 7F       RET   
(0091) }
(0092) 
(0093) 
(0094) void CYRF_WriteRegisterInc(BYTE reg,BYTE  data[] , BYTE cnt)
(0095) {
_CYRF_WriteRegisterInc:
  cnt                  --> X-7
  data                 --> X-6
  reg                  --> X-4
    0B41: 10       PUSH  X
    0B42: 4F       MOV   X,SP
(0096) CYRF_WriteRegisterMultiD(CYRF_INCR_BIT| reg,data,cnt);
    0B43: 52 F9    MOV   A,[X-7]
    0B45: 08       PUSH  A
    0B46: 52 FA    MOV   A,[X-6]
    0B48: 08       PUSH  A
    0B49: 52 FB    MOV   A,[X-5]
    0B4B: 08       PUSH  A
    0B4C: 52 FC    MOV   A,[X-4]
    0B4E: 29 40    OR    A,0x40
    0B50: 08       PUSH  A
    0B51: 9F 93    CALL  _CYRF_WriteRegisterMultiD
    0B53: 38 FC    ADD   SP,0xFC
    0B55: 20       POP   X
    0B56: 7F       RET   
(0097) }
(0098) 
(0099) //read a singele register 
(0100) BYTE CYRF_ReadRegister(BYTE reg)
(0101) {
_CYRF_ReadRegister:
  data                 --> X+0
  reg                  --> X-4
    0B57: 10       PUSH  X
    0B58: 4F       MOV   X,SP
    0B59: 38 01    ADD   SP,0x1
(0102) BYTE data;
(0103) 	CYRF_ReadRegisterMulti(reg,&data,1);
    0B5B: 50 01    MOV   A,0x1
    0B5D: 08       PUSH  A
    0B5E: 51 1D    MOV   A,[__r0]
    0B60: 08       PUSH  A
    0B61: 10       PUSH  X
    0B62: 52 FC    MOV   A,[X-4]
    0B64: 08       PUSH  A
    0B65: 90 08    CALL  _CYRF_ReadRegisterMulti
    0B67: 38 FC    ADD   SP,0xFC
(0104) 	return data;
    0B69: 52 00    MOV   A,[X+0]
    0B6B: 38 FF    ADD   SP,0xFF
    0B6D: 20       POP   X
    0B6E: 7F       RET   
(0105) }
(0106) 
(0107) //read a singel register cnt times
(0108) void CYRF_ReadRegisterMulti(BYTE reg, BYTE data[], BYTE cnt)
(0109) {
_CYRF_ReadRegisterMulti:
  n                    --> X+1
  status               --> X+0
  cnt                  --> X-7
  data                 --> X-6
  reg                  --> X-4
    0B6F: 10       PUSH  X
    0B70: 4F       MOV   X,SP
    0B71: 38 02    ADD   SP,0x2
(0110) 	BYTE n;
(0111) 	BYTE status;
(0112)     CS_LO();
    0B73: 10       PUSH  X
    0B74: 7C 05 35 LCALL CS_PIN_Start|_CS_PIN_Off|CS_PIN_Stop|_CS_PIN_Stop|_CS_PIN_Start|CS_PIN_Off
    0B77: 20       POP   X
(0113) 	//wait for buffer empty
(0114) 	while( ! (SPIM_1_bReadStatus() & SPIM_1_SPIM_TX_BUFFER_EMPTY ) );
    0B78: 10       PUSH  X
    0B79: 7C 04 94 LCALL _SPIM_1_bReadStatus|_bSPIM_1_ReadStatus|SPIM_1_bReadStatus|bSPIM_1_ReadStatus
    0B7C: 20       POP   X
    0B7D: 53 1D    MOV   [__r0],A
    0B7F: 47 1D 10 TST   [__r0],0x10
    0B82: AF F5    JZ    0x0B78
(0115) 	//write address
(0116) 	SPIM_1_SendTxData(reg);
    0B84: 10       PUSH  X
    0B85: 52 FC    MOV   A,[X-4]
    0B87: 7C 04 8E LCALL _SPIM_1_SendTxData|_SPIM_1_Stop|SPIM_1_SendTxData
    0B8A: 20       POP   X
(0117) 	//wait for buffer empty
(0118) 	while( ! (status=SPIM_1_bReadStatus() & SPIM_1_SPIM_TX_BUFFER_EMPTY ) );
    0B8B: 10       PUSH  X
    0B8C: 7C 04 94 LCALL _SPIM_1_bReadStatus|_bSPIM_1_ReadStatus|SPIM_1_bReadStatus|bSPIM_1_ReadStatus
    0B8F: 20       POP   X
    0B90: 21 10    AND   A,0x10
    0B92: 54 00    MOV   [X+0],A
    0B94: 39 00    CMP   A,0x0
    0B96: AF F4    JZ    0x0B8B
(0119)     //dummy write
(0120) 	SPIM_1_SendTxData(0x00);
    0B98: 10       PUSH  X
    0B99: 50 00    MOV   A,0x0
    0B9B: 7C 04 8E LCALL _SPIM_1_SendTxData|_SPIM_1_Stop|SPIM_1_SendTxData
    0B9E: 20       POP   X
(0121) 	//wait for gabage byte read
(0122) 	while( ! (status=SPIM_1_bReadStatus() & SPIM_1_SPIM_RX_BUFFER_FULL ) );
    0B9F: 10       PUSH  X
    0BA0: 7C 04 94 LCALL _SPIM_1_bReadStatus|_bSPIM_1_ReadStatus|SPIM_1_bReadStatus|bSPIM_1_ReadStatus
    0BA3: 20       POP   X
    0BA4: 21 08    AND   A,0x8
    0BA6: 54 00    MOV   [X+0],A
    0BA8: 39 00    CMP   A,0x0
    0BAA: AF F4    JZ    0x0B9F
(0123) 	SPIM_1_bReadRxData();
    0BAC: 10       PUSH  X
    0BAD: 7C 04 91 LCALL _SPIM_1_bReadRxData|_bSPIM_1_ReadRxData|SPIM_1_bReadRxData|bSPIM_1_ReadRxData
    0BB0: 20       POP   X
(0124) 	
(0125)     
(0126)     for(n=0;(n<cnt);)
    0BB1: 56 01 00 MOV   [X+1],0x0
    0BB4: 80 2E    JMP   0x0BE3
(0127) 	{
(0128) 		//if buffer empty
(0129) 		status=SPIM_1_bReadStatus();
    0BB6: 10       PUSH  X
    0BB7: 7C 04 94 LCALL _SPIM_1_bReadStatus|_bSPIM_1_ReadStatus|SPIM_1_bReadStatus|bSPIM_1_ReadStatus
    0BBA: 20       POP   X
    0BBB: 54 00    MOV   [X+0],A
(0130) 		if(  (status & SPIM_1_SPIM_TX_BUFFER_EMPTY ) );
    0BBD: 48 00 10 TST   [X+0],0x10
    0BC0: A0 01    JZ    0x0BC2
(0131) 			{
(0132) 		    //dummy write
(0133) 			SPIM_1_SendTxData(0x00);
    0BC2: 10       PUSH  X
    0BC3: 50 00    MOV   A,0x0
    0BC5: 7C 04 8E LCALL _SPIM_1_SendTxData|_SPIM_1_Stop|SPIM_1_SendTxData
    0BC8: 20       POP   X
(0134) 			}
(0135) 		//if data		
(0136) 		if(  (status & SPIM_1_SPIM_RX_BUFFER_FULL ) );
    0BC9: 48 00 08 TST   [X+0],0x8
    0BCC: A0 01    JZ    0x0BCE
(0137) 		{
(0138) 			data[n]=SPIM_1_bReadRxData();
    0BCE: 10       PUSH  X
    0BCF: 7C 04 91 LCALL _SPIM_1_bReadRxData|_bSPIM_1_ReadRxData|SPIM_1_bReadRxData|bSPIM_1_ReadRxData
    0BD2: 20       POP   X
    0BD3: 53 1D    MOV   [__r0],A
    0BD5: 52 01    MOV   A,[X+1]
    0BD7: 53 1A    MOV   [__r3],A
    0BD9: 52 FB    MOV   A,[X-5]
    0BDB: 04 1A    ADD   [__r3],A
    0BDD: 51 1D    MOV   A,[__r0]
    0BDF: 3F 1A    MVI   [__r3],A
(0139) 			n++;
    0BE1: 77 01    INC   [X+1]
(0140) 		}
(0141)     };
    0BE3: 52 01    MOV   A,[X+1]
    0BE5: 3B F9    CMP   A,[X-7]
    0BE7: CF CE    JC    0x0BB6
(0142) 	CS_HI();
    0BE9: 10       PUSH  X
    0BEA: 7C 05 31 LCALL _CS_PIN_On
    0BED: 20       POP   X
    0BEE: 38 FE    ADD   SP,0xFE
    0BF0: 20       POP   X
    0BF1: 7F       RET   
(0143) }
(0144) void CYRF_ReadRegisterInc(BYTE reg, BYTE data[], BYTE cnt)
(0145) {
_CYRF_ReadRegisterInc:
  cnt                  --> X-7
  data                 --> X-6
  reg                  --> X-4
    0BF2: 10       PUSH  X
    0BF3: 4F       MOV   X,SP
(0146) 	CYRF_ReadRegisterMulti(reg|CYRF_INCR_BIT,data,cnt);
    0BF4: 52 F9    MOV   A,[X-7]
    0BF6: 08       PUSH  A
    0BF7: 52 FA    MOV   A,[X-6]
    0BF9: 08       PUSH  A
    0BFA: 52 FB    MOV   A,[X-5]
    0BFC: 08       PUSH  A
    0BFD: 52 FC    MOV   A,[X-4]
    0BFF: 29 40    OR    A,0x40
    0C01: 08       PUSH  A
    0C02: 9F 6B    CALL  _CYRF_ReadRegisterMulti
    0C04: 38 FC    ADD   SP,0xFC
    0C06: 20       POP   X
    0C07: 7F       RET   
(0147) }
(0148) 
(0149) 
(0150) //get Mfg ID
(0151) void CYRF_GetMfgData(BYTE data[])
(0152) {
_CYRF_GetMfgData:
  data                 --> X-5
    0C08: 10       PUSH  X
    0C09: 4F       MOV   X,SP
(0153)     /* Fuses power on */
(0154)     CYRF_WriteRegister(CYRF_MFG_ID, 0xFF);
    0C0A: 50 FF    MOV   A,0xFF
    0C0C: 08       PUSH  A
    0C0D: 50 25    MOV   A,0x25
    0C0F: 08       PUSH  A
    0C10: 9E 56    CALL  _CYRF_WriteRegister
    0C12: 38 FE    ADD   SP,0xFE
(0155) 
(0156)     CYRF_ReadRegisterMulti(CYRF_MFG_ID, data, 6);
    0C14: 50 06    MOV   A,0x6
    0C16: 08       PUSH  A
    0C17: 52 FB    MOV   A,[X-5]
    0C19: 08       PUSH  A
    0C1A: 52 FC    MOV   A,[X-4]
    0C1C: 08       PUSH  A
    0C1D: 50 25    MOV   A,0x25
    0C1F: 08       PUSH  A
    0C20: 9F 4D    CALL  _CYRF_ReadRegisterMulti
(0157) 
(0158)     /* Fuses power off */
(0159)     CYRF_WriteRegister(CYRF_MFG_ID, 0x00); 
    0C22: 50 00    MOV   A,0x0
    0C24: 08       PUSH  A
    0C25: 50 25    MOV   A,0x25
    0C27: 08       PUSH  A
    0C28: 9E 3E    CALL  _CYRF_WriteRegister
    0C2A: 38 FA    ADD   SP,0xFA
    0C2C: 20       POP   X
    0C2D: 7F       RET   
(0160) }
(0161) 
(0162) void CYRF_SetCRCSeed(WORD crc)
(0163) {
_CYRF_SetCRCSeed:
  crc                  --> X-5
    0C2E: 10       PUSH  X
    0C2F: 4F       MOV   X,SP
(0164)     CYRF_WriteRegister(CYRF_CRC_SEED_LSB,crc & 0xff);
    0C30: 52 FC    MOV   A,[X-4]
    0C32: 08       PUSH  A
    0C33: 50 15    MOV   A,0x15
    0C35: 08       PUSH  A
    0C36: 9E 30    CALL  _CYRF_WriteRegister
(0165)     CYRF_WriteRegister(CYRF_CRC_SEED_MSB,crc >> 8);
    0C38: 52 FB    MOV   A,[X-5]
    0C3A: 08       PUSH  A
    0C3B: 50 16    MOV   A,0x16
    0C3D: 08       PUSH  A
    0C3E: 9E 28    CALL  _CYRF_WriteRegister
    0C40: 38 FC    ADD   SP,0xFC
    0C42: 20       POP   X
    0C43: 7F       RET   
FILE: .\delay.asm                       (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: delay.asm
                                        (0004) ;;
                                        (0005) ;;  DESCRIPTION: Delay functions implementation file
                                        (0006) ;;
                                        (0007) ;;-----------------------------------------------------------------------------
                                        (0008) ;;  Copyright (c) Cypress MicroSystems 2002-2006. All Rights Reserved.
                                        (0009) ;;*****************************************************************************
                                        (0010) ;;*****************************************************************************
                                        (0011) 
                                        (0012) ;-----------------------------------------------------------------------------
                                        (0013) ;  Include Files
                                        (0014) ;-----------------------------------------------------------------------------
                                        (0015) include "m8c.inc"
                                        (0016) include "memory.inc"
                                        (0017) 
                                        (0018) ;-----------------------------------------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------------------------------------
                                        (0021) export  Delay50uTimes
                                        (0022) export _Delay50uTimes
                                        (0023) 
                                        (0024) export  Delay50u
                                        (0025) export _Delay50u
                                        (0026) 
                                        (0027) area text(rom)
                                        (0028) 
                                        (0029) 
                                        (0030) .SECTION
                                        (0031) ;-----------------------------------------------------------------------------
                                        (0032) ;  FUNCTION NAME: Delay50uTimes
                                        (0033) ;
                                        (0034) ;  DESCRIPTION:
                                        (0035) ;     Delay increments of 50uSeconds
                                        (0036) ;
                                        (0037) ;-----------------------------------------------------------------------------
                                        (0038) ;
                                        (0039) ;  ARGUMENTS:
                                        (0040) ;     A contains the delay multiplier
                                        (0041) ;
                                        (0042) ;  RETURNS:
                                        (0043) ;
                                        (0044) ;  SIDE EFFECTS:
                                        (0045) ;    The A and X registers may be modified by this or future implementations
                                        (0046) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0047) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0048) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0049) ;    functions.
                                        (0050) ;
                                        (0051) ;
                                        (0052) 
                                        (0053)  Delay50uTimes:
                                        (0054) _Delay50uTimes:
                                        (0055)     RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0056) 
0C44: 90 0C    CALL  _Delay50u          (0057)     call  Delay50u
0C46: 78       DEC   A                  (0058) 	dec A
0C47: BF FC    JNZ   _Delay50uTimes     (0059)     jnz   Delay50uTimes
                                        (0060) 
                                        (0061) 	
                                        (0062)     RAM_EPILOGUE RAM_USE_CLASS_1
0C49: 7F       RET                      (0063)     ret
                                        (0064) 
                                        (0065) .ENDSECTION
                                        (0066) 
                                        (0067) ;-----------------------------------------------------------------------------
                                        (0068) ;  FUNCTION NAME: Delay50u
                                        (0069) ;
                                        (0070) ;  DESCRIPTION:
                                        (0071) ;     Delay 50uSec for any clock frequency from 1.5MHz to 24MHz
                                        (0072) ;     Slower clock frequencies the delay will be;
                                        (0073) ;           1.5
                                        (0074) ;        -------------- * 50uSec
                                        (0075) ;        clock_freq(MHz)
                                        (0076) ;
                                        (0077) ;
                                        (0078) ;-----------------------------------------------------------------------------
                                        (0079) ;
                                        (0080) ;  ARGUMENTS: none
                                        (0081) ;
                                        (0082) ;  RETURNS: none
                                        (0083) ;
                                        (0084) ;  SIDE EFFECTS:
                                        (0085) ;    The A and X registers may be modified by this or future implementations
                                        (0086) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0087) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0088) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0089) ;    functions.
                                        (0090) ;
                                        (0091) ;  THEORY of OPERATION or PROCEDURE:
                                        (0092) ;
                                        (0093) .LITERAL
                                        (0094)  Delay50u_Table::
                                        (0095)      DB    08h,  19h,   3Ah,   7Ch,   01h,    01h,    01h,   01h
                                        (0096) ;         3MHz, 6MHz, 12MHz, 24MHz, 1.5MHz, 750kHz, 188kHz, 94kHz
                                        (0097) .ENDLITERAL
                                        (0098) .SECTION
                                        (0099) 
                                        (0100)   Delay50u:
                                        (0101)  _Delay50u:                      ; [11]  Call
                                        (0102)     RAM_PROLOGUE RAM_USE_CLASS_1
0C52: 08       PUSH  A                  (0103)     push  A
0C53: 71 10    OR    F,0x10             
                                        (0104)     M8C_SetBank1                       ; [4]
0C55: 5D E0    MOV   A,REG[0xE0]        (0105)     mov   A, reg[OSC_CR0]              ; [6] Get delay value
0C57: 70 EF    AND   F,0xEF             
                                        (0106)     M8C_SetBank0                       ; [4]
0C59: 21 07    AND   A,0x7              (0107)     and   A,07h                        ; [4] Mask off only the clock bits
0C5B: 39 05    CMP   A,0x5              (0108)     cmp   A,05h
0C5D: D0 06    JNC   0x0C64             (0109)     jnc   Delay50u_End
0C5F: FF E9    INDEX Delay50u_Table     (0110)     index Delay50u_Table               ; [13] Get delay value
                                        (0111) Delay50u_Loop:                         ;
0C61: 78       DEC   A                  (0112)     dec   A                            ; [4]
0C62: BF FE    JNZ   0x0C61             (0113)     jnz   Delay50u_Loop                ; [5]
                                        (0114) Delay50u_End:
0C64: 18       POP   A                  (0115)     pop   A
                                        (0116)     RAM_EPILOGUE RAM_USE_CLASS_1
0C65: 7F       RET                      (0117)     ret
FILE: C:\Users\Ralf\DOCUME~1\DSM_SA~1\DSM_SA~1\DSM_SA~1\dsm.c
(0001) #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
(0002) #include "dsm.h"
(0003) #include "serial.h"
(0004) #include "timer.h"
(0005) 
(0006) extern BYTE ModellNr;
(0007) 
(0008) 
(0009) //share memory with flash buffer
(0010) extern RAM_D mem;
(0011) #define tx_buf mem.b.buf0
(0012) //BYTE tx_buf[16];	//transmit buffer
(0013) #define bind_buf mem.b.buf0
(0014) //BYTE bind_buf[16];	//transmit buffer
(0015) #define rx_buf mem.b.buf1
(0016) //BYTE rx_buf[16];	//recive buffer
(0017) 
(0018) //config data
(0019) BOOL DSM_Is_DSMX;		//true for DSMX false for DSM2
(0020) BOOL DSM_Is_11ms;		//true for 11ms update
(0021) BOOL DSM_Is_11Bit;		//true for 11bit resolution
(0022) 
(0023) //global data
(0024) BYTE channels[23]; 	//list of channels
(0025) BYTE chidx;			//current channel index	
(0026) BOOL DSM_Is_Forced;		//if true ignore reciver response
(0027) BOOL RX_Response;	//true if we got a response from reciver
(0028) BOOL Ch_A;			//true for channel A false for channel B
(0029) BYTE dsm_Max_pos;	
(0030) BYTE sop_col;		
(0031) BYTE data_col;		
(0032) BYTE Bind_cnt;		//bind pulse counter
(0033) BYTE State;			
(0034) BYTE bind_channal;	//channel used to send bind packes
(0035) BYTE num_channels;	//number fo transmit channels
(0036) BYTE cyrfmfg_id[6];	//manufacturer ID of cyrf6936
(0037) //BYTE cyrfmfg_id[6]={0x67,0x3B,0x16,0xCC,0xD8,0xFF};	//Does Work
(0038) //BYTE cyrfmfg_id[6]={0x76,0x65,0x3B,0x0F,0x5D,0xFC}; //Does Not Work
(0039) //BYTE cyrfmfg_id[6]={0x67,0x65,0x3B,0x0F,0x5D,0xFC}; //Test OK n
(0040) //BYTE cyrfmfg_id[6]={0x76,0x3B,0x3B,0x0F,0x5D,0xFC}; //Test OK
(0041) //BYTE cyrfmfg_id[6]={0x76,0x65,0x16,0x0F,0x5D,0xFC}; //Test OK
(0042) BYTE cyrfmfg_id[6]={0x76,0x65,0x3B,0xCC,0x5D,0xFC}; ///Test OK
(0043) BYTE tx_cfg;		//xmit power precomputed
(0044) WORD DSM_Perriode;		//cycle time - 4000
(0045) BOOL DSM_ready_for_Serial; //true if we are ready for the next serial package
(0046) int Last_Phase_error;
(0047) 
(0048) 
(0049) static const BYTE pn_bind[] = {0x98, 0x88, 0x1B, 0xE4, 0x30, 0x79, 0x03, 0x84}; //used for reciving bind response
(0050) static const BYTE pn_check[] = {0xc6,0x94,0x22,0xfe,0x48,0xe6,0x57,0x4e };		//used for scanning channel RSSI (found on spi capture of LPDSM)
(0051) 
(0052) static const BYTE pncodes[5][9][8] = {
(0053)     /* Note these are in order transmitted (LSB 1st) */
(0054) { /* Row 0 */
(0055)   /* Col 0 */ {0x03, 0xBC, 0x6E, 0x8A, 0xEF, 0xBD, 0xFE, 0xF8},
(0056)   /* Col 1 */ {0x88, 0x17, 0x13, 0x3B, 0x2D, 0xBF, 0x06, 0xD6},
(0057)   /* Col 2 */ {0xF1, 0x94, 0x30, 0x21, 0xA1, 0x1C, 0x88, 0xA9},
(0058)   /* Col 3 */ {0xD0, 0xD2, 0x8E, 0xBC, 0x82, 0x2F, 0xE3, 0xB4},
(0059)   /* Col 4 */ {0x8C, 0xFA, 0x47, 0x9B, 0x83, 0xA5, 0x66, 0xD0},
(0060)   /* Col 5 */ {0x07, 0xBD, 0x9F, 0x26, 0xC8, 0x31, 0x0F, 0xB8},
(0061)   /* Col 6 */ {0xEF, 0x03, 0x95, 0x89, 0xB4, 0x71, 0x61, 0x9D},
(0062)   /* Col 7 */ {0x40, 0xBA, 0x97, 0xD5, 0x86, 0x4F, 0xCC, 0xD1},
(0063)   /* Col 8 */ {0xD7, 0xA1, 0x54, 0xB1, 0x5E, 0x89, 0xAE, 0x86}
(0064) },
(0065) { /* Row 1 */
(0066)   /* Col 0 */ {0x83, 0xF7, 0xA8, 0x2D, 0x7A, 0x44, 0x64, 0xD3},
(0067)   /* Col 1 */ {0x3F, 0x2C, 0x4E, 0xAA, 0x71, 0x48, 0x7A, 0xC9},
(0068)   /* Col 2 */ {0x17, 0xFF, 0x9E, 0x21, 0x36, 0x90, 0xC7, 0x82},
(0069)   /* Col 3 */ {0xBC, 0x5D, 0x9A, 0x5B, 0xEE, 0x7F, 0x42, 0xEB},
(0070)   /* Col 4 */ {0x24, 0xF5, 0xDD, 0xF8, 0x7A, 0x77, 0x74, 0xE7},
(0071)   /* Col 5 */ {0x3D, 0x70, 0x7C, 0x94, 0xDC, 0x84, 0xAD, 0x95},
(0072)   /* Col 6 */ {0x1E, 0x6A, 0xF0, 0x37, 0x52, 0x7B, 0x11, 0xD4},
(0073)   /* Col 7 */ {0x62, 0xF5, 0x2B, 0xAA, 0xFC, 0x33, 0xBF, 0xAF},
(0074)   /* Col 8 */ {0x40, 0x56, 0x32, 0xD9, 0x0F, 0xD9, 0x5D, 0x97}
(0075) },
(0076) { /* Row 2 */
(0077)   /* Col 0 */ {0x40, 0x56, 0x32, 0xD9, 0x0F, 0xD9, 0x5D, 0x97},
(0078)   /* Col 1 */ {0x8E, 0x4A, 0xD0, 0xA9, 0xA7, 0xFF, 0x20, 0xCA},
(0079)   /* Col 2 */ {0x4C, 0x97, 0x9D, 0xBF, 0xB8, 0x3D, 0xB5, 0xBE},
(0080)   /* Col 3 */ {0x0C, 0x5D, 0x24, 0x30, 0x9F, 0xCA, 0x6D, 0xBD},
(0081)   /* Col 4 */ {0x50, 0x14, 0x33, 0xDE, 0xF1, 0x78, 0x95, 0xAD},
(0082)   /* Col 5 */ {0x0C, 0x3C, 0xFA, 0xF9, 0xF0, 0xF2, 0x10, 0xC9},
(0083)   /* Col 6 */ {0xF4, 0xDA, 0x06, 0xDB, 0xBF, 0x4E, 0x6F, 0xB3},
(0084)   /* Col 7 */ {0x9E, 0x08, 0xD1, 0xAE, 0x59, 0x5E, 0xE8, 0xF0},
(0085)   /* Col 8 */ {0xC0, 0x90, 0x8F, 0xBB, 0x7C, 0x8E, 0x2B, 0x8E}
(0086) },
(0087) { /* Row 3 */
(0088)   /* Col 0 */ {0xC0, 0x90, 0x8F, 0xBB, 0x7C, 0x8E, 0x2B, 0x8E},
(0089)   /* Col 1 */ {0x80, 0x69, 0x26, 0x80, 0x08, 0xF8, 0x49, 0xE7},
(0090)   /* Col 2 */ {0x7D, 0x2D, 0x49, 0x54, 0xD0, 0x80, 0x40, 0xC1},
(0091)   /* Col 3 */ {0xB6, 0xF2, 0xE6, 0x1B, 0x80, 0x5A, 0x36, 0xB4},
(0092)   /* Col 4 */ {0x42, 0xAE, 0x9C, 0x1C, 0xDA, 0x67, 0x05, 0xF6},
(0093)   /* Col 5 */ {0x9B, 0x75, 0xF7, 0xE0, 0x14, 0x8D, 0xB5, 0x80},
(0094)   /* Col 6 */ {0xBF, 0x54, 0x98, 0xB9, 0xB7, 0x30, 0x5A, 0x88},
(0095)   /* Col 7 */ {0x35, 0xD1, 0xFC, 0x97, 0x23, 0xD4, 0xC9, 0x88},
(0096)   /* Col 8 */ {0x88, 0xE1, 0xD6, 0x31, 0x26, 0x5F, 0xBD, 0x40}
(0097) },
(0098) { /* Row 4 */
(0099)   /* Col 0 */ {0xE1, 0xD6, 0x31, 0x26, 0x5F, 0xBD, 0x40, 0x93},
(0100)   /* Col 1 */ {0xDC, 0x68, 0x08, 0x99, 0x97, 0xAE, 0xAF, 0x8C},
(0101)   /* Col 2 */ {0xC3, 0x0E, 0x01, 0x16, 0x0E, 0x32, 0x06, 0xBA},
(0102)   /* Col 3 */ {0xE0, 0x83, 0x01, 0xFA, 0xAB, 0x3E, 0x8F, 0xAC},
(0103)   /* Col 4 */ {0x5C, 0xD5, 0x9C, 0xB8, 0x46, 0x9C, 0x7D, 0x84},
(0104)   /* Col 5 */ {0xF1, 0xC6, 0xFE, 0x5C, 0x9D, 0xA5, 0x4F, 0xB7},
(0105)   /* Col 6 */ {0x58, 0xB5, 0xB3, 0xDD, 0x0E, 0x28, 0xF1, 0xB0},
(0106)   /* Col 7 */ {0x5F, 0x30, 0x3B, 0x56, 0x96, 0x45, 0xF4, 0xA1},
(0107)   /* Col 8 */ {0x03, 0xBC, 0x6E, 0x8A, 0xEF, 0xBD, 0xFE, 0xF8}
(0108) },};
(0109) 
(0110) 
(0111) static const BYTE init_vals[][2] = {
(0112) //	{CYRF_MODE_OVERRIDE, 0x01},
(0113)     {CYRF_CLK_EN, CLK_EN_RXF},  //0x02
(0114)     {CYRF_AUTO_CAL_TIME, 0x3c}, //see cyrf manual
(0115)     {CYRF_AUTO_CAL_OFFSET, 0x14}, //see cyrf manual
(0116) 	{CYRF_IO_CFG,IO_CFG_IRQ_POL}, //0x40 IRQ active High 
(0117)     {CYRF_RX_CFG, RX_LNA|FAST_TURN_EN}, //0x48 Fast Turn Mode Enable, Low Noise Amplifier ON
(0118)     {CYRF_TX_OFFSET_LSB, 0x55},//see cyrf manual
(0119)     {CYRF_TX_OFFSET_MSB, 0x05},//see cyrf manual
(0120)     {CYRF_XACT_CFG,CYRF_XACT_END_STATE(CYRF_MODE_IDLE)|CYRF_FRC_END}, //0x24 Force  Idle Mode
(0121)     //{CYRF_TX_CFG,TX_DM(TX_DM_SDR)|TX_DC_LEN}, //0x38 SDR Mode  64 chip
(0122)     {CYRF_DATA64_THOLD, 0x0a},//see cyrf manual
(0123)     {CYRF_XACT_CFG,CYRF_XACT_END_STATE(CYRF_MODE_IDLE)}, //0x04 Transaction End State Idle Mode
(0124)     //{CYRF_XTAL_CTRL,0x80},
(0125) 	{CYRF_ANALOG_CTRL, ALL_SLOW}, //0x01 all slow
(0126)     {CYRF_XACT_CFG,CYRF_XACT_END_STATE(CYRF_MODE_IDLE)| CYRF_FRC_END}, //0x24 Force IDLE
(0127) 	{CYRF_RX_ABORT, 0x00}, //Clear RX abort
(0128)     {CYRF_DATA64_THOLD, 0x0a}, //set pn correlation threshold
(0129)     {CYRF_FRAMING_CFG, SOP_LEN|0xa}, //set sop len and threshold
(0130)     {CYRF_RX_ABORT, 0x0f}, //Clear RX abort?
(0131) };
(0132) 
(0133) static const BYTE Transmit_vals[][2] = {
(0134)     //{CYRF_TX_CFG,TX_DM(TX_DM_8DR)|TX_PA_P4DBM}, //0x0F 8DR Mode  +4 dBm 32 chip codes
(0135) 	{CYRF_FRAMING_CFG,LEN_EN|SOP_LEN|SOP_EN|0xA},  //0xEA SOP Enable SOP code length is 64 chips Packet Length Enable  SOP Correlator Threshold=0xA
(0136)     {CYRF_TX_OVERRIDE, 0x00},
(0137)     {CYRF_RX_OVERRIDE, 0x00},
(0138) };
(0139) 
(0140) static const BYTE bind_vals[][2] = {
(0141)     {CYRF_TX_CFG,TX_DC_LEN|TX_DM(TX_DM_SDR)|DSM_BIND_POWER}, //0x38 Set 64 chip, SDR mode
(0142)     {CYRF_FRAMING_CFG,SOP_LEN|0xA}, //0x4A set sop len  32 chip and threshold =0xA 
(0143)     {CYRF_TX_OVERRIDE, DIS_TXCRC}, //0x4 disable tx CRC
(0144)     {CYRF_RX_OVERRIDE, DIS_RXCRC}, //0x4 disable rx CRC
(0145)     {CYRF_EOP_CTRL, 0x02}, //set EOP sync == 2
(0146) };
(0147) 
(0148) 
(0149) static const BYTE preamble[]={0x04,0x33,0x33};
(0150) static  BYTE tx_cmd[]={0x10,TXE_IRQEN|TXC_IRQEN|TX_GO|TX_CLR}; //0xC3
(0151) 
(0152) #define TX_CFG (TX_DM(TX_DM_8DR)|TX_DC_LEN) //0x28 DDR Mode  64 chip codes
(0153) 
(0154) void DSM_SetRangeCheck(BOOL val)
(0155) {
_DSM_SetRangeCheck:
  val                  --> X-4
    0C66: 10       PUSH  X
    0C67: 4F       MOV   X,SP
    0C68: 38 02    ADD   SP,0x2
(0156) 	tx_cfg=val?TX_CFG|DSM_RANGE_CHECK_POWER:TX_CFG|DSM_TX_POWER;	
    0C6A: 3D FC 00 CMP   [X-4],0x0
    0C6D: A0 09    JZ    0x0C77
    0C6F: 56 01 2B MOV   [X+1],0x2B
    0C72: 56 00 00 MOV   [X+0],0x0
    0C75: 80 07    JMP   0x0C7D
    0C77: 56 01 2F MOV   [X+1],0x2F
    0C7A: 56 00 00 MOV   [X+0],0x0
    0C7D: 52 01    MOV   A,[X+1]
    0C7F: 53 4A    MOV   [tx_cfg],A
    0C81: 38 FE    ADD   SP,0xFE
    0C83: 20       POP   X
    0C84: 7F       RET   
(0157) }
(0158) 
(0159) //set time till periode
(0160) void SetTimer(void)
(0161) {
(0162) 	if(Ch_A)
_SetTimer:
    0C85: 3C 4F 00 CMP   [Ch_A],0x0
    0C88: A0 0F    JZ    0x0C98
(0163) 	{
(0164) 		//if CH_A is on, CH_B has been send out, 
(0165) 		//from now till CH_A transmit is the windows where the serial data must come in  
(0166) 		DSM_ready_for_Serial=TRUE;
    0C8A: 55 6C 01 MOV   [DSM_ready_for_Serial],0x1
(0167) 		//DSM_Data_To_send=FALSE;
(0168) 		Timer_SetPeriod(DSM_TIME_CHA_CHB);
    0C8D: 10       PUSH  X
    0C8E: 57 0F    MOV   X,0xF
    0C90: 50 A0    MOV   A,0xA0
    0C92: 7C 05 58 LCALL _Counter16_1_WritePeriod
    0C95: 20       POP   X
(0169) 	}
    0C96: 80 0A    JMP   0x0CA1
(0170) 	else
(0171) 	{
(0172) 		Timer_SetPeriod(DSM_Perriode);
    0C98: 10       PUSH  X
    0C99: 58 6A    MOV   X,[DSM_Perriode]
    0C9B: 51 6B    MOV   A,[DSM_Perriode+1]
    0C9D: 7C 05 58 LCALL _Counter16_1_WritePeriod
    0CA0: 20       POP   X
(0173) 	}
    0CA1: 7F       RET   
(0174) }
(0175) 
(0176) //calculate and set channel CRC , SOP and data code 
(0177) void SetCH_CRC_SOP_DATA(void)
(0178) {
_SetCH_CRC_SOP_DATA:
  CRCSeed              --> X+2
  pn_row               --> X+1
  channel              --> X+0
    0CA2: 10       PUSH  X
    0CA3: 4F       MOV   X,SP
    0CA4: 38 08    ADD   SP,0x8
(0179) 	BYTE channel=channels[chidx];
    0CA6: 5F 1C 51 MOV   [__r1],[chidx]
    0CA9: 06 1C 52 ADD   [__r1],0x52
    0CAC: 3E 1C    MVI   A,[__r1]
    0CAE: 54 00    MOV   [X+0],A
(0180) 	BYTE pn_row = DSM_Is_DSMX ? (channel - 2)%5 : channel%5;
    0CB0: 3C 70 00 CMP   [DSM_Is_DSMX],0x0
    0CB3: A0 27    JZ    0x0CDB
    0CB5: 52 00    MOV   A,[X+0]
    0CB7: 53 1C    MOV   [__r1],A
    0CB9: 55 1D 00 MOV   [__r0],0x0
    0CBC: 16 1C 02 SUB   [__r1],0x2
    0CBF: 1E 1D 00 SBB   [__r0],0x0
    0CC2: 50 00    MOV   A,0x0
    0CC4: 08       PUSH  A
    0CC5: 50 05    MOV   A,0x5
    0CC7: 08       PUSH  A
    0CC8: 51 1D    MOV   A,[__r0]
    0CCA: 08       PUSH  A
    0CCB: 51 1C    MOV   A,[__r1]
    0CCD: 08       PUSH  A
    0CCE: 7C 1D 71 LCALL 0x1D71
    0CD1: 38 FE    ADD   SP,0xFE
    0CD3: 18       POP   A
    0CD4: 54 05    MOV   [X+5],A
    0CD6: 18       POP   A
    0CD7: 54 04    MOV   [X+4],A
    0CD9: 80 1C    JMP   0x0CF6
    0CDB: 52 00    MOV   A,[X+0]
    0CDD: 53 1C    MOV   [__r1],A
    0CDF: 50 00    MOV   A,0x0
    0CE1: 08       PUSH  A
    0CE2: 50 05    MOV   A,0x5
    0CE4: 08       PUSH  A
    0CE5: 50 00    MOV   A,0x0
    0CE7: 08       PUSH  A
    0CE8: 51 1C    MOV   A,[__r1]
    0CEA: 08       PUSH  A
    0CEB: 7C 1D 71 LCALL 0x1D71
    0CEE: 38 FE    ADD   SP,0xFE
    0CF0: 18       POP   A
    0CF1: 54 05    MOV   [X+5],A
    0CF3: 18       POP   A
    0CF4: 54 04    MOV   [X+4],A
    0CF6: 52 05    MOV   A,[X+5]
    0CF8: 54 01    MOV   [X+1],A
(0181) 	WORD CRCSeed=Ch_A?~((WORD)(cyrfmfg_id[0] << 8) + (WORD)cyrfmfg_id[1]):((WORD)(cyrfmfg_id[0] << 8) + (WORD)cyrfmfg_id[1]);
    0CFA: 3C 4F 00 CMP   [Ch_A],0x0
    0CFD: A0 18    JZ    0x0D16
    0CFF: 7C 1F 1F LCALL 0x1F1F
    0D02: 53 1C    MOV   [__r1],A
    0D04: 51 1B    MOV   A,[__r2]
    0D06: 0A 1D    ADC   A,[__r0]
    0D08: 53 1D    MOV   [__r0],A
    0D0A: 51 1C    MOV   A,[__r1]
    0D0C: 73       CPL   A
    0D0D: 54 07    MOV   [X+7],A
    0D0F: 51 1D    MOV   A,[__r0]
    0D11: 73       CPL   A
    0D12: 54 06    MOV   [X+6],A
    0D14: 80 0C    JMP   0x0D21
    0D16: 7C 1F 1F LCALL 0x1F1F
    0D19: 54 07    MOV   [X+7],A
    0D1B: 51 1B    MOV   A,[__r2]
    0D1D: 0A 1D    ADC   A,[__r0]
    0D1F: 54 06    MOV   [X+6],A
    0D21: 52 07    MOV   A,[X+7]
    0D23: 54 03    MOV   [X+3],A
    0D25: 52 06    MOV   A,[X+6]
    0D27: 54 02    MOV   [X+2],A
(0182) 	CYRF_SetRFChannel(channel);
    0D29: 52 00    MOV   A,[X+0]
    0D2B: 08       PUSH  A
    0D2C: 50 00    MOV   A,0x0
    0D2E: 08       PUSH  A
    0D2F: 7C 0A 68 LCALL _CYRF_WriteRegister
(0183) 	CYRF_SetCRCSeed(CRCSeed);
    0D32: 52 02    MOV   A,[X+2]
    0D34: 08       PUSH  A
    0D35: 52 03    MOV   A,[X+3]
    0D37: 08       PUSH  A
    0D38: 7C 0C 2E LCALL _CYRF_SetCRCSeed
    0D3B: 38 FC    ADD   SP,0xFC
(0184)     CYRF_SetSOPCode(pncodes[pn_row][sop_col]);
    0D3D: 50 08    MOV   A,0x8
    0D3F: 08       PUSH  A
    0D40: 52 01    MOV   A,[X+1]
    0D42: 53 1C    MOV   [__r1],A
    0D44: 50 00    MOV   A,0x0
    0D46: 08       PUSH  A
    0D47: 51 1C    MOV   A,[__r1]
    0D49: 08       PUSH  A
    0D4A: 50 00    MOV   A,0x0
    0D4C: 08       PUSH  A
    0D4D: 50 48    MOV   A,0x48
    0D4F: 08       PUSH  A
    0D50: 7C 1E 74 LCALL 0x1E74
    0D53: 38 FC    ADD   SP,0xFC
    0D55: 5F 1C 11 MOV   [__r1],[__rX]
    0D58: 5F 1D 10 MOV   [__r0],[__rY]
    0D5B: 06 1C 80 ADD   [__r1],0x80
    0D5E: 0E 1D 01 ADC   [__r0],0x1
    0D61: 5F 1A 4E MOV   [__r3],[sop_col]
    0D64: 55 1B 00 MOV   [__r2],0x0
    0D67: 65 1A    ASL   [__r3]
    0D69: 6B 1B    RLC   [__r2]
    0D6B: 65 1A    ASL   [__r3]
    0D6D: 6B 1B    RLC   [__r2]
    0D6F: 65 1A    ASL   [__r3]
    0D71: 6B 1B    RLC   [__r2]
    0D73: 51 1A    MOV   A,[__r3]
    0D75: 02 1C    ADD   A,[__r1]
    0D77: 53 1C    MOV   [__r1],A
    0D79: 51 1B    MOV   A,[__r2]
    0D7B: 0A 1D    ADC   A,[__r0]
    0D7D: 08       PUSH  A
    0D7E: 51 1C    MOV   A,[__r1]
    0D80: 08       PUSH  A
    0D81: 50 22    MOV   A,0x22
    0D83: 08       PUSH  A
    0D84: 7C 0A 81 LCALL _CYRF_WriteRegisterMulti
    0D87: 38 FC    ADD   SP,0xFC
(0185)     CYRF_SetDataCode(pncodes[pn_row][data_col], 16);
    0D89: 50 10    MOV   A,0x10
    0D8B: 08       PUSH  A
    0D8C: 52 01    MOV   A,[X+1]
    0D8E: 53 1C    MOV   [__r1],A
    0D90: 50 00    MOV   A,0x0
    0D92: 08       PUSH  A
    0D93: 51 1C    MOV   A,[__r1]
    0D95: 08       PUSH  A
    0D96: 50 00    MOV   A,0x0
    0D98: 08       PUSH  A
    0D99: 50 48    MOV   A,0x48
    0D9B: 08       PUSH  A
    0D9C: 7C 1E 74 LCALL 0x1E74
    0D9F: 38 FC    ADD   SP,0xFC
    0DA1: 5F 1C 11 MOV   [__r1],[__rX]
    0DA4: 5F 1D 10 MOV   [__r0],[__rY]
    0DA7: 06 1C 80 ADD   [__r1],0x80
    0DAA: 0E 1D 01 ADC   [__r0],0x1
    0DAD: 5F 1A 4D MOV   [__r3],[data_col]
    0DB0: 55 1B 00 MOV   [__r2],0x0
    0DB3: 65 1A    ASL   [__r3]
    0DB5: 6B 1B    RLC   [__r2]
    0DB7: 65 1A    ASL   [__r3]
    0DB9: 6B 1B    RLC   [__r2]
    0DBB: 65 1A    ASL   [__r3]
    0DBD: 6B 1B    RLC   [__r2]
    0DBF: 51 1A    MOV   A,[__r3]
    0DC1: 02 1C    ADD   A,[__r1]
    0DC3: 53 1C    MOV   [__r1],A
    0DC5: 51 1B    MOV   A,[__r2]
    0DC7: 0A 1D    ADC   A,[__r0]
    0DC9: 08       PUSH  A
    0DCA: 51 1C    MOV   A,[__r1]
    0DCC: 08       PUSH  A
    0DCD: 50 23    MOV   A,0x23
    0DCF: 08       PUSH  A
    0DD0: 7C 0A 81 LCALL _CYRF_WriteRegisterMulti
    0DD3: 38 FC    ADD   SP,0xFC
(0186)     if(DSM_Is_DSMX)
    0DD5: 3C 70 00 CMP   [DSM_Is_DSMX],0x0
    0DD8: A0 17    JZ    0x0DF0
(0187)         chidx = (chidx + 1) % 23;
    0DDA: 51 51    MOV   A,[chidx]
    0DDC: 01 01    ADD   A,0x1
    0DDE: 53 1D    MOV   [__r0],A
    0DE0: 50 17    MOV   A,0x17
    0DE2: 08       PUSH  A
    0DE3: 51 1D    MOV   A,[__r0]
    0DE5: 08       PUSH  A
    0DE6: 7C 1D C6 LCALL 0x1DC6
    0DE9: 38 FF    ADD   SP,0xFF
    0DEB: 18       POP   A
    0DEC: 53 51    MOV   [chidx],A
    0DEE: 80 15    JMP   0x0E04
(0188)     else
(0189)         chidx = (chidx + 1) % 2;
    0DF0: 51 51    MOV   A,[chidx]
    0DF2: 01 01    ADD   A,0x1
    0DF4: 53 1D    MOV   [__r0],A
    0DF6: 50 02    MOV   A,0x2
    0DF8: 08       PUSH  A
    0DF9: 51 1D    MOV   A,[__r0]
    0DFB: 08       PUSH  A
    0DFC: 7C 1D C6 LCALL 0x1DC6
    0DFF: 38 FF    ADD   SP,0xFF
    0E01: 18       POP   A
    0E02: 53 51    MOV   [chidx],A
    0E04: 38 F8    ADD   SP,0xF8
    0E06: 20       POP   X
    0E07: 7F       RET   
(0190) }
(0191) 
(0192) //load the given config into cyfr6936
(0193) void DSM_Load_Config(const BYTE vals[][2],BYTE cnt)
(0194) {
_DSM_Load_Config:
  n                    --> X+0
  cnt                  --> X-6
  vals                 --> X-5
    0E08: 10       PUSH  X
    0E09: 4F       MOV   X,SP
    0E0A: 38 01    ADD   SP,0x1
(0195) BYTE n;
(0196) 
(0197) for(n=0;n<cnt;n++)
    0E0C: 56 00 00 MOV   [X+0],0x0
    0E0F: 80 33    JMP   0x0E43
(0198) 	{
(0199) 	CYRF_WriteRegister(vals[n][0],vals[n][1]);
    0E11: 52 00    MOV   A,[X+0]
    0E13: 53 1C    MOV   [__r1],A
    0E15: 55 1D 00 MOV   [__r0],0x0
    0E18: 65 1C    ASL   [__r1]
    0E1A: 6B 1D    RLC   [__r0]
    0E1C: 52 FC    MOV   A,[X-4]
    0E1E: 04 1C    ADD   [__r1],A
    0E20: 52 FB    MOV   A,[X-5]
    0E22: 0C 1D    ADC   [__r0],A
    0E24: 51 1C    MOV   A,[__r1]
    0E26: 01 01    ADD   A,0x1
    0E28: 53 1A    MOV   [__r3],A
    0E2A: 51 1D    MOV   A,[__r0]
    0E2C: 09 00    ADC   A,0x0
    0E2E: 10       PUSH  X
    0E2F: 58 1A    MOV   X,[__r3]
    0E31: 28       ROMX  
    0E32: 20       POP   X
    0E33: 08       PUSH  A
    0E34: 51 1D    MOV   A,[__r0]
    0E36: 10       PUSH  X
    0E37: 58 1C    MOV   X,[__r1]
    0E39: 28       ROMX  
    0E3A: 20       POP   X
    0E3B: 08       PUSH  A
    0E3C: 7C 0A 68 LCALL _CYRF_WriteRegister
    0E3F: 38 FE    ADD   SP,0xFE
(0200) 	}
    0E41: 77 00    INC   [X+0]
    0E43: 52 00    MOV   A,[X+0]
    0E45: 3B FA    CMP   A,[X-6]
    0E47: CF C9    JC    0x0E11
    0E49: 38 FF    ADD   SP,0xFF
    0E4B: 20       POP   X
    0E4C: 7F       RET   
(0201) }
(0202) 
(0203) //called from timer
(0204) //send out next data package
(0205) void Bind_Xmit_cb(void)
(0206) {
(0207) #ifdef DEBUG
(0208) 	 //TX8SW_1_CPutString("X");
(0209) #endif
(0210) 	CYRF_WriteRegisterInc(CYRF_TX_LENGTH,tx_cmd,sizeof(tx_cmd)/sizeof(BYTE));
_Bind_Xmit_cb:
    0E4D: 50 02    MOV   A,0x2
    0E4F: 08       PUSH  A
    0E50: 50 00    MOV   A,0x0
    0E52: 08       PUSH  A
    0E53: 50 06    MOV   A,0x6
    0E55: 08       PUSH  A
    0E56: 50 01    MOV   A,0x1
    0E58: 08       PUSH  A
    0E59: 7C 0B 41 LCALL _CYRF_WriteRegisterInc
(0211) 	CYRF_WriteTx_Data(bind_buf);
    0E5C: 50 10    MOV   A,0x10
    0E5E: 08       PUSH  A
    0E5F: 50 00    MOV   A,0x0
    0E61: 08       PUSH  A
    0E62: 50 26    MOV   A,0x26
    0E64: 08       PUSH  A
    0E65: 50 20    MOV   A,0x20
    0E67: 08       PUSH  A
    0E68: 7C 0A E6 LCALL _CYRF_WriteRegisterMultiD
    0E6B: 38 F8    ADD   SP,0xF8
    0E6D: 7F       RET   
(0212) }
(0213) 
(0214) 
(0215) void Send_Xmit_cb(void)
(0216) {
_Send_Xmit_cb:
    0E6E: 10       PUSH  X
    0E6F: 4F       MOV   X,SP
    0E70: 38 02    ADD   SP,0x2
(0217) #ifdef DEBUG
(0218) 	//TX8SW_1_CPutString("X");
(0219) 	//DIAG_OUT1_Switch(Ch_A);
(0220) #endif
(0221) 	//if(Ch_A) //found on SPI capture from mlp4dsm
(0222) 	//	CYRF_ReadRegister(CYRF_XTAL_CTRL);
(0223) 	CYRF_WriteRegisterInc(CYRF_TX_LENGTH,tx_cmd,sizeof(tx_cmd)/sizeof(BYTE));
    0E72: 50 02    MOV   A,0x2
    0E74: 08       PUSH  A
    0E75: 50 00    MOV   A,0x0
    0E77: 08       PUSH  A
    0E78: 50 06    MOV   A,0x6
    0E7A: 08       PUSH  A
    0E7B: 50 01    MOV   A,0x1
    0E7D: 08       PUSH  A
    0E7E: 7C 0B 41 LCALL _CYRF_WriteRegisterInc
(0224) 	CYRF_WriteTx_Data(tx_buf);
    0E81: 50 10    MOV   A,0x10
    0E83: 08       PUSH  A
    0E84: 50 00    MOV   A,0x0
    0E86: 08       PUSH  A
    0E87: 50 26    MOV   A,0x26
    0E89: 08       PUSH  A
    0E8A: 50 20    MOV   A,0x20
    0E8C: 08       PUSH  A
    0E8D: 7C 0A E6 LCALL _CYRF_WriteRegisterMultiD
    0E90: 38 F8    ADD   SP,0xF8
(0225) 	DSM_ready_for_Serial=FALSE;		
    0E92: 55 6C 00 MOV   [DSM_ready_for_Serial],0x0
(0226) 	Ch_A=!Ch_A;
    0E95: 3C 4F 00 CMP   [Ch_A],0x0
    0E98: B0 09    JNZ   0x0EA2
    0E9A: 56 01 01 MOV   [X+1],0x1
    0E9D: 56 00 00 MOV   [X+0],0x0
    0EA0: 80 07    JMP   0x0EA8
    0EA2: 56 01 00 MOV   [X+1],0x0
    0EA5: 56 00 00 MOV   [X+0],0x0
    0EA8: 52 01    MOV   A,[X+1]
    0EAA: 53 4F    MOV   [Ch_A],A
    0EAC: 38 FE    ADD   SP,0xFE
    0EAE: 20       POP   X
    0EAF: 7F       RET   
(0227) }
(0228) 
(0229) 
(0230) 
(0231) //start reciving
(0232) void DSM_StartReceive(void)
(0233) {
(0234) 	CYRF_StartReceive();
_DSM_StartReceive:
    0EB0: 50 83    MOV   A,0x83
    0EB2: 08       PUSH  A
    0EB3: 50 05    MOV   A,0x5
    0EB5: 08       PUSH  A
    0EB6: 7C 0A 68 LCALL _CYRF_WriteRegister
(0235) 	CYRF_ReadRSSI();
    0EB9: 50 13    MOV   A,0x13
    0EBB: 08       PUSH  A
    0EBC: 7C 0B 57 LCALL _CYRF_ReadRegister
    0EBF: 38 FD    ADD   SP,0xFD
    0EC1: 7F       RET   
(0236) }
(0237) 
(0238) //initialize bind state
(0239) void DSM_initialize_bind(void)
(0240) {	
_DSM_initialize_bind:
  sum                  --> X+1
  n                    --> X+0
    0EC2: 10       PUSH  X
    0EC3: 4F       MOV   X,SP
    0EC4: 38 0D    ADD   SP,0xD
(0241) 	BYTE n;
(0242) 	Bind_cnt=DSM_BIND_CNT;
    0EC6: 55 71 64 MOV   [Bind_cnt],0x64
(0243) 	State=DSM_STATE_BIND;
    0EC9: 55 4C 00 MOV   [State],0x0
(0244) 	DSM_Load_Config(bind_vals,sizeof(bind_vals)/(sizeof(BYTE)*2));
    0ECC: 50 05    MOV   A,0x5
    0ECE: 08       PUSH  A
    0ECF: 50 03    MOV   A,0x3
    0ED1: 08       PUSH  A
    0ED2: 50 0E    MOV   A,0xE
    0ED4: 08       PUSH  A
    0ED5: 9F 31    CALL  _DSM_Load_Config
    0ED7: 38 FD    ADD   SP,0xFD
(0245) 	CYRF_SetRFChannel(bind_channal);
    0ED9: 51 4B    MOV   A,[bind_channal]
    0EDB: 08       PUSH  A
    0EDC: 50 00    MOV   A,0x0
    0EDE: 08       PUSH  A
    0EDF: 7C 0A 68 LCALL _CYRF_WriteRegister
(0246) 	CYRF_SetDataCode(pncodes[0][8], 16);
    0EE2: 50 10    MOV   A,0x10
    0EE4: 08       PUSH  A
    0EE5: 50 01    MOV   A,0x1
    0EE7: 08       PUSH  A
    0EE8: 50 C0    MOV   A,0xC0
    0EEA: 08       PUSH  A
    0EEB: 50 23    MOV   A,0x23
    0EED: 08       PUSH  A
    0EEE: 7C 0A 81 LCALL _CYRF_WriteRegisterMulti
    0EF1: 38 FA    ADD   SP,0xFA
(0247) 
(0248) 	//manual inline
(0249) 	//DSM_build_bind_packet();
(0250) 	//void DSM_build_bind_packet(void)
(0251) 	{
(0252) 	    //BYTE n;
(0253) 	    WORD sum = 384 - 0x10;
    0EF3: 56 02 70 MOV   [X+2],0x70
    0EF6: 56 01 01 MOV   [X+1],0x1
(0254) 	    bind_buf[0] = ~cyrfmfg_id[0];
    0EF9: 51 00    MOV   A,[cyrfmfg_id|n|ser_c]
    0EFB: 73       CPL   A
    0EFC: 53 26    MOV   [mem],A
(0255) 	    bind_buf[1] = ~cyrfmfg_id[1];
    0EFE: 51 01    MOV   A,[cyrfmfg_id|n|ser_c+1]
    0F00: 73       CPL   A
    0F01: 53 27    MOV   [mem+1],A
(0256) 	    bind_buf[2] = ~cyrfmfg_id[2];
    0F03: 51 02    MOV   A,[cyrfmfg_id|n|ser_c+2]
    0F05: 73       CPL   A
    0F06: 53 28    MOV   [mem+2],A
(0257) 	    bind_buf[3] = ~(cyrfmfg_id[3]+ModellNr);
    0F08: 51 03    MOV   A,[cyrfmfg_id|n|ser_c+3]
    0F0A: 02 74    ADD   A,[ModellNr]
    0F0C: 73       CPL   A
    0F0D: 53 29    MOV   [mem+3],A
(0258) 	    bind_buf[4] = bind_buf[0];
    0F0F: 5F 2A 26 MOV   [mem+4],[mem]
(0259) 	    bind_buf[5] = bind_buf[1];
    0F12: 5F 2B 27 MOV   [mem+5],[mem+1]
(0260) 	    bind_buf[6] = bind_buf[2];
    0F15: 5F 2C 28 MOV   [mem+6],[mem+2]
(0261) 	    bind_buf[7] = bind_buf[3];
    0F18: 5F 2D 29 MOV   [mem+7],[mem+3]
(0262) 		
(0263) 		//gennerate first checksum
(0264) 	    for(n = 0; n < 8; n++)
    0F1B: 56 00 00 MOV   [X+0],0x0
    0F1E: 80 12    JMP   0x0F31
(0265) 	        sum += bind_buf[n];
    0F20: 52 00    MOV   A,[X+0]
    0F22: 01 26    ADD   A,0x26
    0F24: 53 1C    MOV   [__r1],A
    0F26: 3E 1C    MVI   A,[__r1]
    0F28: 05 02    ADD   [X+2],A
    0F2A: 50 00    MOV   A,0x0
    0F2C: 0F 01 00 ADC   [X+1],0x0
    0F2F: 77 00    INC   [X+0]
    0F31: 3D 00 08 CMP   [X+0],0x8
    0F34: CF EB    JC    0x0F20
(0266) 	    bind_buf[8] = sum >> 8;
    0F36: 52 01    MOV   A,[X+1]
    0F38: 53 2E    MOV   [mem+8],A
(0267) 	    bind_buf[9] = sum & 0xff;
    0F3A: 52 02    MOV   A,[X+2]
    0F3C: 53 2F    MOV   [mem+9],A
(0268) 
(0269) 		bind_buf[10] = 0x01; //?Air 0x2; //surface 
    0F3E: 55 30 01 MOV   [mem+10],0x1
(0270) 	    bind_buf[11] =num_channels;
    0F41: 5F 31 72 MOV   [mem+11],[num_channels]
(0271) 	    bind_buf[12] = DSM_Is_DSMX?(DSM_Is_11ms?0xB2:0xA2):DSM_Is_11Bit?(DSM_Is_11ms?0x12:0x11):(DSM_Is_11ms?0x02:0x01);
    0F44: 3C 70 00 CMP   [DSM_Is_DSMX],0x0
    0F47: A0 1E    JZ    0x0F66
    0F49: 3C 6F 00 CMP   [DSM_Is_11ms],0x0
    0F4C: A0 09    JZ    0x0F56
    0F4E: 56 06 B2 MOV   [X+6],0xB2
    0F51: 56 05 00 MOV   [X+5],0x0
    0F54: 80 07    JMP   0x0F5C
    0F56: 56 06 A2 MOV   [X+6],0xA2
    0F59: 56 05 00 MOV   [X+5],0x0
    0F5C: 52 06    MOV   A,[X+6]
    0F5E: 54 04    MOV   [X+4],A
    0F60: 52 05    MOV   A,[X+5]
    0F62: 54 03    MOV   [X+3],A
    0F64: 80 46    JMP   0x0FAB
    0F66: 3C 6E 00 CMP   [DSM_Is_11Bit],0x0
    0F69: A0 1E    JZ    0x0F88
    0F6B: 3C 6F 00 CMP   [DSM_Is_11ms],0x0
    0F6E: A0 09    JZ    0x0F78
    0F70: 56 0A 12 MOV   [X+10],0x12
    0F73: 56 09 00 MOV   [X+9],0x0
    0F76: 80 07    JMP   0x0F7E
    0F78: 56 0A 11 MOV   [X+10],0x11
    0F7B: 56 09 00 MOV   [X+9],0x0
    0F7E: 52 0A    MOV   A,[X+10]
    0F80: 54 08    MOV   [X+8],A
    0F82: 52 09    MOV   A,[X+9]
    0F84: 54 07    MOV   [X+7],A
    0F86: 80 1C    JMP   0x0FA3
    0F88: 3C 6F 00 CMP   [DSM_Is_11ms],0x0
    0F8B: A0 09    JZ    0x0F95
    0F8D: 56 0C 02 MOV   [X+12],0x2
    0F90: 56 0B 00 MOV   [X+11],0x0
    0F93: 80 07    JMP   0x0F9B
    0F95: 56 0C 01 MOV   [X+12],0x1
    0F98: 56 0B 00 MOV   [X+11],0x0
    0F9B: 52 0C    MOV   A,[X+12]
    0F9D: 54 08    MOV   [X+8],A
    0F9F: 52 0B    MOV   A,[X+11]
    0FA1: 54 07    MOV   [X+7],A
    0FA3: 52 08    MOV   A,[X+8]
    0FA5: 54 04    MOV   [X+4],A
    0FA7: 52 07    MOV   A,[X+7]
    0FA9: 54 03    MOV   [X+3],A
    0FAB: 52 04    MOV   A,[X+4]
    0FAD: 53 32    MOV   [mem+12],A
(0272) 
(0273) #ifdef DEBUG
(0274) 		TX8SW_1_PutSHexByte(bind_buf[12]);	
(0275) #endif
(0276) 		
(0277) 		bind_buf[13] = 0x00; //???
    0FAF: 55 33 00 MOV   [mem+13],0x0
(0278) 		
(0279) 	    //gennerate second checksum 
(0280) 		for(n = 8; n < 14; n++)
    0FB2: 56 00 08 MOV   [X+0],0x8
    0FB5: 80 12    JMP   0x0FC8
(0281) 	        sum += bind_buf[n];
    0FB7: 52 00    MOV   A,[X+0]
    0FB9: 01 26    ADD   A,0x26
    0FBB: 53 1C    MOV   [__r1],A
    0FBD: 3E 1C    MVI   A,[__r1]
    0FBF: 05 02    ADD   [X+2],A
    0FC1: 50 00    MOV   A,0x0
    0FC3: 0F 01 00 ADC   [X+1],0x0
    0FC6: 77 00    INC   [X+0]
    0FC8: 3D 00 0E CMP   [X+0],0xE
    0FCB: CF EB    JC    0x0FB7
(0282) 	    
(0283) 		bind_buf[14] = sum >> 8;
    0FCD: 52 01    MOV   A,[X+1]
    0FCF: 53 34    MOV   [mem+14],A
(0284) 	    bind_buf[15] = sum & 0xff;
    0FD1: 52 02    MOV   A,[X+2]
    0FD3: 53 35    MOV   [mem+15],A
(0285) 	}
(0286) 	Timer_SetPeriod(DSM_TIME_BIND);
    0FD5: 10       PUSH  X
    0FD6: 57 27    MOV   X,0x27
    0FD8: 50 10    MOV   A,0x10
    0FDA: 7C 05 58 LCALL _Counter16_1_WritePeriod
    0FDD: 20       POP   X
(0287) 	Timer_SetCallback(Bind_Xmit_cb);
    0FDE: 50 03    MOV   A,0x3
    0FE0: 08       PUSH  A
    0FE1: 50 32    MOV   A,0x32
    0FE3: 08       PUSH  A
    0FE4: 7C 1C 75 LCALL _Timer_SetCallback
    0FE7: 38 FE    ADD   SP,0xFE
(0288) 	Timer_Start();
    0FE9: 10       PUSH  X
    0FEA: 7C 05 50 LCALL _Counter16_1_DisableInt|_Counter16_1_Start|Counter16_1_Start
    0FED: 20       POP   X
    0FEE: 38 F3    ADD   SP,0xF3
    0FF0: 20       POP   X
    0FF1: 7F       RET   
(0289) }
(0290) 
(0291) 
(0292) //build the data package
(0293) void DSM_build_data_packet(void)
(0294) {
_DSM_build_data_packet:
  val                  --> X+1
  i                    --> X+0
    0FF2: 10       PUSH  X
    0FF3: 4F       MOV   X,SP
    0FF4: 38 03    ADD   SP,0x3
(0295) BYTE i;
(0296) 	//init header
(0297)    if (DSM_Is_DSMX) {
    0FF6: 3C 70 00 CMP   [DSM_Is_DSMX],0x0
    0FF9: A0 0C    JZ    0x1006
(0298)         tx_buf[0] = cyrfmfg_id[2];
    0FFB: 5F 26 02 MOV   [mem],[cyrfmfg_id|n|ser_c+2]
(0299)         tx_buf[1] = (cyrfmfg_id[3]+ModellNr);
    0FFE: 51 03    MOV   A,[cyrfmfg_id|n|ser_c+3]
    1000: 02 74    ADD   A,[ModellNr]
    1002: 53 27    MOV   [mem+1],A
(0300)     } else {
    1004: 80 0D    JMP   0x1012
(0301)         tx_buf[0] = ~cyrfmfg_id[2];
    1006: 51 02    MOV   A,[cyrfmfg_id|n|ser_c+2]
    1008: 73       CPL   A
    1009: 53 26    MOV   [mem],A
(0302)         tx_buf[1] = ~(cyrfmfg_id[3]+ModellNr);
    100B: 51 03    MOV   A,[cyrfmfg_id|n|ser_c+3]
    100D: 02 74    ADD   A,[ModellNr]
    100F: 73       CPL   A
    1010: 53 27    MOV   [mem+1],A
(0303)     }
(0304) 	//fill data 
(0305)     for (i = 0; i < 6; i++) 
    1012: 56 00 00 MOV   [X+0],0x0
    1015: 80 3B    JMP   0x1051
(0306) 		{
(0307) 		WORD val=Ch_Data[i];
    1017: 52 00    MOV   A,[X+0]
    1019: 64       ASL   A
    101A: 01 78    ADD   A,0x78
    101C: 53 1C    MOV   [__r1],A
    101E: 3E 1C    MVI   A,[__r1]
    1020: 54 01    MOV   [X+1],A
    1022: 3E 1C    MVI   A,[__r1]
    1024: 54 02    MOV   [X+2],A
(0308) 		//input data is allways 11Bit
(0309) 		//so we need to shift down if we transmit DSM2 10Bit format
(0310) 		if(!DSM_Is_11Bit)
    1026: 3C 6E 00 CMP   [DSM_Is_11Bit],0x0
    1029: B0 07    JNZ   0x1031
(0311) 			val=val>>1;
    102B: 70 FB    AND   F,0xFB
    102D: 6F 01    RRC   [X+1]
    102F: 6F 02    RRC   [X+2]
(0312) 		tx_buf[i*2+2]=val>>8;
    1031: 52 01    MOV   A,[X+1]
    1033: 53 1D    MOV   [__r0],A
    1035: 52 00    MOV   A,[X+0]
    1037: 64       ASL   A
    1038: 01 28    ADD   A,0x28
    103A: 53 1A    MOV   [__r3],A
    103C: 51 1D    MOV   A,[__r0]
    103E: 3F 1A    MVI   [__r3],A
(0313) 		tx_buf[i*2+3]=val&0xFF;
    1040: 52 02    MOV   A,[X+2]
    1042: 53 1C    MOV   [__r1],A
    1044: 52 00    MOV   A,[X+0]
    1046: 64       ASL   A
    1047: 01 29    ADD   A,0x29
    1049: 53 1A    MOV   [__r3],A
    104B: 51 1C    MOV   A,[__r1]
    104D: 3F 1A    MVI   [__r3],A
(0314)  		}
    104F: 77 00    INC   [X+0]
    1051: 3D 00 06 CMP   [X+0],0x6
    1054: CF C2    JC    0x1017
(0315) 	tx_buf[14]=0xFF;
    1056: 55 34 FF MOV   [mem+14],0xFF
(0316) 	tx_buf[15]=0xFF;
    1059: 55 35 FF MOV   [mem+15],0xFF
    105C: 38 FD    ADD   SP,0xFD
    105E: 20       POP   X
    105F: 7F       RET   
(0317)  }
(0318) 
(0319) //clear recive error and pending interupt flags
(0320) void DSM_ClearRxError(void)
(0321) {
_DSM_ClearRxError:
  i                    --> X+0
    1060: 10       PUSH  X
    1061: 4F       MOV   X,SP
    1062: 38 01    ADD   SP,0x1
(0322) 	BYTE i=100;
    1064: 56 00 64 MOV   [X+0],0x64
(0323) 	CYRF_ReadRegister(CYRF_RX_IRQ_STATUS);
    1067: 50 07    MOV   A,0x7
    1069: 08       PUSH  A
    106A: 7C 0B 57 LCALL _CYRF_ReadRegister
(0324) 	CYRF_ReadRegister(CYRF_RX_IRQ_STATUS);
    106D: 50 07    MOV   A,0x7
    106F: 08       PUSH  A
    1070: 7C 0B 57 LCALL _CYRF_ReadRegister
    1073: 38 FE    ADD   SP,0xFE
(0325) 	CYRF_WriteRegister(CYRF_RX_ABORT,ABORT_EN); //abort
    1075: 50 20    MOV   A,0x20
    1077: 08       PUSH  A
    1078: 50 29    MOV   A,0x29
    107A: 08       PUSH  A
    107B: 7C 0A 68 LCALL _CYRF_WriteRegister
(0326) 	//force end state
(0327) 	CYRF_WriteRegister(CYRF_XACT_CFG,CYRF_XACT_END_STATE(CYRF_MODE_IDLE)|CYRF_FRC_END);
    107E: 50 24    MOV   A,0x24
    1080: 08       PUSH  A
    1081: 50 0F    MOV   A,0xF
    1083: 08       PUSH  A
    1084: 7C 0A 68 LCALL _CYRF_WriteRegister
    1087: 38 FC    ADD   SP,0xFC
    1089: 80 0A    JMP   0x1094
(0328)     while (! (CYRF_ReadRegister(CYRF_XACT_CFG) & CYRF_XACT_END_STATE(CYRF_MODE_IDLE))) 
(0329) 	{
(0330)         if(!--i)
    108B: 17 00 01 SUB   [X+0],0x1
    108E: 52 00    MOV   A,[X+0]
    1090: B0 03    JNZ   0x1094
(0331)             break;
    1092: 80 10    JMP   0x10A3
(0332) 	}
    1094: 50 0F    MOV   A,0xF
    1096: 08       PUSH  A
    1097: 7C 0B 57 LCALL _CYRF_ReadRegister
    109A: 38 FF    ADD   SP,0xFF
    109C: 53 1D    MOV   [__r0],A
    109E: 47 1D 04 TST   [__r0],0x4
    10A1: AF E9    JZ    0x108B
(0333) 	//clear abort
(0334) 	CYRF_WriteRegister(CYRF_RX_ABORT,0);
    10A3: 50 00    MOV   A,0x0
    10A5: 08       PUSH  A
    10A6: 50 29    MOV   A,0x29
    10A8: 08       PUSH  A
    10A9: 7C 0A 68 LCALL _CYRF_WriteRegister
    10AC: 38 FE    ADD   SP,0xFE
    10AE: 38 FF    ADD   SP,0xFF
    10B0: 20       POP   X
    10B1: 7F       RET   
(0335) }
(0336) 
(0337) 
(0338) //called from timer
(0339) //see if we recived response from reciver
(0340) void Rcv_cb(void)
(0341) {
(0342) #ifdef DEBUG
(0343) 	//TX8SW_1_CPutString("R");
(0344) #endif
(0345) 	Bind_cnt--;
_Rcv_cb:
    10B2: 7A 71    DEC   [Bind_cnt]
(0346) 	//check if time is over
(0347) 	if(!Bind_cnt)
    10B4: 3C 71 00 CMP   [Bind_cnt],0x0
    10B7: B0 1E    JNZ   0x10D6
(0348) 	{
(0349) 		Timer_Stop();
    10B9: 10       PUSH  X
    10BA: 7C 05 54 LCALL _Counter16_1_Stop
    10BD: 20       POP   X
(0350) 		//if we got no response abbort RX and clear anny rx error
(0351) 		if(!RX_Response)
    10BE: 3C 50 00 CMP   [RX_Response],0x0
    10C1: B0 11    JNZ   0x10D3
(0352) 		{
(0353) 			DSM_ClearRxError();
    10C3: 9F 9B    CALL  _DSM_ClearRxError
(0354) 			//fallback to DSM2 10Bit 22ms if not forced 
(0355) 			if(!DSM_Is_Forced)
    10C5: 3C 6D 00 CMP   [DSM_Is_Forced],0x0
    10C8: B0 0A    JNZ   0x10D3
(0356) 			{
(0357) 				DSM_Is_DSMX=FALSE;
    10CA: 55 70 00 MOV   [DSM_Is_DSMX],0x0
(0358) 				DSM_Is_11Bit=FALSE;
    10CD: 55 6E 00 MOV   [DSM_Is_11Bit],0x0
(0359) 				DSM_Is_11ms=FALSE;
    10D0: 55 6F 00 MOV   [DSM_Is_11ms],0x0
(0360) 			}
(0361) 		}
(0362) 	State=DSM_STATE_TRANSMIT;
    10D3: 55 4C 02 MOV   [State],0x2
(0363) #ifdef DEBUG
(0364) 	/*if(DSM_Is_DSMX)
(0365) 		TX8SW_1_CPutString("DSMX ");
(0366) 	else
(0367) 		TX8SW_1_CPutString("DSM2 ");
(0368) 	if(DSM_Is_11ms)
(0369) 		TX8SW_1_CPutString("11ms ");
(0370) 	else
(0371) 		TX8SW_1_CPutString("22ms ");
(0372) 	if(DSM_Is_11Bit)
(0373) 		TX8SW_1_CPutString("11Bit ");
(0374) 	else
(0375) 		TX8SW_1_CPutString("10Bit ");*/
(0376) #endif
(0377) 	}
    10D6: 7F       RET   
(0378) }
(0379) 
(0380) //start waiting for the bind recive signal
(0381) void DSM_StartBindRcv(void)
(0382) {
(0383) 	State=DSM_STATE_BIND_RCV;
_DSM_StartBindRcv:
    10D7: 55 4C 01 MOV   [State],0x1
(0384) 	Timer_SetCallback(Rcv_cb);
    10DA: 50 03    MOV   A,0x3
    10DC: 08       PUSH  A
    10DD: 50 30    MOV   A,0x30
    10DF: 08       PUSH  A
    10E0: 7C 1C 75 LCALL _Timer_SetCallback
(0385)     CYRF_SetDataCode(pn_bind, 16);
    10E3: 50 10    MOV   A,0x10
    10E5: 08       PUSH  A
    10E6: 50 01    MOV   A,0x1
    10E8: 08       PUSH  A
    10E9: 50 70    MOV   A,0x70
    10EB: 08       PUSH  A
    10EC: 50 23    MOV   A,0x23
    10EE: 08       PUSH  A
    10EF: 7C 0A 81 LCALL _CYRF_WriteRegisterMulti
    10F2: 38 FA    ADD   SP,0xFA
(0386) 	Bind_cnt=DSM_BIND_RCV_CNT;
    10F4: 55 71 1E MOV   [Bind_cnt],0x1E
(0387) 	CYRF_StartReceive();
    10F7: 50 83    MOV   A,0x83
    10F9: 08       PUSH  A
    10FA: 50 05    MOV   A,0x5
    10FC: 08       PUSH  A
    10FD: 7C 0A 68 LCALL _CYRF_WriteRegister
(0388) 	CYRF_ReadRSSI();
    1100: 50 13    MOV   A,0x13
    1102: 08       PUSH  A
    1103: 7C 0B 57 LCALL _CYRF_ReadRegister
    1106: 38 FD    ADD   SP,0xFD
    1108: 7F       RET   
(0389) }
(0390) 
(0391) 
(0392) 
(0393) void DSM_Cyclic(void)
(0394) {
_DSM_Cyclic:
  i                    --> X+7
  rx_cnt               --> X+6
  ckSum                --> X+4
  Irq_Status           --> X+0
    1109: 10       PUSH  X
    110A: 4F       MOV   X,SP
    110B: 38 0C    ADD   SP,0xC
(0395) 	if(CY_irq) //we got an IRQ from CYRF6936
    110D: 3C 46 00 CMP   [CY_irq],0x0
    1110: A1 6F    JZ    0x1280
(0396) 	{
(0397) 		BYTE Irq_Status[2];
(0398) 		CY_irq=FALSE;
    1112: 55 46 00 MOV   [CY_irq],0x0
(0399) #ifdef DEBUG
(0400) 		//DIAG_OUT1_Invert();
(0401) 		//DIAG_OUT1_Invert();
(0402) 		//TX8SW_1_CPutString("I");
(0403) #endif
(0404) 		
(0405) 		switch(State)
    1115: 51 4C    MOV   A,[State]
    1117: 54 03    MOV   [X+3],A
    1119: 56 02 00 MOV   [X+2],0x0
    111C: 3D 02 00 CMP   [X+2],0x0
    111F: B0 06    JNZ   0x1126
    1121: 3D 03 00 CMP   [X+3],0x0
    1124: A0 0D    JZ    0x1132
    1126: 3D 02 00 CMP   [X+2],0x0
    1129: B0 06    JNZ   0x1130
    112B: 3D 03 01 CMP   [X+3],0x1
    112E: A0 28    JZ    0x1157
    1130: 81 21    JMP   0x1252
(0406) 		{
(0407) 			case DSM_STATE_BIND:
(0408) 			{
(0409) 				//read IRQ status
(0410) 				CYRF_ReadRegisterMulti(CYRF_TX_IRQ_STATUS,Irq_Status,2);
    1132: 50 02    MOV   A,0x2
    1134: 08       PUSH  A
    1135: 51 1D    MOV   A,[__r0]
    1137: 08       PUSH  A
    1138: 10       PUSH  X
    1139: 50 04    MOV   A,0x4
    113B: 08       PUSH  A
    113C: 7C 0B 6F LCALL _CYRF_ReadRegisterMulti
    113F: 38 FC    ADD   SP,0xFC
(0411) 				Irq_Status[0]|=Irq_Status[1]&TXE_IRQ;
    1141: 52 01    MOV   A,[X+1]
    1143: 21 01    AND   A,0x1
    1145: 2D 00    OR    [X+0],A
(0412) 				//TX done
(0413) 				if(Irq_Status[0]&TXC_IRQ)
    1147: 48 00 02 TST   [X+0],0x2
    114A: A1 35    JZ    0x1280
(0414) 					{
(0415) 						Bind_cnt--;
    114C: 7A 71    DEC   [Bind_cnt]
(0416) 						//check if we are done (time is over)
(0417) 						if(!Bind_cnt)
    114E: 3C 71 00 CMP   [Bind_cnt],0x0
    1151: B1 2E    JNZ   0x1280
(0418) 						{
(0419) 							//start reciving the response
(0420) 							DSM_StartBindRcv();
    1153: 9F 82    CALL  _DSM_StartBindRcv
(0421) 						}
(0422) 					}	
(0423) 			}
(0424) 			return;
    1155: 81 2A    JMP   0x1280
(0425) 			case DSM_STATE_BIND_RCV:
(0426) 				{
(0427) 					//read IRQ status
(0428) 					CYRF_ReadRegisterMulti(CYRF_RX_IRQ_STATUS,Irq_Status,2);
    1157: 50 02    MOV   A,0x2
    1159: 08       PUSH  A
    115A: 51 1D    MOV   A,[__r0]
    115C: 08       PUSH  A
    115D: 10       PUSH  X
    115E: 50 07    MOV   A,0x7
    1160: 08       PUSH  A
    1161: 7C 0B 6F LCALL _CYRF_ReadRegisterMulti
    1164: 38 FC    ADD   SP,0xFC
(0429) 					Irq_Status[0]|=Irq_Status[1]&RXE_IRQ;
    1166: 52 01    MOV   A,[X+1]
    1168: 21 01    AND   A,0x1
    116A: 2D 00    OR    [X+0],A
(0430) 					if(Irq_Status[0]&RXC_IRQ)
    116C: 48 00 02 TST   [X+0],0x2
    116F: A1 10    JZ    0x1280
(0431) 					{
(0432) 						//we got some thing
(0433) 						BYTE i;
(0434) 				        WORD ckSum = 0x170;
    1171: 56 05 70 MOV   [X+5],0x70
    1174: 56 04 01 MOV   [X+4],0x1
(0435) 						
(0436) 						BYTE rx_cnt=CYRF_Rx_cnt();
    1177: 50 09    MOV   A,0x9
    1179: 08       PUSH  A
    117A: 7C 0B 57 LCALL _CYRF_ReadRegister
    117D: 54 06    MOV   [X+6],A
(0437) #ifdef DEBUG
(0438) 						//TX8SW_1_CPutString("i");
(0439) #endif
(0440) 						//read it in
(0441) 						CYRF_ReadRx_data(rx_buf,rx_cnt);
    117F: 52 06    MOV   A,[X+6]
    1181: 08       PUSH  A
    1182: 50 00    MOV   A,0x0
    1184: 08       PUSH  A
    1185: 50 36    MOV   A,0x36
    1187: 08       PUSH  A
    1188: 50 21    MOV   A,0x21
    118A: 08       PUSH  A
    118B: 7C 0B 6F LCALL _CYRF_ReadRegisterMulti
    118E: 38 FB    ADD   SP,0xFB
(0442) 						//check recived data
(0443) 						if(rx_cnt!=10)
    1190: 3D 06 0A CMP   [X+6],0xA
    1193: A0 03    JZ    0x1197
(0444) 						{
(0445) 							goto rcv_error;
    1195: 80 B6    JMP   0x124C
(0446) 						}
(0447) #ifdef DEBUG
(0448) 						//TX8SW_1_CPutString("a");
(0449) #endif
(0450) 						if(rx_buf[0]!=bind_buf[0] || rx_buf[1]!=bind_buf[1] || rx_buf[2]!=bind_buf[2] || rx_buf[3]!=bind_buf[3])
    1197: 51 36    MOV   A,[mem+16]
    1199: 3A 26    CMP   A,[mem]
    119B: B0 13    JNZ   0x11AF
    119D: 51 37    MOV   A,[mem+17]
    119F: 3A 27    CMP   A,[mem+1]
    11A1: B0 0D    JNZ   0x11AF
    11A3: 51 38    MOV   A,[mem+18]
    11A5: 3A 28    CMP   A,[mem+2]
    11A7: B0 07    JNZ   0x11AF
    11A9: 51 39    MOV   A,[mem+19]
    11AB: 3A 29    CMP   A,[mem+3]
    11AD: A0 03    JZ    0x11B1
(0451) 						{
(0452) 							goto rcv_error;
    11AF: 80 9C    JMP   0x124C
(0453) 						}
(0454) #ifdef DEBUG
(0455) 						//TX8SW_1_CPutString("b");
(0456) #endif
(0457) 						for (i = 0; i < 8; i++)
    11B1: 56 07 00 MOV   [X+7],0x0
    11B4: 80 12    JMP   0x11C7
(0458) 					         ckSum += rx_buf[i];
    11B6: 52 07    MOV   A,[X+7]
    11B8: 01 36    ADD   A,0x36
    11BA: 53 1C    MOV   [__r1],A
    11BC: 3E 1C    MVI   A,[__r1]
    11BE: 05 05    ADD   [X+5],A
    11C0: 50 00    MOV   A,0x0
    11C2: 0F 04 00 ADC   [X+4],0x0
    11C5: 77 07    INC   [X+7]
    11C7: 3D 07 08 CMP   [X+7],0x8
    11CA: CF EB    JC    0x11B6
(0459) 						if(rx_buf[8] != (ckSum >> 8) || rx_buf[9] !=(ckSum & 0xff))
    11CC: 52 04    MOV   A,[X+4]
    11CE: 53 1C    MOV   [__r1],A
    11D0: 55 1D 00 MOV   [__r0],0x0
    11D3: 5F 1A 3E MOV   [__r3],[mem+24]
    11D6: 50 00    MOV   A,0x0
    11D8: 3A 1D    CMP   A,[__r0]
    11DA: B0 1D    JNZ   0x11F8
    11DC: 51 1A    MOV   A,[__r3]
    11DE: 3A 1C    CMP   A,[__r1]
    11E0: B0 17    JNZ   0x11F8
    11E2: 52 05    MOV   A,[X+5]
    11E4: 53 1C    MOV   [__r1],A
    11E6: 55 1D 00 MOV   [__r0],0x0
    11E9: 5F 1A 3F MOV   [__r3],[mem+25]
    11EC: 50 00    MOV   A,0x0
    11EE: 3A 1D    CMP   A,[__r0]
    11F0: B0 07    JNZ   0x11F8
    11F2: 51 1A    MOV   A,[__r3]
    11F4: 3A 1C    CMP   A,[__r1]
    11F6: A0 03    JZ    0x11FA
(0460) 						{
(0461) 							goto rcv_error;
    11F8: 80 53    JMP   0x124C
(0462) 						}
(0463) #ifdef DEBUG
(0464) 						//TX8SW_1_CPutString("c");
(0465) #endif
(0466) 						//I have no Ida what to do with the channel count the reciver send us
(0467) 						//dsmNumChannels=packet[5];
(0468) 						
(0469) 						//if transmitter is not forced determin operation mode
(0470) 						if(!DSM_Is_Forced)
    11FA: 3C 6D 00 CMP   [DSM_Is_Forced],0x0
    11FD: B0 49    JNZ   0x1247
(0471) 							{
(0472) 							DSM_Is_DSMX=PROTOC_IS_DSMX(rx_buf[6]);
    11FF: 51 3C    MOV   A,[mem+22]
    1201: 21 A0    AND   A,0xA0
    1203: 39 A0    CMP   A,0xA0
    1205: B0 09    JNZ   0x120F
    1207: 56 09 01 MOV   [X+9],0x1
    120A: 56 08 00 MOV   [X+8],0x0
    120D: 80 07    JMP   0x1215
    120F: 56 09 00 MOV   [X+9],0x0
    1212: 56 08 00 MOV   [X+8],0x0
    1215: 52 09    MOV   A,[X+9]
    1217: 53 70    MOV   [DSM_Is_DSMX],A
(0473) 							DSM_Is_11Bit = PROTOC_IS_DSM_11BIT(rx_buf[6]);
    1219: 51 3C    MOV   A,[mem+22]
    121B: 21 30    AND   A,0x30
    121D: 67       ASR   A
    121E: 67       ASR   A
    121F: 67       ASR   A
    1220: 67       ASR   A
    1221: 21 0F    AND   A,0xF
    1223: 53 6E    MOV   [DSM_Is_11Bit],A
(0474) 							DSM_Is_11ms=PROTOC_IS_DSM_11MS(rx_buf[6]);
    1225: 51 3C    MOV   A,[mem+22]
    1227: 21 B2    AND   A,0xB2
    1229: 39 02    CMP   A,0x2
    122B: A0 09    JZ    0x1235
    122D: 51 3C    MOV   A,[mem+22]
    122F: 21 B2    AND   A,0xB2
    1231: 39 B2    CMP   A,0xB2
    1233: B0 09    JNZ   0x123D
    1235: 56 0B 01 MOV   [X+11],0x1
    1238: 56 0A 00 MOV   [X+10],0x0
    123B: 80 07    JMP   0x1243
    123D: 56 0B 00 MOV   [X+11],0x0
    1240: 56 0A 00 MOV   [X+10],0x0
    1243: 52 0B    MOV   A,[X+11]
    1245: 53 6F    MOV   [DSM_Is_11ms],A
(0475) 							}
(0476) 						RX_Response=TRUE;
    1247: 55 50 01 MOV   [RX_Response],0x1
(0477) #ifdef DEBUG
(0478) 						TX8SW_1_PutSHexByte(rx_buf[6]);	
(0479) #endif
(0480) 					}			
(0481) 				return;			
    124A: 80 35    JMP   0x1280
(0482) 				}
(0483) 				rcv_error:
(0484) 					DSM_ClearRxError();
    124C: 9E 12    CALL  _DSM_ClearRxError
(0485) 					DSM_StartBindRcv();
    124E: 9E 87    CALL  _DSM_StartBindRcv
(0486) 				return;
    1250: 80 2F    JMP   0x1280
(0487) 			default:
(0488) 				{ //transmit Mode
(0489) 				//get IRQ Status
(0490) 				CYRF_ReadRegisterMulti(CYRF_TX_IRQ_STATUS,Irq_Status,2);
    1252: 50 02    MOV   A,0x2
    1254: 08       PUSH  A
    1255: 51 1D    MOV   A,[__r0]
    1257: 08       PUSH  A
    1258: 10       PUSH  X
    1259: 50 04    MOV   A,0x4
    125B: 08       PUSH  A
    125C: 7C 0B 6F LCALL _CYRF_ReadRegisterMulti
    125F: 38 FC    ADD   SP,0xFC
(0491) 				Irq_Status[0]|=Irq_Status[1]&TXE_IRQ;
    1261: 52 01    MOV   A,[X+1]
    1263: 21 01    AND   A,0x1
    1265: 2D 00    OR    [X+0],A
(0492) 				//tx done
(0493) 				if(Irq_Status[0]&TXC_IRQ)
    1267: 48 00 02 TST   [X+0],0x2
    126A: A0 15    JZ    0x1280
(0494) 					{
(0495) 					//tx done
(0496) 						//set timer for next transmit
(0497) 						SetTimer();
    126C: 9A 17    CALL  _SetTimer
(0498) #ifdef DEBUG
(0499) 						//TX8SW_1_CPutString("C");
(0500) #endif
(0501) 						//calculate and set channel SOP , CRC and data code
(0502) 						SetCH_CRC_SOP_DATA();
    126E: 9A 32    CALL  _SetCH_CRC_SOP_DATA
(0503) 						if(!Ch_A)
    1270: 3C 4F 00 CMP   [Ch_A],0x0
    1273: B0 0C    JNZ   0x1280
(0504) 						{
(0505) 							CYRF_WriteRegister(CYRF_TX_CFG,tx_cfg); //update TX power 
    1275: 51 4A    MOV   A,[tx_cfg]
    1277: 08       PUSH  A
    1278: 50 03    MOV   A,0x3
    127A: 08       PUSH  A
    127B: 7C 0A 68 LCALL _CYRF_WriteRegister
    127E: 38 FE    ADD   SP,0xFE
(0506) 						}
(0507) 					}	
(0508) 				}
(0509) 		}
(0510) 	}
    1280: 38 F4    ADD   SP,0xF4
    1282: 20       POP   X
    1283: 7F       RET   
(0511) }
(0512) 
(0513) 
(0514) //called if there is new serial data
(0515) void DSM_NewSerialData(void)
(0516) {
_DSM_NewSerialData:
  time                 --> X+4
  Freq_Error           --> X+2
  Phase_Error          --> X+0
    1284: 10       PUSH  X
    1285: 4F       MOV   X,SP
    1286: 38 06    ADD   SP,0x6
(0517) 	int Phase_Error;	
(0518) 	int Freq_Error;
(0519) 		//if we are in the windows for reciving data proceed
(0520) 		if(DSM_ready_for_Serial)
    1288: 3C 6C 00 CMP   [DSM_ready_for_Serial],0x0
    128B: A0 82    JZ    0x130E
(0521) 		{
(0522) 			//get time left till next transmit, shall be 2ms
(0523) 			WORD time=Counter16_1_wReadCounter();
    128D: 10       PUSH  X
    128E: 7C 05 5E LCALL _Counter16_1_wReadCounter|_wCounter16_1_ReadCounter|Counter16_1_wReadCounter|wCounter16_1_ReadCounter|wCounter16_1_ReadCompareValue|_Counter16_1_wReadCompareValue|_Counter16_1_WriteCompareValue|_wCounter16_1_ReadCompareValue
    1291: 5A 1D    MOV   [__r0],X
    1293: 20       POP   X
    1294: 54 05    MOV   [X+5],A
    1296: 51 1D    MOV   A,[__r0]
    1298: 54 04    MOV   [X+4],A
(0524) 			//we need at least one ms for building the package
(0525) 			if(time>DSM_TIME11MS && !DSM_Is_11ms )//&& ((Ch_Data[dsm_Max_pos]>>11)+1)==num_channels)
    129A: 50 58    MOV   A,0x58
    129C: 13 05    SUB   A,[X+5]
    129E: 50 1B    MOV   A,0x1B
    12A0: 1B 04    SBB   A,[X+4]
    12A2: D0 08    JNC   0x12AB
    12A4: 3C 6F 00 CMP   [DSM_Is_11ms],0x0
    12A7: B0 03    JNZ   0x12AB
(0526) 				{ //ignore extra data (transmitter running 11ms while reciver expect 11ms)
(0527) #ifdef DEBUG
(0528) 				TX8SW_1_CPutString("Q");
(0529) #endif
(0530) 				return;
    12A9: 80 8E    JMP   0x1338
(0531) 				}
(0532) 			if(time>200)
    12AB: 50 C8    MOV   A,0xC8
    12AD: 13 05    SUB   A,[X+5]
    12AF: 50 00    MOV   A,0x0
    12B1: 1B 04    SBB   A,[X+4]
    12B3: D0 03    JNC   0x12B7
(0533) 			{
(0534) 				DSM_build_data_packet();
    12B5: 9D 3B    CALL  _DSM_build_data_packet
(0535) #ifdef DEBUG
(0536) 				TX8SW_1_CPutString("P");
(0537) #endif
(0538) 			}
(0539) #ifdef DEBUG
(0540) 				TX8SW_1_CPutString("S");
(0541) #endif
(0542) 		//calculate pahse error	
(0543) 		Phase_Error=DSM_SER_TO_XMIT_TIME-time;
    12B7: 50 D0    MOV   A,0xD0
    12B9: 13 05    SUB   A,[X+5]
    12BB: 53 1C    MOV   [__r1],A
    12BD: 50 07    MOV   A,0x7
    12BF: 1B 04    SBB   A,[X+4]
    12C1: 53 1D    MOV   [__r0],A
    12C3: 51 1C    MOV   A,[__r1]
    12C5: 54 01    MOV   [X+1],A
    12C7: 51 1D    MOV   A,[__r0]
    12C9: 54 00    MOV   [X+0],A
(0544) 		//calculate frequency error
(0545) 		//instead off measuring the perriode and the transmision perriode
(0546) 		//wee use the change the Phase Error to calculate the frequency error
(0547) 		Freq_Error=Phase_Error-Last_Phase_error;
    12CB: 52 01    MOV   A,[X+1]
    12CD: 12 49    SUB   A,[Last_Phase_error+1]
    12CF: 54 03    MOV   [X+3],A
    12D1: 52 00    MOV   A,[X+0]
    12D3: 1A 48    SBB   A,[Last_Phase_error]
    12D5: 54 02    MOV   [X+2],A
(0548) 		//save corrent error as last
(0549) 		Last_Phase_error=Phase_Error;
    12D7: 52 01    MOV   A,[X+1]
    12D9: 53 49    MOV   [Last_Phase_error+1],A
    12DB: 52 00    MOV   A,[X+0]
    12DD: 53 48    MOV   [Last_Phase_error],A
(0550) 		//simple double P-Term loop.
(0551) 		DSM_Perriode+=Freq_Error>>3;
    12DF: 52 03    MOV   A,[X+3]
    12E1: 53 1C    MOV   [__r1],A
    12E3: 52 02    MOV   A,[X+2]
    12E5: 67       ASR   A
    12E6: 53 1D    MOV   [__r0],A
    12E8: 7C 1E FF LCALL 0x1EFF
    12EB: 51 1C    MOV   A,[__r1]
    12ED: 04 6B    ADD   [DSM_Perriode+1],A
    12EF: 51 1D    MOV   A,[__r0]
    12F1: 0C 6A    ADC   [DSM_Perriode],A
(0552) 		DSM_Perriode+=Phase_Error>>6;
    12F3: 52 01    MOV   A,[X+1]
    12F5: 53 1C    MOV   [__r1],A
    12F7: 52 00    MOV   A,[X+0]
    12F9: 67       ASR   A
    12FA: 53 1D    MOV   [__r0],A
    12FC: 7C 1E FF LCALL 0x1EFF
    12FF: 68 1D    ASR   [__r0]
    1301: 7C 1E FF LCALL 0x1EFF
    1304: 51 1C    MOV   A,[__r1]
    1306: 04 6B    ADD   [DSM_Perriode+1],A
    1308: 51 1D    MOV   A,[__r0]
    130A: 0C 6A    ADC   [DSM_Perriode],A
(0553) #ifdef DEBUG
(0554) 			if(Phase_Error>200)
(0555) 				TX8SW_1_CPutString("p");
(0556) 			if(Phase_Error<-300)
(0557) 				TX8SW_1_CPutString("m");
(0558) #endif
(0559) 		
(0560) 		}
    130C: 80 29    JMP   0x1336
(0561) 		else //lost sync
(0562) 		{
(0563) 		//serial data came in at a time we did not expected it
(0564) 		//porbably we are out of sync
(0565) 		//resync
(0566) #ifdef DEBUG
(0567) 			TX8SW_1_CPutString("L");
(0568) 			//DIAG_OUT1_Switch(0);
(0569) #endif
(0570) 			//manual inline
(0571) 			//DSM_StartTransmit();
(0572) 			//void DSM_StartTransmit(void)
(0573) 			{
(0574) 				State=DSM_STATE_TRANSMIT;
    130E: 55 4C 02 MOV   [State],0x2
(0575) 				Timer_SetCallback(Send_Xmit_cb);
    1311: 50 03    MOV   A,0x3
    1313: 08       PUSH  A
    1314: 50 2E    MOV   A,0x2E
    1316: 08       PUSH  A
    1317: 7C 1C 75 LCALL _Timer_SetCallback
    131A: 38 FE    ADD   SP,0xFE
(0576) 				//to set timer current value we need to
(0577) 				//stop timer ans set period instead
(0578) 				Timer_Stop();
    131C: 10       PUSH  X
    131D: 7C 05 54 LCALL _Counter16_1_Stop
(0579) 				Timer_SetPeriod(DSM_SER_TO_XMIT_TIME);
    1320: 57 07    MOV   X,0x7
    1322: 50 D0    MOV   A,0xD0
    1324: 7C 05 58 LCALL _Counter16_1_WritePeriod
(0580) 				//start timer
(0581) 				Timer_Start();
    1327: 7C 05 50 LCALL _Counter16_1_DisableInt|_Counter16_1_Start|Counter16_1_Start
    132A: 20       POP   X
(0582) 				Last_Phase_error=0;
    132B: 55 49 00 MOV   [Last_Phase_error+1],0x0
    132E: 55 48 00 MOV   [Last_Phase_error],0x0
(0583) 				Ch_A=TRUE;
    1331: 55 4F 01 MOV   [Ch_A],0x1
(0584) 				SetTimer();
    1334: 99 4F    CALL  _SetTimer
(0585) 			}
(0586) 		}
(0587) 		DSM_build_data_packet();
    1336: 9C BA    CALL  _DSM_build_data_packet
    1338: 38 FA    ADD   SP,0xFA
    133A: 20       POP   X
    133B: 7F       RET   
(0588) }
(0589) 
(0590) //calculate dsmX channels 
(0591) //found on deviation-tx source
(0592) // math by Alexandr Alexandrov code by Sergey Gimaev
(0593) //pseudo random gennerator /Linear congruential generator based on "Numerical Recipes" Chapter 7.1
(0594) void calc_dsmx_channel(void)
(0595) {
_calc_dsmx_channel:
  count_52_76          --> X+20
  count_28_51          --> X+18
  count_3_27           --> X+16
  next_ch              --> X+15
  i                    --> X+13
  id                   --> X+5
  id_tmp               --> X+1
  idx                  --> X+0
    133C: 10       PUSH  X
    133D: 4F       MOV   X,SP
    133E: 38 16    ADD   SP,0x16
(0596)     BYTE idx; 
(0597) 	DWORD id_tmp;
(0598)     DWORD id = ~(((DWORD)cyrfmfg_id[0] << 24) | ((DWORD)cyrfmfg_id[1] << 16) | ((DWORD)cyrfmfg_id[2] << 8) | (((DWORD)cyrfmfg_id[3]+ModellNr) << 0));
    1340: 5F 1A 74 MOV   [__r3],[ModellNr]
    1343: 55 1B 00 MOV   [__r2],0x0
    1346: 55 1C 00 MOV   [__r1],0x0
    1349: 55 1D 00 MOV   [__r0],0x0
    134C: 51 03    MOV   A,[cyrfmfg_id|n|ser_c+3]
    134E: 02 1A    ADD   A,[__r3]
    1350: 53 1A    MOV   [__r3],A
    1352: 50 00    MOV   A,0x0
    1354: 0A 1B    ADC   A,[__r2]
    1356: 53 1B    MOV   [__r2],A
    1358: 50 00    MOV   A,0x0
    135A: 0A 1C    ADC   A,[__r1]
    135C: 53 1C    MOV   [__r1],A
    135E: 50 00    MOV   A,0x0
    1360: 0A 1D    ADC   A,[__r0]
    1362: 54 09    MOV   [X+9],A
    1364: 51 1C    MOV   A,[__r1]
    1366: 54 0A    MOV   [X+10],A
    1368: 51 1B    MOV   A,[__r2]
    136A: 54 0B    MOV   [X+11],A
    136C: 51 1A    MOV   A,[__r3]
    136E: 54 0C    MOV   [X+12],A
    1370: 5F 16 02 MOV   [__r7],[cyrfmfg_id|n|ser_c+2]
    1373: 55 17 00 MOV   [__r6],0x0
    1376: 55 18 00 MOV   [__r5],0x0
    1379: 55 19 00 MOV   [__r4],0x0
    137C: 50 08    MOV   A,0x8
    137E: 65 16    ASL   [__r7]
    1380: 6B 17    RLC   [__r6]
    1382: 6B 18    RLC   [__r5]
    1384: 6B 19    RLC   [__r4]
    1386: 78       DEC   A
    1387: BF F6    JNZ   0x137E
    1389: 5F 12 01 MOV   [__r11],[cyrfmfg_id|n|ser_c+1]
    138C: 55 13 00 MOV   [__r10],0x0
    138F: 55 14 00 MOV   [__r9],0x0
    1392: 55 15 00 MOV   [__r8],0x0
    1395: 50 10    MOV   A,0x10
    1397: 65 12    ASL   [__r11]
    1399: 6B 13    RLC   [__r10]
    139B: 6B 14    RLC   [__r9]
    139D: 6B 15    RLC   [__r8]
    139F: 78       DEC   A
    13A0: BF F6    JNZ   0x1397
    13A2: 5F 1A 00 MOV   [__r3],[cyrfmfg_id|n|ser_c]
    13A5: 55 1B 00 MOV   [__r2],0x0
    13A8: 55 1C 00 MOV   [__r1],0x0
    13AB: 55 1D 00 MOV   [__r0],0x0
    13AE: 50 18    MOV   A,0x18
    13B0: 65 1A    ASL   [__r3]
    13B2: 6B 1B    RLC   [__r2]
    13B4: 6B 1C    RLC   [__r1]
    13B6: 6B 1D    RLC   [__r0]
    13B8: 78       DEC   A
    13B9: BF F6    JNZ   0x13B0
    13BB: 51 12    MOV   A,[__r11]
    13BD: 2C 1A    OR    [__r3],A
    13BF: 51 13    MOV   A,[__r10]
    13C1: 2C 1B    OR    [__r2],A
    13C3: 51 14    MOV   A,[__r9]
    13C5: 2C 1C    OR    [__r1],A
    13C7: 51 15    MOV   A,[__r8]
    13C9: 2C 1D    OR    [__r0],A
    13CB: 51 16    MOV   A,[__r7]
    13CD: 2C 1A    OR    [__r3],A
    13CF: 51 17    MOV   A,[__r6]
    13D1: 2C 1B    OR    [__r2],A
    13D3: 51 18    MOV   A,[__r5]
    13D5: 2C 1C    OR    [__r1],A
    13D7: 51 19    MOV   A,[__r4]
    13D9: 2C 1D    OR    [__r0],A
    13DB: 52 0C    MOV   A,[X+12]
    13DD: 2C 1A    OR    [__r3],A
    13DF: 52 0B    MOV   A,[X+11]
    13E1: 2C 1B    OR    [__r2],A
    13E3: 52 0A    MOV   A,[X+10]
    13E5: 2C 1C    OR    [__r1],A
    13E7: 52 09    MOV   A,[X+9]
    13E9: 2C 1D    OR    [__r0],A
    13EB: 51 1D    MOV   A,[__r0]
    13ED: 73       CPL   A
    13EE: 54 05    MOV   [X+5],A
    13F0: 51 1C    MOV   A,[__r1]
    13F2: 73       CPL   A
    13F3: 54 06    MOV   [X+6],A
    13F5: 51 1B    MOV   A,[__r2]
    13F7: 73       CPL   A
    13F8: 54 07    MOV   [X+7],A
    13FA: 51 1A    MOV   A,[__r3]
    13FC: 73       CPL   A
    13FD: 54 08    MOV   [X+8],A
(0599) 	idx = 0;
    13FF: 56 00 00 MOV   [X+0],0x0
(0600)     id_tmp = id;
    1402: 52 05    MOV   A,[X+5]
    1404: 54 01    MOV   [X+1],A
    1406: 52 06    MOV   A,[X+6]
    1408: 54 02    MOV   [X+2],A
    140A: 52 07    MOV   A,[X+7]
    140C: 54 03    MOV   [X+3],A
    140E: 52 08    MOV   A,[X+8]
    1410: 54 04    MOV   [X+4],A
    1412: 81 9B    JMP   0x15AE
(0601)     while(idx < 23) {
(0602)         int i;
(0603)         BYTE next_ch;
(0604) 		int count_3_27 = 0, count_28_51 = 0, count_52_76 = 0;
    1414: 56 11 00 MOV   [X+17],0x0
    1417: 56 10 00 MOV   [X+16],0x0
    141A: 56 13 00 MOV   [X+19],0x0
    141D: 56 12 00 MOV   [X+18],0x0
    1420: 56 15 00 MOV   [X+21],0x0
    1423: 56 14 00 MOV   [X+20],0x0
(0605)         id_tmp = id_tmp * 0x0019660D + 0x3C6EF35F; // Randomization
    1426: 52 01    MOV   A,[X+1]
    1428: 08       PUSH  A
    1429: 52 02    MOV   A,[X+2]
    142B: 08       PUSH  A
    142C: 52 03    MOV   A,[X+3]
    142E: 08       PUSH  A
    142F: 52 04    MOV   A,[X+4]
    1431: 08       PUSH  A
    1432: 50 00    MOV   A,0x0
    1434: 08       PUSH  A
    1435: 50 19    MOV   A,0x19
    1437: 08       PUSH  A
    1438: 50 66    MOV   A,0x66
    143A: 08       PUSH  A
    143B: 50 0D    MOV   A,0xD
    143D: 08       PUSH  A
    143E: 7C 1E 97 LCALL 0x1E97
    1441: 38 FC    ADD   SP,0xFC
    1443: 18       POP   A
    1444: 53 1A    MOV   [__r3],A
    1446: 18       POP   A
    1447: 53 1B    MOV   [__r2],A
    1449: 18       POP   A
    144A: 53 1C    MOV   [__r1],A
    144C: 18       POP   A
    144D: 53 1D    MOV   [__r0],A
    144F: 51 1A    MOV   A,[__r3]
    1451: 01 5F    ADD   A,0x5F
    1453: 54 04    MOV   [X+4],A
    1455: 51 1B    MOV   A,[__r2]
    1457: 09 F3    ADC   A,0xF3
    1459: 54 03    MOV   [X+3],A
    145B: 51 1C    MOV   A,[__r1]
    145D: 09 6E    ADC   A,0x6E
    145F: 54 02    MOV   [X+2],A
    1461: 51 1D    MOV   A,[__r0]
    1463: 09 3C    ADC   A,0x3C
    1465: 54 01    MOV   [X+1],A
(0606)         next_ch = ((id_tmp >> 8) % 0x49) + 3;       // Use least-significant byte and must be larger than 3
    1467: 52 01    MOV   A,[X+1]
    1469: 53 1D    MOV   [__r0],A
    146B: 52 02    MOV   A,[X+2]
    146D: 53 1C    MOV   [__r1],A
    146F: 52 03    MOV   A,[X+3]
    1471: 53 1B    MOV   [__r2],A
    1473: 52 04    MOV   A,[X+4]
    1475: 53 1A    MOV   [__r3],A
    1477: 50 08    MOV   A,0x8
    1479: 70 FB    AND   F,0xFB
    147B: 6E 1D    RRC   [__r0]
    147D: 6E 1C    RRC   [__r1]
    147F: 6E 1B    RRC   [__r2]
    1481: 6E 1A    RRC   [__r3]
    1483: 78       DEC   A
    1484: BF F4    JNZ   0x1479
    1486: 50 00    MOV   A,0x0
    1488: 08       PUSH  A
    1489: 08       PUSH  A
    148A: 08       PUSH  A
    148B: 50 49    MOV   A,0x49
    148D: 08       PUSH  A
    148E: 51 1D    MOV   A,[__r0]
    1490: 08       PUSH  A
    1491: 51 1C    MOV   A,[__r1]
    1493: 08       PUSH  A
    1494: 51 1B    MOV   A,[__r2]
    1496: 08       PUSH  A
    1497: 51 1A    MOV   A,[__r3]
    1499: 08       PUSH  A
    149A: 7C 1D BB LCALL 0x1DBB
    149D: 38 FC    ADD   SP,0xFC
    149F: 18       POP   A
    14A0: 53 1A    MOV   [__r3],A
    14A2: 18       POP   A
    14A3: 18       POP   A
    14A4: 18       POP   A
    14A5: 06 1A 03 ADD   [__r3],0x3
    14A8: 51 1A    MOV   A,[__r3]
    14AA: 54 0F    MOV   [X+15],A
(0607)         if (((next_ch ^ id) & 0x01 )== 0)
    14AC: 52 0F    MOV   A,[X+15]
    14AE: 53 1A    MOV   [__r3],A
    14B0: 55 1B 00 MOV   [__r2],0x0
    14B3: 55 1C 00 MOV   [__r1],0x0
    14B6: 55 1D 00 MOV   [__r0],0x0
    14B9: 52 08    MOV   A,[X+8]
    14BB: 34 1A    XOR   [__r3],A
    14BD: 52 07    MOV   A,[X+7]
    14BF: 34 1B    XOR   [__r2],A
    14C1: 52 06    MOV   A,[X+6]
    14C3: 34 1C    XOR   [__r1],A
    14C5: 52 05    MOV   A,[X+5]
    14C7: 34 1D    XOR   [__r0],A
    14C9: 26 1A 01 AND   [__r3],0x1
    14CC: 26 1B 00 AND   [__r2],0x0
    14CF: 26 1C 00 AND   [__r1],0x0
    14D2: 26 1D 00 AND   [__r0],0x0
    14D5: B0 12    JNZ   0x14E8
    14D7: 3C 1C 00 CMP   [__r1],0x0
    14DA: B0 0D    JNZ   0x14E8
    14DC: 3C 1B 00 CMP   [__r2],0x0
    14DF: B0 08    JNZ   0x14E8
    14E1: 3C 1A 00 CMP   [__r3],0x0
    14E4: B0 03    JNZ   0x14E8
(0608)             continue;
    14E6: 80 C7    JMP   0x15AE
(0609)         for (i = 0; i < idx; i++) {
    14E8: 56 0E 00 MOV   [X+14],0x0
    14EB: 56 0D 00 MOV   [X+13],0x0
    14EE: 80 47    JMP   0x1536
(0610)             if(channels[i] == next_ch)
    14F0: 52 0E    MOV   A,[X+14]
    14F2: 01 52    ADD   A,0x52
    14F4: 53 1C    MOV   [__r1],A
    14F6: 3E 1C    MVI   A,[__r1]
    14F8: 3B 0F    CMP   A,[X+15]
    14FA: B0 03    JNZ   0x14FE
(0611)                 break;
    14FC: 80 4F    JMP   0x154C
(0612)             if(channels[i] <= 27)
    14FE: 52 0E    MOV   A,[X+14]
    1500: 01 52    ADD   A,0x52
    1502: 53 1C    MOV   [__r1],A
    1504: 3E 1C    MVI   A,[__r1]
    1506: 53 1D    MOV   [__r0],A
    1508: 50 1B    MOV   A,0x1B
    150A: 3A 1D    CMP   A,[__r0]
    150C: C0 08    JC    0x1515
(0613)                 count_3_27++;
    150E: 77 11    INC   [X+17]
    1510: 0F 10 00 ADC   [X+16],0x0
    1513: 80 1D    JMP   0x1531
(0614)             else if (channels[i] <= 51)
    1515: 52 0E    MOV   A,[X+14]
    1517: 01 52    ADD   A,0x52
    1519: 53 1C    MOV   [__r1],A
    151B: 3E 1C    MVI   A,[__r1]
    151D: 53 1D    MOV   [__r0],A
    151F: 50 33    MOV   A,0x33
    1521: 3A 1D    CMP   A,[__r0]
    1523: C0 08    JC    0x152C
(0615)                 count_28_51++;
    1525: 77 13    INC   [X+19]
    1527: 0F 12 00 ADC   [X+18],0x0
    152A: 80 06    JMP   0x1531
(0616)             else
(0617)                 count_52_76++;
    152C: 77 15    INC   [X+21]
    152E: 0F 14 00 ADC   [X+20],0x0
(0618)         }
    1531: 77 0E    INC   [X+14]
    1533: 0F 0D 00 ADC   [X+13],0x0
    1536: 52 00    MOV   A,[X+0]
    1538: 53 1C    MOV   [__r1],A
    153A: 52 0E    MOV   A,[X+14]
    153C: 12 1C    SUB   A,[__r1]
    153E: 50 00    MOV   A,0x0
    1540: 31 80    XOR   A,0x80
    1542: 53 11    MOV   [__rX],A
    1544: 52 0D    MOV   A,[X+13]
    1546: 31 80    XOR   A,0x80
    1548: 1A 11    SBB   A,[__rX]
    154A: CF A5    JC    0x14F0
(0619)         if (i != idx)
    154C: 52 00    MOV   A,[X+0]
    154E: 53 1C    MOV   [__r1],A
    1550: 55 1D 00 MOV   [__r0],0x0
    1553: 52 0D    MOV   A,[X+13]
    1555: 3A 1D    CMP   A,[__r0]
    1557: B0 07    JNZ   0x155F
    1559: 52 0E    MOV   A,[X+14]
    155B: 3A 1C    CMP   A,[__r1]
    155D: A0 03    JZ    0x1561
(0620)             continue;
    155F: 80 4E    JMP   0x15AE
(0621)         if ((next_ch < 28 && count_3_27 < 8)
    1561: 3D 0F 1C CMP   [X+15],0x1C
    1564: D0 0D    JNC   0x1572
    1566: 52 11    MOV   A,[X+17]
    1568: 11 08    SUB   A,0x8
    156A: 52 10    MOV   A,[X+16]
    156C: 31 80    XOR   A,0x80
    156E: 19 80    SBB   A,0x80
    1570: C0 28    JC    0x1599
    1572: 3D 0F 1C CMP   [X+15],0x1C
    1575: C0 12    JC    0x1588
    1577: 3D 0F 34 CMP   [X+15],0x34
    157A: D0 0D    JNC   0x1588
    157C: 52 13    MOV   A,[X+19]
    157E: 11 07    SUB   A,0x7
    1580: 52 12    MOV   A,[X+18]
    1582: 31 80    XOR   A,0x80
    1584: 19 80    SBB   A,0x80
    1586: C0 12    JC    0x1599
    1588: 3D 0F 34 CMP   [X+15],0x34
    158B: C0 22    JC    0x15AE
    158D: 52 15    MOV   A,[X+21]
    158F: 11 08    SUB   A,0x8
    1591: 52 14    MOV   A,[X+20]
    1593: 31 80    XOR   A,0x80
    1595: 19 80    SBB   A,0x80
    1597: D0 16    JNC   0x15AE
(0622)           ||(next_ch >= 28 && next_ch < 52 && count_28_51 < 7)
(0623)           ||(next_ch >= 52 && count_52_76 < 8))
(0624)         {
(0625)             channels[idx++] = next_ch;
    1599: 52 00    MOV   A,[X+0]
    159B: 53 1C    MOV   [__r1],A
    159D: 55 1D 00 MOV   [__r0],0x0
    15A0: 01 01    ADD   A,0x1
    15A2: 54 00    MOV   [X+0],A
    15A4: 06 1C 52 ADD   [__r1],0x52
    15A7: 0E 1D 00 ADC   [__r0],0x0
    15AA: 52 0F    MOV   A,[X+15]
    15AC: 3F 1C    MVI   [__r1],A
(0626) #ifdef DEBUG
(0627) 		TX8SW_1_PutSHexByte(next_ch);	
(0628) #endif
(0629)         }
(0630)     }
    15AE: 3D 00 17 CMP   [X+0],0x17
    15B1: CE 62    JC    0x1414
    15B3: 38 EA    ADD   SP,0xEA
    15B5: 20       POP   X
    15B6: 7F       RET   
(0631) }
(0632) 
(0633) BOOL cb_tick;
(0634) //called form timer
(0635) //set flag that timer ticked
(0636) void src_cb(void)
(0637) {
(0638) 	cb_tick=TRUE;
_src_cb:
    15B7: 55 47 01 MOV   [cb_tick],0x1
    15BA: 7F       RET   
(0639) 	#ifdef DEBUG
(0640) 	//TX8SW_1_CPutString("t");
(0641) 	#endif
(0642) 
(0643) }
(0644) 
(0645) //find 2 channels with low noise
(0646) void find_dsm2_channel(void)
(0647) {
_find_dsm2_channel:
  val                  --> X+2
  rssi                 --> X+1
  ch                   --> X+0
    15BB: 10       PUSH  X
    15BC: 4F       MOV   X,SP
    15BD: 38 03    ADD   SP,0x3
(0648) BYTE ch;
(0649) #ifdef DEBUG
(0650) 	//TX8SW_1_CPutString("F");
(0651) #endif
(0652) 	//set timing	
(0653) 	Timer_SetCallback(src_cb);
    15BF: 50 03    MOV   A,0x3
    15C1: 08       PUSH  A
    15C2: 50 2C    MOV   A,0x2C
    15C4: 08       PUSH  A
    15C5: 7C 1C 75 LCALL _Timer_SetCallback
    15C8: 38 FE    ADD   SP,0xFE
(0654) 	Timer_SetPeriod(DSM_SCAN_TIME);
    15CA: 10       PUSH  X
    15CB: 57 55    MOV   X,0x55
    15CD: 50 F0    MOV   A,0xF0
    15CF: 7C 05 58 LCALL _Counter16_1_WritePeriod
(0655) 	Timer_Start();
    15D2: 7C 05 50 LCALL _Counter16_1_DisableInt|_Counter16_1_Start|Counter16_1_Start
    15D5: 20       POP   X
(0656) 	cb_tick=FALSE;
    15D6: 55 47 00 MOV   [cb_tick],0x0
(0657) 	//loop thru both channels
(0658) 	for(ch=0;ch<2;)
    15D9: 56 00 00 MOV   [X+0],0x0
    15DC: 80 92    JMP   0x166F
(0659) 	{
(0660) 		BYTE rssi=0;
    15DE: 56 01 00 MOV   [X+1],0x0
(0661) 		//take from spi capture of MLP4DSM
(0662) 		CYRF_WriteRegister(CYRF_DATA64_THOLD,0x3F);
    15E1: 50 3F    MOV   A,0x3F
    15E3: 08       PUSH  A
    15E4: 50 12    MOV   A,0x12
    15E6: 08       PUSH  A
    15E7: 7C 0A 68 LCALL _CYRF_WriteRegister
    15EA: 38 FE    ADD   SP,0xFE
(0663) 		CYRF_WriteRegister(CYRF_FRAMING_CFG,0xFF);
    15EC: 50 FF    MOV   A,0xFF
    15EE: 08       PUSH  A
    15EF: 50 10    MOV   A,0x10
    15F1: 08       PUSH  A
    15F2: 7C 0A 68 LCALL _CYRF_WriteRegister
(0664) 		CYRF_SetSOPCode(pn_check);
    15F5: 50 08    MOV   A,0x8
    15F7: 08       PUSH  A
    15F8: 50 01    MOV   A,0x1
    15FA: 08       PUSH  A
    15FB: 50 78    MOV   A,0x78
    15FD: 08       PUSH  A
    15FE: 50 22    MOV   A,0x22
    1600: 08       PUSH  A
    1601: 7C 0A 81 LCALL _CYRF_WriteRegisterMulti
    1604: 38 FA    ADD   SP,0xFA
(0665) 		//loop thru avaliable channels
(0666) 		bind_channal+=5;
    1606: 06 4B 05 ADD   [bind_channal],0x5
(0667) 		bind_channal%=0x4F;
    1609: 50 4F    MOV   A,0x4F
    160B: 08       PUSH  A
    160C: 51 4B    MOV   A,[bind_channal]
    160E: 08       PUSH  A
    160F: 7C 1D C6 LCALL 0x1DC6
    1612: 38 FF    ADD   SP,0xFF
    1614: 18       POP   A
    1615: 53 4B    MOV   [bind_channal],A
(0668) 		bind_channal|=1;
    1617: 2E 4B 01 OR    [bind_channal],0x1
(0669) 		CYRF_SetRFChannel(bind_channal);
    161A: 51 4B    MOV   A,[bind_channal]
    161C: 08       PUSH  A
    161D: 50 00    MOV   A,0x0
    161F: 08       PUSH  A
    1620: 7C 0A 68 LCALL _CYRF_WriteRegister
    1623: 38 FE    ADD   SP,0xFE
(0670) 		//start reciving
(0671) 		DSM_StartReceive();
    1625: 98 89    CALL  _DSM_StartReceive
    1627: 80 17    JMP   0x163F
(0672) 		//capture max of rssi
(0673) 		while(!cb_tick)
(0674) 		{
(0675) 			BYTE val=0x1F&CYRF_ReadRSSI();
    1629: 50 13    MOV   A,0x13
    162B: 08       PUSH  A
    162C: 7C 0B 57 LCALL _CYRF_ReadRegister
    162F: 38 FF    ADD   SP,0xFF
    1631: 21 1F    AND   A,0x1F
    1633: 54 02    MOV   [X+2],A
(0676) 			if(val>rssi)
    1635: 52 01    MOV   A,[X+1]
    1637: 3B 02    CMP   A,[X+2]
    1639: D0 05    JNC   0x163F
(0677) 				rssi=val;
    163B: 52 02    MOV   A,[X+2]
    163D: 54 01    MOV   [X+1],A
(0678) 		}
    163F: 3C 47 00 CMP   [cb_tick],0x0
    1642: AF E6    JZ    0x1629
(0679) #ifdef DEBUG
(0680) 		//TX8SW_1_CPutString("T");
(0681) 		//TX8SW_1_PutSHexByte(bind_channal);
(0682) #endif
(0683) 		cb_tick=FALSE;
    1644: 55 47 00 MOV   [cb_tick],0x0
(0684) 		//low noise? use this one
(0685) 		if(rssi<15)
    1647: 3D 01 0F CMP   [X+1],0xF
    164A: D0 0D    JNC   0x1658
(0686) 			{
(0687) 			channels[ch]=bind_channal;
    164C: 52 00    MOV   A,[X+0]
    164E: 01 52    ADD   A,0x52
    1650: 53 1C    MOV   [__r1],A
    1652: 51 4B    MOV   A,[bind_channal]
    1654: 3F 1C    MVI   [__r1],A
(0688) 			ch++;
    1656: 77 00    INC   [X+0]
(0689) #ifdef DEBUG
(0690) 			//TX8SW_1_CPutString("P ");
(0691) #endif
(0692) 			}
(0693) 	//read away any data we recived and clear any error
(0694) 	CYRF_ReadRx_data(rx_buf,CYRF_Rx_cnt());
    1658: 50 09    MOV   A,0x9
    165A: 08       PUSH  A
    165B: 7C 0B 57 LCALL _CYRF_ReadRegister
    165E: 08       PUSH  A
    165F: 50 00    MOV   A,0x0
    1661: 08       PUSH  A
    1662: 50 36    MOV   A,0x36
    1664: 08       PUSH  A
    1665: 50 21    MOV   A,0x21
    1667: 08       PUSH  A
    1668: 7C 0B 6F LCALL _CYRF_ReadRegisterMulti
    166B: 38 FB    ADD   SP,0xFB
(0695) 	DSM_ClearRxError();
    166D: 99 F1    CALL  _DSM_ClearRxError
(0696) 	}
    166F: 3D 00 02 CMP   [X+0],0x2
    1672: CF 6B    JC    0x15DE
(0697) 	//we are done stop timer
(0698) 	Timer_SetCallback(0);
    1674: 50 03    MOV   A,0x3
    1676: 08       PUSH  A
    1677: 50 2A    MOV   A,0x2A
    1679: 08       PUSH  A
    167A: 7C 1C 75 LCALL _Timer_SetCallback
    167D: 38 FE    ADD   SP,0xFE
(0699) 	Timer_Stop();
    167F: 10       PUSH  X
    1680: 7C 05 54 LCALL _Counter16_1_Stop
    1683: 20       POP   X
    1684: 38 FD    ADD   SP,0xFD
    1686: 20       POP   X
    1687: 7F       RET   
(0700) #ifdef DEBUG
(0701) 		//TX8SW_1_CPutString("E");
(0702) #endif
(0703) }
(0704) //coad configuration for transmit mode
(0705) void DSM_LoadTransmitMode(void)
(0706) {
_DSM_LoadTransmitMode:
    1688: 10       PUSH  X
    1689: 4F       MOV   X,SP
    168A: 38 02    ADD   SP,0x2
(0707) 	CYRF_WriteRegister(CYRF_TX_CFG,tx_cfg); 
    168C: 51 4A    MOV   A,[tx_cfg]
    168E: 08       PUSH  A
    168F: 50 03    MOV   A,0x3
    1691: 08       PUSH  A
    1692: 7C 0A 68 LCALL _CYRF_WriteRegister
(0708) 	DSM_Load_Config(Transmit_vals,sizeof(Transmit_vals)/(sizeof(BYTE)*2));
    1695: 50 03    MOV   A,0x3
    1697: 08       PUSH  A
    1698: 50 03    MOV   A,0x3
    169A: 08       PUSH  A
    169B: 50 08    MOV   A,0x8
    169D: 08       PUSH  A
    169E: 7C 0E 08 LCALL _DSM_Load_Config
    16A1: 38 FB    ADD   SP,0xFB
(0709) 	if(DSM_Is_DSMX)
    16A3: 3C 70 00 CMP   [DSM_Is_DSMX],0x0
    16A6: A0 05    JZ    0x16AC
(0710) 		{
(0711) #ifdef DEBUG
(0712) 			//TX8SW_1_CPutString("CH_");
(0713) #endif
(0714) 		calc_dsmx_channel();
    16A8: 9C 92    CALL  _calc_dsmx_channel
(0715) 		}
    16AA: 80 03    JMP   0x16AE
(0716) 	else
(0717) 		{
(0718) 		find_dsm2_channel();
    16AC: 9F 0D    CALL  _find_dsm2_channel
(0719) 		}	
(0720) 	//set periode to be 11ms or 22ms	
(0721) 	DSM_Perriode=DSM_Is_11ms?DSM_TIME11MS:DSM_TIME22MS;
    16AE: 3C 6F 00 CMP   [DSM_Is_11ms],0x0
    16B1: A0 09    JZ    0x16BB
    16B3: 56 01 58 MOV   [X+1],0x58
    16B6: 56 00 1B MOV   [X+0],0x1B
    16B9: 80 07    JMP   0x16C1
    16BB: 56 01 50 MOV   [X+1],0x50
    16BE: 56 00 46 MOV   [X+0],0x46
    16C1: 52 01    MOV   A,[X+1]
    16C3: 53 6B    MOV   [DSM_Perriode+1],A
    16C5: 52 00    MOV   A,[X+0]
    16C7: 53 6A    MOV   [DSM_Perriode],A
(0722) 	//calculate channel CRC SOP and data code for first channel to transmitt
(0723) 	SetCH_CRC_SOP_DATA();
    16C9: 7C 0C A2 LCALL _SetCH_CRC_SOP_DATA
    16CC: 38 FE    ADD   SP,0xFE
    16CE: 20       POP   X
    16CF: 7F       RET   
(0724) 	
(0725) #ifdef DEBUG
(0726) 	if(DSM_Perriode==DSM_TIME11MS)
(0727) 		TX8SW_1_CPutString("T11");
(0728) 	if(DSM_Perriode==DSM_TIME22MS)
(0729) 		TX8SW_1_CPutString("T22");
(0730) #endif
(0731) }
(0732) 
(0733) 
(0734) //initialise system
(0735) void DSM_Init(void)
(0736) {
_DSM_Init:
  n                    --> X+0
    16D0: 10       PUSH  X
    16D1: 4F       MOV   X,SP
    16D2: 38 01    ADD   SP,0x1
(0737) 	BYTE n;
(0738) 	//init CYRF6936
(0739) 	CYRF_Init();
    16D4: 7C 0A 20 LCALL _CYRF_Init
(0740) 	//set defalut values
(0741) 	DSM_Is_DSMX=TRUE;
    16D7: 55 70 01 MOV   [DSM_Is_DSMX],0x1
(0742) 	DSM_Is_11ms=TRUE;
    16DA: 55 6F 01 MOV   [DSM_Is_11ms],0x1
(0743) 	DSM_Is_11Bit=TRUE;
    16DD: 55 6E 01 MOV   [DSM_Is_11Bit],0x1
(0744) 	DSM_Is_Forced=FALSE;
    16E0: 55 6D 00 MOV   [DSM_Is_Forced],0x0
(0745) 	RX_Response=FALSE;
    16E3: 55 50 00 MOV   [RX_Response],0x0
(0746) 	Ch_A=TRUE;
    16E6: 55 4F 01 MOV   [Ch_A],0x1
(0747) 	chidx=0;
    16E9: 55 51 00 MOV   [chidx],0x0
(0748) 	DSM_ready_for_Serial=FALSE;
    16EC: 55 6C 00 MOV   [DSM_ready_for_Serial],0x0
(0749) 	Bind_cnt=0;
    16EF: 55 71 00 MOV   [Bind_cnt],0x0
(0750) 	num_channels=6;
    16F2: 55 72 06 MOV   [num_channels],0x6
(0751) 	//set tx power to defalut
(0752) 	tx_cfg=TX_CFG|DSM_TX_POWER;
    16F5: 55 4A 2F MOV   [tx_cfg],0x2F
(0753) 	
(0754) 	CYRF_WritePreamble(preamble);
    16F8: 50 03    MOV   A,0x3
    16FA: 08       PUSH  A
    16FB: 50 03    MOV   A,0x3
    16FD: 08       PUSH  A
    16FE: 50 18    MOV   A,0x18
    1700: 08       PUSH  A
    1701: 50 24    MOV   A,0x24
    1703: 08       PUSH  A
    1704: 7C 0A 81 LCALL _CYRF_WriteRegisterMulti
    1707: 38 FC    ADD   SP,0xFC
(0755) 	CYRF_GetMfgData(cyrfmfg_id);
    1709: 50 00    MOV   A,0x0
    170B: 08       PUSH  A
    170C: 50 00    MOV   A,0x0
    170E: 08       PUSH  A
    170F: 7C 0C 08 LCALL _CYRF_GetMfgData
(0756) #ifdef SHIFT_MFG_ID
(0757) 	for (n=0;n<6;n++)
(0758) 		{
(0759) 		cyrfmfg_id[n]=cyrfmfg_id[(n+1)%6];
(0760) 		}
(0761) #endif
(0762) #ifdef DEBUG
(0763) 	TX8SW_1_CPutString("MfgId:");
(0764) 	for (n=0;n<6;n++)
(0765) 		{
(0766) 		TX8SW_1_PutSHexByte(cyrfmfg_id[n]);	
(0767) 		}
(0768) #endif
(0769) 	//calculate sop and data column
(0770) 	sop_col = (cyrfmfg_id[0] + cyrfmfg_id[1] + cyrfmfg_id[2] + 2) & 0x07;
    1712: 51 00    MOV   A,[cyrfmfg_id|n|ser_c]
    1714: 02 01    ADD   A,[cyrfmfg_id|n|ser_c+1]
    1716: 53 1D    MOV   [__r0],A
    1718: 51 02    MOV   A,[cyrfmfg_id|n|ser_c+2]
    171A: 04 1D    ADD   [__r0],A
    171C: 06 1D 02 ADD   [__r0],0x2
    171F: 51 1D    MOV   A,[__r0]
    1721: 21 07    AND   A,0x7
    1723: 53 4E    MOV   [sop_col],A
(0771)     data_col = 7 - sop_col;
    1725: 50 07    MOV   A,0x7
    1727: 12 4E    SUB   A,[sop_col]
    1729: 53 4D    MOV   [data_col],A
(0772) 	CYRF_SetRFChannel(0x61);
    172B: 50 61    MOV   A,0x61
    172D: 08       PUSH  A
    172E: 50 00    MOV   A,0x0
    1730: 08       PUSH  A
    1731: 7C 0A 68 LCALL _CYRF_WriteRegister
    1734: 38 FC    ADD   SP,0xFC
(0773) 	//get some random
(0774) 	//for choosing a random bind cannel we need some randomness.
(0775) 	//but on a microcontroller this is hard to archive
(0776) 	//so use some noise we capture on channel 0x61
(0777) 	//if you look on the SPI trace from MLP4DSM spectrum seems to do something simmular
(0778) 	DSM_StartReceive();
    1736: 7C 0E B0 LCALL _DSM_StartReceive
(0779) 	CYRF_WriteRegister(CYRF_DATA64_THOLD,0x3F);
    1739: 50 3F    MOV   A,0x3F
    173B: 08       PUSH  A
    173C: 50 12    MOV   A,0x12
    173E: 08       PUSH  A
    173F: 7C 0A 68 LCALL _CYRF_WriteRegister
(0780) 	CYRF_WriteRegister(CYRF_FRAMING_CFG,0x7F);
    1742: 50 7F    MOV   A,0x7F
    1744: 08       PUSH  A
    1745: 50 10    MOV   A,0x10
    1747: 08       PUSH  A
    1748: 7C 0A 68 LCALL _CYRF_WriteRegister
    174B: 38 FC    ADD   SP,0xFC
(0781) 	DSM_StartReceive();
    174D: 7C 0E B0 LCALL _DSM_StartReceive
(0782) 	Timer_Wait_ms(10);
    1750: 50 0A    MOV   A,0xA
    1752: 08       PUSH  A
    1753: 7C 1B FF LCALL _Timer_Wait_ms
(0783) 	CYRF_ReadRx_data(rx_buf,CYRF_Rx_cnt());
    1756: 50 09    MOV   A,0x9
    1758: 08       PUSH  A
    1759: 7C 0B 57 LCALL _CYRF_ReadRegister
    175C: 38 FE    ADD   SP,0xFE
    175E: 08       PUSH  A
    175F: 50 00    MOV   A,0x0
    1761: 08       PUSH  A
    1762: 50 36    MOV   A,0x36
    1764: 08       PUSH  A
    1765: 50 21    MOV   A,0x21
    1767: 08       PUSH  A
    1768: 7C 0B 6F LCALL _CYRF_ReadRegisterMulti
(0784) 	DSM_ClearRxError();
    176B: 98 F3    CALL  _DSM_ClearRxError
(0785) 	DSM_Load_Config(init_vals,sizeof(init_vals)/(sizeof(BYTE)*2));
    176D: 50 10    MOV   A,0x10
    176F: 08       PUSH  A
    1770: 50 02    MOV   A,0x2
    1772: 08       PUSH  A
    1773: 50 E8    MOV   A,0xE8
    1775: 08       PUSH  A
    1776: 7C 0E 08 LCALL _DSM_Load_Config
    1779: 38 F9    ADD   SP,0xF9
(0786) 
(0787) #ifdef DEBUG
(0788) 	TX8SW_1_CPutString(" BindCH:");
(0789) #endif
(0790) 	//simpel xor sum of what we got
(0791) 	for(n=0;n<16;n++)
    177B: 56 00 00 MOV   [X+0],0x0
    177E: 80 13    JMP   0x1792
(0792) 		bind_channal^=rx_buf[n];
    1780: 52 00    MOV   A,[X+0]
    1782: 01 36    ADD   A,0x36
    1784: 53 1C    MOV   [__r1],A
    1786: 3E 1C    MVI   A,[__r1]
    1788: 53 1D    MOV   [__r0],A
    178A: 51 4B    MOV   A,[bind_channal]
    178C: 32 1D    XOR   A,[__r0]
    178E: 53 4B    MOV   [bind_channal],A
    1790: 77 00    INC   [X+0]
    1792: 3D 00 10 CMP   [X+0],0x10
    1795: CF EA    JC    0x1780
(0793) 	//add systic
(0794) 	bind_channal+=(systic&0xFF)^(systic>>8);
    1797: 5F 1C 0B MOV   [__r1],[systic]
    179A: 51 0C    MOV   A,[systic+1]
    179C: 32 1C    XOR   A,[__r1]
    179E: 53 1C    MOV   [__r1],A
    17A0: 51 4B    MOV   A,[bind_channal]
    17A2: 02 1C    ADD   A,[__r1]
    17A4: 53 4B    MOV   [bind_channal],A
(0795) 	bind_channal&=0x3F;
    17A6: 26 4B 3F AND   [bind_channal],0x3F
(0796) 	bind_channal|=1; //make shure channel is odd
    17A9: 2E 4B 01 OR    [bind_channal],0x1
(0797) #ifdef DEBUG
(0798) 	TX8SW_1_PutSHexByte(bind_channal);
(0799) #endif
(0800) 	CY_irq=FALSE;;
    17AC: 55 46 00 MOV   [CY_irq],0x0
    17AF: 38 FF    ADD   SP,0xFF
    17B1: 20       POP   X
    17B2: 7F       RET   
FILE: C:\Users\Ralf\DOCUME~1\DSM_SA~1\DSM_SA~1\DSM_SA~1\main.c
(0001) //----------------------------------------------------------------------------
(0002) // C main line
(0003) //----------------------------------------------------------------------------
(0004) 
(0005) //98000BFE295413FE26A81BFE0154 //DSMX
(0006) 
(0007) //900005FF14AA09FF13540DFF00AA   //DSM2
(0008) 
(0009) #include <m8c.h>        // part specific constants and macros
(0010) #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
(0011) #include "serial.h"
(0012) #include "timer.h"
(0013) #include "CYRF6936.h"
(0014) #include "DSM.h"
(0015) #include "config.h"
(0016) 
(0017) //global data
(0018) BOOL HighRes; //true if incomming data is 11Bit
(0019) BOOL New_Ser_Data; //true if a new serial package is recived
(0020) BOOL ADD_CH_Map;	//true if channel nomber in serial stream are missing
(0021) WORD Ch_Data[6];  //channel data is alwasy 11Bit resolution
(0022) BYTE ModellNr;	//modell number from serial stream
(0023) 
(0024) 
(0025) //get the biggest channel number in data package
(0026) BYTE GetMaxCh(BYTE *max_pos)
(0027) {
_GetMaxCh:
  max                  --> X+2
  chanal               --> X+1
  n                    --> X+0
  max_pos              --> X-5
    17B3: 10       PUSH  X
    17B4: 4F       MOV   X,SP
    17B5: 38 05    ADD   SP,0x5
(0028) 	BYTE n;
(0029) 	BYTE chanal;
(0030) 	BYTE max=0;
    17B7: 56 02 00 MOV   [X+2],0x0
(0031) 	for (n=0;n<6;n++)
    17BA: 56 00 00 MOV   [X+0],0x0
    17BD: 80 57    JMP   0x1815
(0032) 	{
(0033) 		chanal=(ser_databuf[n*2+2]>>(HighRes?3:2))&0xF;
    17BF: 3C 77 00 CMP   [HighRes],0x0
    17C2: A0 09    JZ    0x17CC
    17C4: 56 04 03 MOV   [X+4],0x3
    17C7: 56 03 00 MOV   [X+3],0x0
    17CA: 80 07    JMP   0x17D2
    17CC: 56 04 02 MOV   [X+4],0x2
    17CF: 56 03 00 MOV   [X+3],0x0
    17D2: 52 00    MOV   A,[X+0]
    17D4: 64       ASL   A
    17D5: 01 89    ADD   A,0x89
    17D7: 53 1C    MOV   [__r1],A
    17D9: 3E 1C    MVI   A,[__r1]
    17DB: 53 1C    MOV   [__r1],A
    17DD: 55 1D 00 MOV   [__r0],0x0
    17E0: 52 04    MOV   A,[X+4]
    17E2: 21 0F    AND   A,0xF
    17E4: A0 08    JZ    0x17ED
    17E6: 68 1D    ASR   [__r0]
    17E8: 6E 1C    RRC   [__r1]
    17EA: 78       DEC   A
    17EB: BF FA    JNZ   0x17E6
    17ED: 26 1C 0F AND   [__r1],0xF
    17F0: 51 1C    MOV   A,[__r1]
    17F2: 54 01    MOV   [X+1],A
(0034) 		if(ser_databuf[n*2+2]!=0xFF  && chanal>max)
    17F4: 52 00    MOV   A,[X+0]
    17F6: 64       ASL   A
    17F7: 01 89    ADD   A,0x89
    17F9: 53 1C    MOV   [__r1],A
    17FB: 3E 1C    MVI   A,[__r1]
    17FD: 39 FF    CMP   A,0xFF
    17FF: A0 13    JZ    0x1813
    1801: 52 02    MOV   A,[X+2]
    1803: 3B 01    CMP   A,[X+1]
    1805: D0 0D    JNC   0x1813
(0035) 		{
(0036) 			*max_pos=n;
    1807: 52 FC    MOV   A,[X-4]
    1809: 53 1C    MOV   [__r1],A
    180B: 52 00    MOV   A,[X+0]
    180D: 3F 1C    MVI   [__r1],A
(0037) 			max=chanal;
    180F: 52 01    MOV   A,[X+1]
    1811: 54 02    MOV   [X+2],A
(0038) 		}
(0039) 	}		
    1813: 77 00    INC   [X+0]
    1815: 3D 00 06 CMP   [X+0],0x6
    1818: CF A6    JC    0x17BF
(0040) return max;
    181A: 52 02    MOV   A,[X+2]
    181C: 38 FB    ADD   SP,0xFB
    181E: 20       POP   X
    181F: 7F       RET   
(0041) }
(0042) 
(0043) //called from  serial if a full package is recived
(0044) void Ser_cb(void)
(0045) {
(0046) 	SER_RESET()
_Ser_cb:
    1820: 55 09 00 MOV   [ser_status],0x0
    1823: 55 08 00 MOV   [ser_idx],0x0
(0047) 	//manual inline
(0048) 	//SetOutData();
(0049) 	//void SetOutData(void)
(0050) 	{
(0051) 		static BYTE n;
(0052) 		//loop thru the channel data 
(0053) 		for(n=0;n<6;n++)
    1826: 55 73 00 MOV   [num_channels+1],0x0
    1829: 80 33    JMP   0x185D
(0054) 		{
(0055) 		//Ch_Data is alwasy 11Bit so if incoming data is 10Bit we need to shift up by one bit		
(0056) 		if(HighRes)
    182B: 3C 77 00 CMP   [HighRes],0x0
    182E: A0 12    JZ    0x1841
    1830: 96 B0    CALL  <created procedures>
    1832: 40       NOP   
(0057) 			Ch_Data[n]=((ser_databuf[n*2+2]<<8)|ser_databuf[n*2+3]);
    1833: 06 1C 78 ADD   [__r1],0x78
    1836: 0E 1D 00 ADC   [__r0],0x0
    1839: 3F 1C    MVI   [__r1],A
    183B: 51 1B    MOV   A,[__r2]
    183D: 3F 1C    MVI   [__r1],A
    183F: 80 1B    JMP   0x185B
(0058) 		else
(0059) 			Ch_Data[n]=((ser_databuf[n*2+2]<<8)|ser_databuf[n*2+3])<<1;
    1841: 96 9F    CALL  <created procedures>
    1843: 40       NOP   
    1844: 5F 1A 1B MOV   [__r3],[__r2]
    1847: 53 1B    MOV   [__r2],A
    1849: 65 1A    ASL   [__r3]
    184B: 6B 1B    RLC   [__r2]
    184D: 06 1C 78 ADD   [__r1],0x78
    1850: 0E 1D 00 ADC   [__r0],0x0
    1853: 51 1B    MOV   A,[__r2]
    1855: 3F 1C    MVI   [__r1],A
    1857: 51 1A    MOV   A,[__r3]
    1859: 3F 1C    MVI   [__r1],A
(0060) 		}
    185B: 76 73    INC   [num_channels+1]
    185D: 3C 73 06 CMP   [num_channels+1],0x6
    1860: CF CA    JC    0x182B
(0061) 		if(ADD_CH_Map)
    1862: 3C 75 00 CMP   [ADD_CH_Map],0x0
    1865: A0 30    JZ    0x1896
(0062) 			Ch_Data[n]|=(n<<11);
    1867: 5F 1C 73 MOV   [__r1],[num_channels+1]
    186A: 65 1C    ASL   [__r1]
    186C: 06 1C 78 ADD   [__r1],0x78
    186F: 5F 1B 73 MOV   [__r2],[num_channels+1]
    1872: 55 1A 00 MOV   [__r3],0x0
    1875: 65 1B    ASL   [__r2]
    1877: 65 1A    ASL   [__r3]
    1879: 6B 1B    RLC   [__r2]
    187B: 65 1A    ASL   [__r3]
    187D: 6B 1B    RLC   [__r2]
    187F: 3E 1C    MVI   A,[__r1]
    1881: 53 19    MOV   [__r4],A
    1883: 3E 1C    MVI   A,[__r1]
    1885: 16 1C 02 SUB   [__r1],0x2
    1888: 2A 1A    OR    A,[__r3]
    188A: 53 1A    MOV   [__r3],A
    188C: 51 19    MOV   A,[__r4]
    188E: 2A 1B    OR    A,[__r2]
    1890: 3F 1C    MVI   [__r1],A
    1892: 51 1A    MOV   A,[__r3]
    1894: 3F 1C    MVI   [__r1],A
(0063) 	}
(0064) 	New_Ser_Data=TRUE;
    1896: 55 76 01 MOV   [New_Ser_Data],0x1
    1899: 7F       RET   
(0065) }
(0066) 
(0067) void main(void)
(0068) {
_main:
  max_pos2             --> X+4
  max_pos              --> X+3
  max2                 --> X+2
  Max_Ch               --> X+1
  max                  --> X+4
  min                  --> X+3
  n                    --> X+2
  chanal               --> X+1
  config               --> X+0
    189A: 10       PUSH  X
    189B: 4F       MOV   X,SP
    189C: 38 09    ADD   SP,0x9
(0069) 	BYTE config;				//configuration
(0070) 
(0071) 	//initialize everiting
(0072) 	M8C_EnableGInt;		 		// Enable Global Interrupts
    189E: 71 01    OR    F,0x1
(0073) #ifdef DEBUG
(0074) 	TX8SW_1_Start();
(0075) #endif
(0076) 	SerialRX_Init();
    18A0: 7C 1A A0 LCALL _SerialRX_Init
(0077) 	Timer_init();
    18A3: 7C 1C 31 LCALL _Timer_init
(0078) #ifdef DEBUG
(0079) 	TX8SW_1_CPutString("Hello");
(0080) #endif
(0081) 	LED_1_Start();
    18A6: 10       PUSH  X
    18A7: 7C 04 FE LCALL _LED_1_Off|_LED_1_Start|LED_1_Start|RST_GetState|LED_1_On|_LED_1_Stop|RST_Invert|LED_1_Stop|LED_1_Off
    18AA: 20       POP   X
(0082) 	DSM_Init();
    18AB: 7C 16 D0 LCALL _DSM_Init
(0083) #ifndef DEBUG
(0084) 	E2PROM_1_Start();
    18AE: 10       PUSH  X
    18AF: 7C 05 19 LCALL _E2PROM_1_Start|LED_1_GetState
    18B2: 20       POP   X
(0085) #endif
(0086) 	New_Ser_Data=FALSE;
    18B3: 55 76 00 MOV   [New_Ser_Data],0x0
(0087) 	SerialSetCallback(Ser_cb);
    18B6: 50 03    MOV   A,0x3
    18B8: 08       PUSH  A
    18B9: 50 34    MOV   A,0x34
    18BB: 08       PUSH  A
    18BC: 7C 1A 94 LCALL _SerialSetCallback
    18BF: 38 FE    ADD   SP,0xFE
(0088) #ifdef DEBUG
(0089) 	//DIAG_OUT1_Start();
(0090) #endif
(0091) 
(0092) 	//wait for serial data
(0093) 	while(!New_Ser_Data);
    18C1: 3C 76 00 CMP   [New_Ser_Data],0x0
    18C4: AF FC    JZ    0x18C1
(0094) 	New_Ser_Data=FALSE;
    18C6: 55 76 00 MOV   [New_Ser_Data],0x0
(0095) 	//check format of serial data, do we have 10bit or 11Bit data
(0096) 	
(0097) 	//manual inline
(0098) 	//DeterminBitCount();
(0099) 	//void DeterminBitCount(void)
(0100) 	{
(0101) 		BYTE chanal;
(0102) 		BYTE n;
(0103) 		BYTE min=0xff;
    18C9: 56 03 FF MOV   [X+3],0xFF
(0104) 		BYTE max=0;
    18CC: 56 04 00 MOV   [X+4],0x0
(0105) 
(0106) 		//try 11 Bits
(0107) 		for (n=0;n<6;n++)
    18CF: 56 02 00 MOV   [X+2],0x0
    18D2: 80 39    JMP   0x190C
(0108) 		{
(0109) 			chanal=(ser_databuf[n*2+2]>>3)&0xF;
    18D4: 52 02    MOV   A,[X+2]
    18D6: 64       ASL   A
    18D7: 01 89    ADD   A,0x89
    18D9: 53 1C    MOV   [__r1],A
    18DB: 3E 1C    MVI   A,[__r1]
    18DD: 67       ASR   A
    18DE: 67       ASR   A
    18DF: 67       ASR   A
    18E0: 21 0F    AND   A,0xF
    18E2: 54 01    MOV   [X+1],A
(0110) 			if (chanal&&chanal<min)
    18E4: 3D 01 00 CMP   [X+1],0x0
    18E7: A0 0B    JZ    0x18F3
    18E9: 52 01    MOV   A,[X+1]
    18EB: 3B 03    CMP   A,[X+3]
    18ED: D0 05    JNC   0x18F3
(0111) 				min=chanal;
    18EF: 52 01    MOV   A,[X+1]
    18F1: 54 03    MOV   [X+3],A
(0112) 			if(ser_databuf[n*2+2]!=0xFF  && chanal>max)
    18F3: 52 02    MOV   A,[X+2]
    18F5: 64       ASL   A
    18F6: 01 89    ADD   A,0x89
    18F8: 53 1C    MOV   [__r1],A
    18FA: 3E 1C    MVI   A,[__r1]
    18FC: 39 FF    CMP   A,0xFF
    18FE: A0 0B    JZ    0x190A
    1900: 52 04    MOV   A,[X+4]
    1902: 3B 01    CMP   A,[X+1]
    1904: D0 05    JNC   0x190A
(0113) 				max=chanal;
    1906: 52 01    MOV   A,[X+1]
    1908: 54 04    MOV   [X+4],A
(0114) 		}		
    190A: 77 02    INC   [X+2]
    190C: 3D 02 06 CMP   [X+2],0x6
    190F: CF C4    JC    0x18D4
(0115) 		if ((max-min)>=4)
    1911: 52 04    MOV   A,[X+4]
    1913: 13 03    SUB   A,[X+3]
    1915: 39 04    CMP   A,0x4
    1917: C0 06    JC    0x191E
(0116) 			HighRes=TRUE;
    1919: 55 77 01 MOV   [HighRes],0x1
    191C: 80 04    JMP   0x1921
(0117) 		else 
(0118) 			HighRes=FALSE;
    191E: 55 77 00 MOV   [HighRes],0x0
(0119) 	}
(0120) 	//get model number from serail stream
(0121) 	//range is from 0 to 15
(0122) 	ModellNr=ser_databuf[1];
    1921: 5F 74 88 MOV   [ModellNr],[ser_databuf+1]
(0123) 	
(0124) 	
(0125) 	DSM_SetRangeCheck(ser_databuf[0]&SPTX_RANGE_CHECK);
    1924: 51 87    MOV   A,[ser_databuf]
    1926: 21 20    AND   A,0x20
    1928: 08       PUSH  A
    1929: 7C 0C 66 LCALL _DSM_SetRangeCheck
(0126) 
(0127) 	
(0128) 	//manual inline
(0129) 	//Determin_Mode();
(0130) 	//void Determin_Mode(void)
(0131) 	{
(0132) 		BYTE max2;
(0133) 		BYTE max_pos;
(0134) 		BYTE max_pos2;
(0135) 
(0136) 		//get highest channel found in data stream
(0137) 		BYTE Max_Ch=GetMaxCh(&max_pos);
    192C: 5A 1C    MOV   [__r1],X
    192E: 06 1C 03 ADD   [__r1],0x3
    1931: 51 1D    MOV   A,[__r0]
    1933: 08       PUSH  A
    1934: 51 1C    MOV   A,[__r1]
    1936: 08       PUSH  A
    1937: 9E 7A    CALL  _GetMaxCh
    1939: 38 FD    ADD   SP,0xFD
    193B: 54 01    MOV   [X+1],A
(0138) 		//wait for next serial data
(0139) 		while(!New_Ser_Data);
    193D: 3C 76 00 CMP   [New_Ser_Data],0x0
    1940: AF FC    JZ    0x193D
(0140) 		//get highest channel found in data stream
(0141) 		max2=GetMaxCh(&max_pos2);
    1942: 5A 1C    MOV   [__r1],X
    1944: 06 1C 04 ADD   [__r1],0x4
    1947: 51 1D    MOV   A,[__r0]
    1949: 08       PUSH  A
    194A: 51 1C    MOV   A,[__r1]
    194C: 08       PUSH  A
    194D: 9E 64    CALL  _GetMaxCh
    194F: 38 FE    ADD   SP,0xFE
    1951: 54 02    MOV   [X+2],A
(0142) 		//if they are different we have more that 6 channel 
(0143) 		if(max2!=Max_Ch && Max_Ch && max2)
    1953: 52 02    MOV   A,[X+2]
    1955: 3B 01    CMP   A,[X+1]
    1957: A0 0E    JZ    0x1966
    1959: 3D 01 00 CMP   [X+1],0x0
    195C: A0 09    JZ    0x1966
    195E: 3D 02 00 CMP   [X+2],0x0
    1961: A0 04    JZ    0x1966
(0144) 			DSM_Is_11ms=TRUE;
    1963: 55 6F 01 MOV   [DSM_Is_11ms],0x1
(0145) 
(0146) 		//update max	
(0147) 		if(max2>Max_Ch)
    1966: 52 01    MOV   A,[X+1]
    1968: 3B 02    CMP   A,[X+2]
    196A: D0 09    JNC   0x1974
(0148) 			{
(0149) 			Max_Ch=max2;
    196C: 52 02    MOV   A,[X+2]
    196E: 54 01    MOV   [X+1],A
(0150) 			max_pos=max_pos2;
    1970: 52 04    MOV   A,[X+4]
    1972: 54 03    MOV   [X+3],A
(0151) 			}
(0152) 		//if channel numbers are missing in data stream we need to add them
(0153) 		if(!Max_Ch)
    1974: 3D 01 00 CMP   [X+1],0x0
    1977: B0 04    JNZ   0x197C
(0154) 			ADD_CH_Map=TRUE;
    1979: 55 75 01 MOV   [ADD_CH_Map],0x1
(0155) 
(0156) 		//determin Mode
(0157) 		DSM_Is_DSMX=((ser_databuf[0]&SPTX_DSMX_MODE)==SPTX_DSMX_MODE);
    197C: 51 87    MOV   A,[ser_databuf]
    197E: 21 08    AND   A,0x8
    1980: 39 08    CMP   A,0x8
    1982: 95 86    CALL  0x1F0A
    1984: 40       NOP   
(0158) 		DSM_Is_Forced=!((ser_databuf[0]&SPTX_NORM_MODE)==SPTX_NORM_MODE);
    1985: 51 87    MOV   A,[ser_databuf]
    1987: 21 10    AND   A,0x10
    1989: 39 10    CMP   A,0x10
    198B: A0 09    JZ    0x1995
    198D: 56 08 01 MOV   [X+8],0x1
    1990: 56 07 00 MOV   [X+7],0x0
    1993: 80 07    JMP   0x199B
    1995: 56 08 00 MOV   [X+8],0x0
    1998: 56 07 00 MOV   [X+7],0x0
    199B: 52 08    MOV   A,[X+8]
    199D: 53 6D    MOV   [DSM_Is_Forced],A
(0159) 	
(0160) 		//DSMX is always 11Bit
(0161) 		if(DSM_Is_DSMX || HighRes)
    199F: 3C 70 00 CMP   [DSM_Is_DSMX],0x0
    19A2: B0 06    JNZ   0x19A9
    19A4: 3C 77 00 CMP   [HighRes],0x0
    19A7: A0 04    JZ    0x19AC
(0162) 			DSM_Is_11Bit=TRUE;
    19A9: 55 6E 01 MOV   [DSM_Is_11Bit],0x1
(0163) 
(0164) 		//update channel number send out while bind 
(0165) 		if(Max_Ch>5)
    19AC: 50 05    MOV   A,0x5
    19AE: 3B 01    CMP   A,[X+1]
    19B0: D0 07    JNC   0x19B8
(0166) 			num_channels=Max_Ch+1;
    19B2: 52 01    MOV   A,[X+1]
    19B4: 01 01    ADD   A,0x1
    19B6: 53 72    MOV   [num_channels],A
(0167) 		dsm_Max_pos=max_pos;
    19B8: 52 03    MOV   A,[X+3]
    19BA: 53 69    MOV   [dsm_Max_pos],A
(0168) 			
(0169) #ifdef DEBUG
(0170) 		TX8SW_1_CPutString(" C:");
(0171) 		TX8SW_1_PutSHexByte(DSM_Is_DSMX);
(0172) 		TX8SW_1_PutSHexByte(DSM_Is_11Bit);
(0173) 		TX8SW_1_PutSHexByte(DSM_Is_11ms);
(0174) 		TX8SW_1_PutSHexByte(HighRes);
(0175) 		TX8SW_1_PutSHexByte(ADD_CH_Map);
(0176) 		TX8SW_1_PutSHexByte(Max_Ch);
(0177) 		TX8SW_1_PutSHexByte(dsm_Max_pos);
(0178) #endif
(0179) 	}
(0180) 	
(0181) 	if(ser_databuf[0]&SPTX_BIND_MODE)
    19BC: 47 87 80 TST   [ser_databuf],0x80
    19BF: A0 61    JZ    0x1A21
(0182) 	{
(0183) #ifdef DEBUG
(0184) 		TX8SW_1_CPutString("BIND ");
(0185) #endif
(0186) 		DSM_initialize_bind();
    19C1: 7C 0E C2 LCALL _DSM_initialize_bind
(0187) 		do
(0188) 			{
(0189) 			DSM_Cyclic();
    19C4: 7C 11 09 LCALL _DSM_Cyclic
(0190) 			}
(0191) 		//wait till binding is done
(0192) 		while(!DSM_BIND_DONE());
    19C7: 3C 71 00 CMP   [Bind_cnt],0x0
    19CA: BF F9    JNZ   0x19C4
(0193) 		
(0194) 		New_Ser_Data=FALSE;
    19CC: 55 76 00 MOV   [New_Ser_Data],0x0
(0195) 		
(0196) 		//save configuration to FLASH
(0197) 		config=(DSM_Is_11Bit?OPTION_11BIT:0)|(DSM_Is_11ms?OPTION_11MS:0)|(DSM_Is_DSMX?OPTION_DSMX:0);
    19CF: 3C 6E 00 CMP   [DSM_Is_11Bit],0x0
    19D2: A0 09    JZ    0x19DC
    19D4: 56 02 04 MOV   [X+2],0x4
    19D7: 56 01 00 MOV   [X+1],0x0
    19DA: 80 07    JMP   0x19E2
    19DC: 56 02 00 MOV   [X+2],0x0
    19DF: 56 01 00 MOV   [X+1],0x0
    19E2: 3C 6F 00 CMP   [DSM_Is_11ms],0x0
    19E5: A0 09    JZ    0x19EF
    19E7: 56 04 02 MOV   [X+4],0x2
    19EA: 56 03 00 MOV   [X+3],0x0
    19ED: 80 07    JMP   0x19F5
    19EF: 56 04 00 MOV   [X+4],0x0
    19F2: 56 03 00 MOV   [X+3],0x0
    19F5: 3C 70 00 CMP   [DSM_Is_DSMX],0x0
    19F8: A0 09    JZ    0x1A02
    19FA: 56 06 01 MOV   [X+6],0x1
    19FD: 56 05 00 MOV   [X+5],0x0
    1A00: 80 07    JMP   0x1A08
    1A02: 56 06 00 MOV   [X+6],0x0
    1A05: 56 05 00 MOV   [X+5],0x0
    1A08: 52 02    MOV   A,[X+2]
    1A0A: 2B 04    OR    A,[X+4]
    1A0C: 53 1C    MOV   [__r1],A
    1A0E: 52 06    MOV   A,[X+6]
    1A10: 2C 1C    OR    [__r1],A
    1A12: 51 1C    MOV   A,[__r1]
    1A14: 54 00    MOV   [X+0],A
(0198) #ifdef DEBUG
(0199) 		TX8SW_1_PutSHexByte(config);
(0200) 		TX8SW_1_CPutString("SAVE ");
(0201) #endif
(0202) 		SaveConfig(config,ModellNr);
    1A16: 51 74    MOV   A,[ModellNr]
    1A18: 08       PUSH  A
    1A19: 52 00    MOV   A,[X+0]
    1A1B: 08       PUSH  A
    1A1C: 7C 09 85 LCALL __UserModules_end|_FlashReadBlock|_SaveConfig|__text_start|_SaveConfig
    1A1F: 38 FE    ADD   SP,0xFE
(0203) 	}
(0204) //read config from flash
(0205) #ifdef DEBUG
(0206) 	config=(DSM_Is_11Bit?OPTION_11BIT:0)|(DSM_Is_11ms?OPTION_11MS:0)|(DSM_Is_DSMX?OPTION_DSMX:0);
(0207) #else
(0208) 	config=ReadConfig(ModellNr);
    1A21: 51 74    MOV   A,[ModellNr]
    1A23: 08       PUSH  A
    1A24: 7C 09 D3 LCALL _ReadConfig
    1A27: 38 FF    ADD   SP,0xFF
    1A29: 54 00    MOV   [X+0],A
(0209) #endif
(0210) 
(0211) #ifdef DEBUG
(0212) 	TX8SW_1_CPutString("RUN ");
(0213) 	TX8SW_1_PutSHexByte(config);
(0214) 	//DIAG_OUT1_Off();
(0215) #endif
(0216) 	//determin config based on value from flash
(0217) 	DSM_Is_11ms=((config&OPTION_11MS)==OPTION_11MS);
    1A2B: 52 00    MOV   A,[X+0]
    1A2D: 21 02    AND   A,0x2
    1A2F: 39 02    CMP   A,0x2
    1A31: B0 09    JNZ   0x1A3B
    1A33: 56 02 01 MOV   [X+2],0x1
    1A36: 56 01 00 MOV   [X+1],0x0
    1A39: 80 07    JMP   0x1A41
    1A3B: 56 02 00 MOV   [X+2],0x0
    1A3E: 56 01 00 MOV   [X+1],0x0
    1A41: 52 02    MOV   A,[X+2]
    1A43: 53 6F    MOV   [DSM_Is_11ms],A
(0218) 	DSM_Is_11Bit=((config&OPTION_11BIT)==OPTION_11BIT);
    1A45: 52 00    MOV   A,[X+0]
    1A47: 21 04    AND   A,0x4
    1A49: 39 04    CMP   A,0x4
    1A4B: B0 09    JNZ   0x1A55
    1A4D: 56 04 01 MOV   [X+4],0x1
    1A50: 56 03 00 MOV   [X+3],0x0
    1A53: 80 07    JMP   0x1A5B
    1A55: 56 04 00 MOV   [X+4],0x0
    1A58: 56 03 00 MOV   [X+3],0x0
    1A5B: 52 04    MOV   A,[X+4]
    1A5D: 53 6E    MOV   [DSM_Is_11Bit],A
(0219) 	DSM_Is_DSMX=((config&OPTION_DSMX)==OPTION_DSMX);
    1A5F: 52 00    MOV   A,[X+0]
    1A61: 21 01    AND   A,0x1
    1A63: 39 01    CMP   A,0x1
    1A65: 94 A3    CALL  0x1F0A
    1A67: 40       NOP   
(0220) 	//prepare transmitting
(0221) 	DSM_LoadTransmitMode();
    1A68: 7C 16 88 LCALL _DSM_LoadTransmitMode
(0222) 	New_Ser_Data=FALSE;
    1A6B: 55 76 00 MOV   [New_Ser_Data],0x0
    1A6E: 80 1E    JMP   0x1A8D
(0223) 	while (1)
(0224) 	{
(0225) 	DSM_Cyclic();
    1A70: 7C 11 09 LCALL _DSM_Cyclic
(0226) 
(0227) 	if(New_Ser_Data)
    1A73: 3C 76 00 CMP   [New_Ser_Data],0x0
    1A76: A0 16    JZ    0x1A8D
(0228) 		{
(0229) 		New_Ser_Data=FALSE;
    1A78: 55 76 00 MOV   [New_Ser_Data],0x0
(0230) 		
(0231) 		DSM_NewSerialData();
    1A7B: 7C 12 84 LCALL _DSM_NewSerialData
(0232) 	
(0233) 		//update TX power
(0234) 		DSM_SetRangeCheck(ser_databuf[0]&SPTX_RANGE_CHECK);
    1A7E: 51 87    MOV   A,[ser_databuf]
    1A80: 21 20    AND   A,0x20
    1A82: 08       PUSH  A
    1A83: 7C 0C 66 LCALL _DSM_SetRangeCheck
    1A86: 38 FF    ADD   SP,0xFF
(0235) 
(0236) 		LED_1_Invert(); 
    1A88: 10       PUSH  X
    1A89: 7C 05 11 LCALL _LED_1_Invert
    1A8C: 20       POP   X
(0237) 		}
(0238) 	}
    1A8D: 8F E2    JMP   0x1A70
(0239) }
FILE: C:\Users\Ralf\DOCUME~1\DSM_SA~1\DSM_SA~1\DSM_SA~1\serial.c
(0001) /*this module contains the code for serial reciving the data from the Transmitter
(0002) * a Buffer of 16 byte ist used to store recived data
(0003) * most work is doen within the interrupt sevice routine
(0004) *datarate is set in the chip design to 115200 by the devider for VC3
(0005) *the timer module will call the ser_Tic function once per ms
(0006) *if for 5ms no more chars are recived the index is reset to zerro
(0007) */
(0008) 
(0009) #include <m8c.h>        // part specific constants and macros
(0010) #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
(0011) #include "serial.h"
(0012) 
(0013) 
(0014) 
(0015) BYTE ser_databuf[SER_BUFFER_SIZE]; //the buffer to hold the recived data
(0016) BYTE ser_idx=0;						//index into buffer
(0017) BYTE ser_status=0;					//reciver status
(0018) BYTE ser_to=0;						//timeout variable to determin end of transmision
(0019) 
(0020) ser_callback_t serial_cb;
(0021) 
(0022) void SerialSetCallback(ser_callback_t cb)
(0023) {
_SerialSetCallback:
  cb                   --> X-5
    1A94: 10       PUSH  X
    1A95: 4F       MOV   X,SP
(0024) 	serial_cb=cb;
    1A96: 52 FC    MOV   A,[X-4]
    1A98: 53 86    MOV   [serial_cb+1],A
    1A9A: 52 FB    MOV   A,[X-5]
    1A9C: 53 85    MOV   [serial_cb],A
    1A9E: 20       POP   X
    1A9F: 7F       RET   
(0025) }
(0026) 
(0027) //initialize the RX8 module
(0028) void SerialRX_Init(void )
(0029) {
_SerialRX_Init:
  n                    --> X+0
    1AA0: 10       PUSH  X
    1AA1: 4F       MOV   X,SP
    1AA2: 38 02    ADD   SP,0x2
(0030) 	int n;
(0031) 	serial_cb=0;
    1AA4: 55 86 36 MOV   [serial_cb+1],0x36
    1AA7: 55 85 03 MOV   [serial_cb],0x3
(0032) 	RX8_1_EnableInt(); //enable hardwar
    1AAA: 10       PUSH  X
    1AAB: 7C 04 D6 LCALL _RX8_1_EnableInt
    1AAE: 20       POP   X
(0033) 	//clear buffer
(0034) 	for (n=0;n<16;n++)
    1AAF: 56 01 00 MOV   [X+1],0x0
    1AB2: 56 00 00 MOV   [X+0],0x0
(0035) 		ser_databuf[n]=0;
    1AB5: 52 01    MOV   A,[X+1]
    1AB7: 01 87    ADD   A,0x87
    1AB9: 53 1C    MOV   [__r1],A
    1ABB: 50 00    MOV   A,0x0
    1ABD: 3F 1C    MVI   [__r1],A
    1ABF: 77 01    INC   [X+1]
    1AC1: 0F 00 00 ADC   [X+0],0x0
    1AC4: 52 01    MOV   A,[X+1]
    1AC6: 11 10    SUB   A,0x10
    1AC8: 52 00    MOV   A,[X+0]
    1ACA: 31 80    XOR   A,0x80
    1ACC: 19 80    SBB   A,0x80
    1ACE: CF E6    JC    0x1AB5
(0036) 	//set index to 0
(0037) 	ser_idx=0;
    1AD0: 55 08 00 MOV   [ser_idx],0x0
(0038) 	//enable interrupts
(0039) 	M8C_EnableGInt;
    1AD3: 71 01    OR    F,0x1
(0040) 	RX8_1_EnableInt();
    1AD5: 10       PUSH  X
    1AD6: 7C 04 D6 LCALL _RX8_1_EnableInt
(0041) 	//start reciving
(0042) 	RX8_1_Start(RX8_PARITY_NONE);
    1AD9: 50 00    MOV   A,0x0
    1ADB: 7C 04 DA LCALL _RX8_1_Start|_RX8_1_DisableInt
    1ADE: 20       POP   X
    1ADF: 38 FE    ADD   SP,0xFE
    1AE1: 20       POP   X
    1AE2: 7F       RET   
(0043) }
(0044) 
(0045) //check if there is a complete package avaliable
(0046) BOOL SerialDataReady(void )
(0047) {
(0048) 	//check if status contains anny error bits
(0049) 	if (0xF0&SER_GET_STATUS())
_SerialDataReady:
    1AE3: 47 09 F0 TST   [ser_status],0xF0
    1AE6: A0 0E    JZ    0x1AF5
(0050) 	{	//reset in case of an error
(0051) 		SER_CLEAR_ERROR();
    1AE8: 26 09 F0 AND   [ser_status],0xF0
(0052) 		SER_RESET();
    1AEB: 55 09 00 MOV   [ser_status],0x0
    1AEE: 55 08 00 MOV   [ser_idx],0x0
(0053) 		return 0;
    1AF1: 50 00    MOV   A,0x0
    1AF3: 80 0C    JMP   0x1B00
(0054) 	}
(0055) 	//ckeck if buffer is full
(0056) 	if (SER_PEAK())
    1AF5: 47 09 01 TST   [ser_status],0x1
    1AF8: A0 05    JZ    0x1AFE
(0057) 	{
(0058) 		return 1;
    1AFA: 50 01    MOV   A,0x1
    1AFC: 80 03    JMP   0x1B00
(0059) 	}
(0060) return 0;
    1AFE: 50 00    MOV   A,0x0
    1B00: 7F       RET   
(0061) }
(0062) 
(0063) 
(0064) //this is called from the system timer once per 1,953125 ms
(0065) //ser_to is reset to zerro each time a char is recived by the serial interupt service
(0066) //if there has not been anny char recived for 3 consecutive calls then reset the index
(0067) void ser_Tic(void )
(0068) {
(0069) 	ser_to++; //increment timeout
_ser_Tic:
    1B01: 76 0A    INC   [ser_to]
(0070) 	if (ser_idx!=0 && ser_to > 3) //to we have a timeout (>6ms)
    1B03: 3C 08 00 CMP   [ser_idx],0x0
    1B06: A0 0A    JZ    0x1B11
    1B08: 50 03    MOV   A,0x3
    1B0A: 3A 0A    CMP   A,[ser_to]
    1B0C: D0 04    JNC   0x1B11
(0071) 		ser_idx=0; //reset index
    1B0E: 55 08 00 MOV   [ser_idx],0x0
    1B11: 7F       RET   
(0072) }
(0073) 
(0074) #define RX8_1_RX_ENABLE 1
(0075) #pragma interrupt_handler RX8_1_Interrupt
(0076) 
(0077) //interrupt handler called if a char is recived
(0078) void RX8_1_Interrupt(void )
(0079) {
_RX8_1_Interrupt:
    1B12: 08       PUSH  A
    1B13: 51 1D    MOV   A,[__r0]
    1B15: 08       PUSH  A
    1B16: 51 1C    MOV   A,[__r1]
    1B18: 08       PUSH  A
    1B19: 51 1B    MOV   A,[__r2]
    1B1B: 08       PUSH  A
    1B1C: 51 1A    MOV   A,[__r3]
    1B1E: 08       PUSH  A
    1B1F: 51 19    MOV   A,[__r4]
    1B21: 08       PUSH  A
    1B22: 51 18    MOV   A,[__r5]
    1B24: 08       PUSH  A
    1B25: 51 17    MOV   A,[__r6]
    1B27: 08       PUSH  A
    1B28: 51 16    MOV   A,[__r7]
    1B2A: 08       PUSH  A
    1B2B: 51 15    MOV   A,[__r8]
    1B2D: 08       PUSH  A
    1B2E: 51 14    MOV   A,[__r9]
    1B30: 08       PUSH  A
    1B31: 51 13    MOV   A,[__r10]
    1B33: 08       PUSH  A
    1B34: 51 12    MOV   A,[__r11]
    1B36: 08       PUSH  A
    1B37: 51 11    MOV   A,[__rX]
    1B39: 08       PUSH  A
    1B3A: 51 10    MOV   A,[__rY]
    1B3C: 08       PUSH  A
    1B3D: 51 0F    MOV   A,[__rZ]
    1B3F: 08       PUSH  A
(0080) 	static BYTE ser_c; //the char buffer, defined as static to save stack space
(0081) 	
(0082) 	ser_to=0; //reset timeout
    1B40: 55 0A 00 MOV   [ser_to],0x0
    1B43: 80 83    JMP   0x1BC7
(0083) 
(0084) 
(0085) 	//if a char is recived 
(0086) 	//we use while instead of if because it can happen that another char is recived while we are here, 
(0087) 	//in that case no extra interrop for that one will occour
(0088) 	while (RX8_RX_COMPLETE & RX8_1_CONTROL_REG)
(0089) 	{	//get the char
(0090) 		ser_c=RX8_1_RX_BUFFER_REG;
    1B45: 5D 2E    MOV   A,REG[0x2E]
    1B47: 53 84    MOV   [Ch_Data+12],A
(0091) 		//if we have no error store the char
(0092) 		if (!(RX8_1_RX_ERROR & RX8_1_CONTROL_REG))
    1B49: 5D 2F    MOV   A,REG[0x2F]
    1B4B: 53 1D    MOV   [__r0],A
    1B4D: 47 1D E0 TST   [__r0],0xE0
    1B50: B0 55    JNZ   0x1BA6
(0093) 		{
(0094) 			//if there is still room in bufffer
(0095) 			if (ser_idx<SER_BUFFER_SIZE)
    1B52: 3C 08 0E CMP   [ser_idx],0xE
    1B55: D0 4B    JNC   0x1BA1
(0096) 			{//store data
(0097) 				ser_databuf[ser_idx++]=ser_c;
    1B57: 5F 1C 08 MOV   [__r1],[ser_idx]
    1B5A: 55 1D 00 MOV   [__r0],0x0
    1B5D: 51 1C    MOV   A,[__r1]
    1B5F: 01 01    ADD   A,0x1
    1B61: 53 08    MOV   [ser_idx],A
    1B63: 06 1C 87 ADD   [__r1],0x87
    1B66: 0E 1D 00 ADC   [__r0],0x0
    1B69: 51 84    MOV   A,[Ch_Data+12]
    1B6B: 3F 1C    MVI   [__r1],A
(0098) 				//check if buffer is full now
(0099) 				if (ser_idx==SER_BUFFER_SIZE)
    1B6D: 3C 08 0E CMP   [ser_idx],0xE
    1B70: B0 5F    JNZ   0x1BD0
(0100) 				{
(0101) 					ser_status|=SER_BUFFERFULL; //flag that we are done
    1B72: 2E 09 01 OR    [ser_status],0x1
(0102) 					if(serial_cb)
    1B75: 5F 1C 86 MOV   [__r1],[serial_cb+1]
    1B78: 51 85    MOV   A,[serial_cb]
    1B7A: 10       PUSH  X
    1B7B: 58 1C    MOV   X,[__r1]
    1B7D: 08       PUSH  A
    1B7E: 28       ROMX  
    1B7F: 53 1D    MOV   [__r0],A
    1B81: 18       POP   A
    1B82: 75       INC   X
    1B83: 09 00    ADC   A,0x0
    1B85: 28       ROMX  
    1B86: 20       POP   X
    1B87: 3C 1D 00 CMP   [__r0],0x0
    1B8A: B0 05    JNZ   0x1B90
    1B8C: 39 00    CMP   A,0x0
    1B8E: A0 41    JZ    0x1BD0
(0103) 					{
(0104) 						serial_cb();
    1B90: 5F 1C 86 MOV   [__r1],[serial_cb+1]
    1B93: 5F 1D 85 MOV   [__r0],[serial_cb]
    1B96: 10       PUSH  X
    1B97: 58 1C    MOV   X,[__r1]
    1B99: 51 1D    MOV   A,[__r0]
    1B9B: 7C 1E D5 LCALL __plcall
    1B9E: 20       POP   X
(0105) 						return;
    1B9F: 80 30    JMP   0x1BD0
(0106) 					}
(0107) 				}
(0108) 			}
(0109) 			else 
(0110) 				ser_status|=SER_BUFOVERRUN_ERROR; //flag a buffer overrun
    1BA1: 2E 09 10 OR    [ser_status],0x10
(0111) 			return ;
    1BA4: 80 2B    JMP   0x1BD0
(0112) 		}
(0113) 		//if we got anny error
(0114) 		if(RX8_1_RX_ERROR & RX8_1_CONTROL_REG)
    1BA6: 5D 2F    MOV   A,REG[0x2F]
    1BA8: 53 1D    MOV   [__r0],A
    1BAA: 47 1D E0 TST   [__r0],0xE0
    1BAD: A0 19    JZ    0x1BC7
(0115) 		{
(0116) 			ser_idx=0; //reset index , trash all we have so far
    1BAF: 55 08 00 MOV   [ser_idx],0x0
(0117) 			ser_status|=RX8_1_CONTROL_REG & RX8_1_RX_ERROR; //update status
    1BB2: 5D 2F    MOV   A,REG[0x2F]
    1BB4: 21 E0    AND   A,0xE0
    1BB6: 2C 09    OR    [ser_status],A
(0118) 			//special case framing error
(0119) 			if (RX8_1_RX_FRAMING_ERROR & RX8_1_CONTROL_REG)
    1BB8: 5D 2F    MOV   A,REG[0x2F]
    1BBA: 53 1D    MOV   [__r0],A
    1BBC: 47 1D 20 TST   [__r0],0x20
    1BBF: A0 07    JZ    0x1BC7
(0120) 			{
(0121) 				RX8_1_CONTROL_REG&=~RX8_1_RX_ENABLE; //disable RX
    1BC1: 41 2F FE AND   REG[0x2F],0xFE
(0122) 				RX8_1_CONTROL_REG|=RX8_1_RX_ENABLE; //enable RX
    1BC4: 43 2F 01 OR    REG[0x2F],0x1
(0123) 			}
(0124) 		}
(0125) 	}
    1BC7: 5D 2F    MOV   A,REG[0x2F]
(0126) } //end of ISRFILE: C:\Users\Ralf\DOCUME~1\DSM_SA~1\DSM_SA~1\DSM_SA~1\timer.c
(0001) #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
(0002) #include "timer.h"
(0003) #include "serial.h"
(0004) 
(0005) WORD systic=0;   //will be incremented once per 1,953125 ms
(0006) WORD cnt_last;
(0007) tmr_callback_t timer_cb=0;
(0008) 
(0009) //a delay
(0010) void Timer_Wait_ms(BYTE ms)
(0011) {
_Timer_Wait_ms:
  ms                   --> X-4
    1BFF: 10       PUSH  X
    1C00: 4F       MOV   X,SP
(0012) SleepTimer_1_TickWait(ms>>2);
    1C01: 52 FC    MOV   A,[X-4]
    1C03: 67       ASR   A
    1C04: 67       ASR   A
    1C05: 21 3F    AND   A,0x3F
    1C07: 10       PUSH  X
    1C08: 7C 04 C3 LCALL _SleepTimer_1_SetInterval|_SleepTimer_1_Stop|SleepTimer_1_TickWait|_SleepTimer_1_TickWait
    1C0B: 20       POP   X
    1C0C: 20       POP   X
    1C0D: 7F       RET   
(0013) }
(0014) 
(0015) void Timer_Enable(BOOL val)
(0016) {
_Timer_Enable:
  val                  --> X-4
    1C0E: 10       PUSH  X
    1C0F: 4F       MOV   X,SP
    1C10: 38 02    ADD   SP,0x2
(0017) Counter16_1_INPUT_LSB_REG=val?0x16:0x6;
    1C12: 3D FC 00 CMP   [X-4],0x0
    1C15: A0 09    JZ    0x1C1F
    1C17: 56 01 16 MOV   [X+1],0x16
    1C1A: 56 00 00 MOV   [X+0],0x0
    1C1D: 80 07    JMP   0x1C25
    1C1F: 56 01 06 MOV   [X+1],0x6
    1C22: 56 00 00 MOV   [X+0],0x0
    1C25: 52 01    MOV   A,[X+1]
    1C27: 71 10    OR    F,0x10
    1C29: 60 21    MOV   REG[0x21],A
    1C2B: 70 CF    AND   F,0xCF
    1C2D: 38 FE    ADD   SP,0xFE
    1C2F: 20       POP   X
    1C30: 7F       RET   
(0018) }
(0019) 
(0020) void Timer_init (void)
(0021) {
(0022) timer_cb=0;
_Timer_init:
    1C31: 55 0E 38 MOV   [timer_cb+1],0x38
    1C34: 55 0D 03 MOV   [timer_cb],0x3
(0023) SleepTimer_1_EnableInt();
    1C37: 10       PUSH  X
    1C38: 7C 04 B2 LCALL _SleepTimer_1_EnableInt
(0024) SleepTimer_1_Start();
    1C3B: 7C 04 B6 LCALL _SleepTimer_1_DisableInt|SleepTimer_1_Start|_SleepTimer_1_Start
(0025) Counter16_1_EnableInt();
    1C3E: 7C 05 4C LCALL _Counter16_1_EnableInt
    1C41: 20       POP   X
(0026) Timer_Enable(TRUE);
    1C42: 50 01    MOV   A,0x1
    1C44: 08       PUSH  A
    1C45: 9F C7    CALL  _Timer_Enable
    1C47: 38 FF    ADD   SP,0xFF
    1C49: 7F       RET   
(0027) }
(0028) 
(0029) 
(0030) 
(0031) WORD Timer_GetTime(void)
(0032) {
_Timer_GetTime:
  time                 --> X+0
    1C4A: 10       PUSH  X
    1C4B: 4F       MOV   X,SP
    1C4C: 38 02    ADD   SP,0x2
(0033) 	WORD time;
(0034) 	Timer_Enable(FALSE);
    1C4E: 50 00    MOV   A,0x0
    1C50: 08       PUSH  A
    1C51: 9F BB    CALL  _Timer_Enable
    1C53: 38 FF    ADD   SP,0xFF
(0035) 	time=Counter16_1_wReadCounter();
    1C55: 10       PUSH  X
    1C56: 7C 05 5E LCALL _Counter16_1_wReadCounter|_wCounter16_1_ReadCounter|Counter16_1_wReadCounter|wCounter16_1_ReadCounter|wCounter16_1_ReadCompareValue|_Counter16_1_wReadCompareValue|_Counter16_1_WriteCompareValue|_wCounter16_1_ReadCompareValue
    1C59: 5A 1D    MOV   [__r0],X
    1C5B: 20       POP   X
    1C5C: 54 01    MOV   [X+1],A
    1C5E: 51 1D    MOV   A,[__r0]
    1C60: 54 00    MOV   [X+0],A
(0036) 	Timer_Enable(TRUE);
    1C62: 50 01    MOV   A,0x1
    1C64: 08       PUSH  A
    1C65: 9F A7    CALL  _Timer_Enable
    1C67: 38 FF    ADD   SP,0xFF
(0037) 	return time;
    1C69: 52 01    MOV   A,[X+1]
    1C6B: 53 1C    MOV   [__r1],A
    1C6D: 52 00    MOV   A,[X+0]
    1C6F: 53 1D    MOV   [__r0],A
    1C71: 38 FE    ADD   SP,0xFE
    1C73: 20       POP   X
    1C74: 7F       RET   
(0038) }
(0039) 
(0040) void Timer_SetCallback(tmr_callback_t cb_fn)
(0041) {
_Timer_SetCallback:
  cb_fn                --> X-5
    1C75: 10       PUSH  X
    1C76: 4F       MOV   X,SP
(0042) 	timer_cb=cb_fn;
    1C77: 52 FC    MOV   A,[X-4]
    1C79: 53 0E    MOV   [timer_cb+1],A
    1C7B: 52 FB    MOV   A,[X-5]
    1C7D: 53 0D    MOV   [timer_cb],A
    1C7F: 20       POP   X
    1C80: 7F       RET   
(0043) }
(0044) 
(0045) #pragma interrupt_handler Sleep_Timer_Interrupt
(0046) 
(0047) //interrupt handler on TC of LSB
(0048) void Sleep_Timer_Interrupt(void )
(0049) {
_Sleep_Timer_Interrupt:
    1C81: 08       PUSH  A
    1C82: 51 1D    MOV   A,[__r0]
    1C84: 08       PUSH  A
    1C85: 51 1C    MOV   A,[__r1]
    1C87: 08       PUSH  A
    1C88: 51 1B    MOV   A,[__r2]
    1C8A: 08       PUSH  A
    1C8B: 51 1A    MOV   A,[__r3]
    1C8D: 08       PUSH  A
    1C8E: 51 19    MOV   A,[__r4]
    1C90: 08       PUSH  A
    1C91: 51 18    MOV   A,[__r5]
    1C93: 08       PUSH  A
    1C94: 51 17    MOV   A,[__r6]
    1C96: 08       PUSH  A
    1C97: 51 16    MOV   A,[__r7]
    1C99: 08       PUSH  A
    1C9A: 51 15    MOV   A,[__r8]
    1C9C: 08       PUSH  A
    1C9D: 51 14    MOV   A,[__r9]
    1C9F: 08       PUSH  A
    1CA0: 51 13    MOV   A,[__r10]
    1CA2: 08       PUSH  A
    1CA3: 51 12    MOV   A,[__r11]
    1CA5: 08       PUSH  A
    1CA6: 51 11    MOV   A,[__rX]
    1CA8: 08       PUSH  A
    1CA9: 51 10    MOV   A,[__rY]
    1CAB: 08       PUSH  A
    1CAC: 51 0F    MOV   A,[__rZ]
    1CAE: 08       PUSH  A
(0050) 	systic++;
    1CAF: 76 0C    INC   [systic+1]
    1CB1: 0E 0B 00 ADC   [systic],0x0
(0051) 	ser_Tic();
    1CB4: 7C 1B 01 LCALL _ser_Tic
    1CB7: 18       POP   A
    1CB8: 53 0F    MOV   [__rZ],A
    1CBA: 18       POP   A
    1CBB: 53 10    MOV   [__rY],A
    1CBD: 18       POP   A
    1CBE: 53 11    MOV   [__rX],A
    1CC0: 18       POP   A
    1CC1: 53 12    MOV   [__r11],A
    1CC3: 18       POP   A
    1CC4: 53 13    MOV   [__r10],A
    1CC6: 18       POP   A
    1CC7: 53 14    MOV   [__r9],A
    1CC9: 18       POP   A
    1CCA: 53 15    MOV   [__r8],A
    1CCC: 18       POP   A
    1CCD: 53 16    MOV   [__r7],A
    1CCF: 18       POP   A
    1CD0: 53 17    MOV   [__r6],A
    1CD2: 18       POP   A
    1CD3: 53 18    MOV   [__r5],A
    1CD5: 18       POP   A
    1CD6: 53 19    MOV   [__r4],A
    1CD8: 18       POP   A
    1CD9: 53 1A    MOV   [__r3],A
    1CDB: 18       POP   A
    1CDC: 53 1B    MOV   [__r2],A
    1CDE: 18       POP   A
    1CDF: 53 1C    MOV   [__r1],A
    1CE1: 18       POP   A
    1CE2: 53 1D    MOV   [__r0],A
    1CE4: 18       POP   A
    1CE5: 7E       RETI  
(0052) }
(0053) 
(0054) #pragma interrupt_handler Counter16_1_Interrupt
(0055) 
(0056) void Counter16_1_Interrupt(void)
(0057) {
_Counter16_1_Interrupt:
    1CE6: 08       PUSH  A
    1CE7: 51 1D    MOV   A,[__r0]
    1CE9: 08       PUSH  A
    1CEA: 51 1C    MOV   A,[__r1]
    1CEC: 08       PUSH  A
    1CED: 51 1B    MOV   A,[__r2]
    1CEF: 08       PUSH  A
    1CF0: 51 1A    MOV   A,[__r3]
    1CF2: 08       PUSH  A
    1CF3: 51 19    MOV   A,[__r4]
    1CF5: 08       PUSH  A
    1CF6: 51 18    MOV   A,[__r5]
    1CF8: 08       PUSH  A
    1CF9: 51 17    MOV   A,[__r6]
    1CFB: 08       PUSH  A
    1CFC: 51 16    MOV   A,[__r7]
    1CFE: 08       PUSH  A
    1CFF: 51 15    MOV   A,[__r8]
    1D01: 08       PUSH  A
    1D02: 51 14    MOV   A,[__r9]
    1D04: 08       PUSH  A
    1D05: 51 13    MOV   A,[__r10]
    1D07: 08       PUSH  A
    1D08: 51 12    MOV   A,[__r11]
    1D0A: 08       PUSH  A
    1D0B: 51 11    MOV   A,[__rX]
    1D0D: 08       PUSH  A
    1D0E: 51 10    MOV   A,[__rY]
    1D10: 08       PUSH  A
    1D11: 51 0F    MOV   A,[__rZ]
    1D13: 08       PUSH  A
(0058) 	if(timer_cb!=0)
    1D14: 5F 1C 0E MOV   [__r1],[timer_cb+1]
    1D17: 51 0D    MOV   A,[timer_cb]
    1D19: 10       PUSH  X
    1D1A: 58 1C    MOV   X,[__r1]
    1D1C: 08       PUSH  A
    1D1D: 28       ROMX  
    1D1E: 53 1D    MOV   [__r0],A
    1D20: 18       POP   A
    1D21: 75       INC   X
    1D22: 09 00    ADC   A,0x0
    1D24: 28       ROMX  
    1D25: 20       POP   X
    1D26: 3C 1D 00 CMP   [__r0],0x0
    1D29: B0 05    JNZ   0x1D2F
    1D2B: 39 00    CMP   A,0x0
    1D2D: A0 10    JZ    0x1D3E
(0059) 		timer_cb();
    1D2F: 5F 1C 0E MOV   [__r1],[timer_cb+1]
    1D32: 5F 1D 0D MOV   [__r0],[timer_cb]
    1D35: 10       PUSH  X
    1D36: 58 1C    MOV   X,[__r1]
    1D38: 51 1D    MOV   A,[__r0]
    1D3A: 7C 1E D5 LCALL __plcall
    1D3D: 20       POP   X
    1D3E: 18       POP   A
    1D3F: 53 0F    MOV   [__rZ],A
    1D41: 18       POP   A
    1D42: 53 10    MOV   [__rY],A
    1D44: 18       POP   A
    1D45: 53 11    MOV   [__rX],A
    1D47: 18       POP   A
    1D48: 53 12    MOV   [__r11],A
    1D4A: 18       POP   A
    1D4B: 53 13    MOV   [__r10],A
    1D4D: 18       POP   A
    1D4E: 53 14    MOV   [__r9],A
    1D50: 18       POP   A
    1D51: 53 15    MOV   [__r8],A
    1D53: 18       POP   A
    1D54: 53 16    MOV   [__r7],A
    1D56: 18       POP   A
    1D57: 53 17    MOV   [__r6],A
    1D59: 18       POP   A
    1D5A: 53 18    MOV   [__r5],A
    1D5C: 18       POP   A
    1D5D: 53 19    MOV   [__r4],A
    1D5F: 18       POP   A
    1D60: 53 1A    MOV   [__r3],A
    1D62: 18       POP   A
    1D63: 53 1B    MOV   [__r2],A
    1D65: 18       POP   A
    1D66: 53 1C    MOV   [__r1],A
    1D68: 18       POP   A
    1D69: 53 1D    MOV   [__r0],A
    1D6B: 18       POP   A
    1D6C: 7E       RETI  
FILE: lib\psocgpioint.asm               (0001) ;  Generated by PSoC Designer 5.4.3191
                                        (0002) ;
                                        (0003) ;;*****************************************************************************
                                        (0004) ;;*****************************************************************************
                                        (0005) ;;  FILENAME: PSoCGPIOINT.asm
                                        (0006) ;;   Version: 2.0.0.20, Updated on 2003/07/17 at 12:10:35
                                        (0007) ;;  @PSOC_VERSION
                                        (0008) ;;
                                        (0009) ;;  DESCRIPTION: PSoC GPIO Interrupt Service Routine
                                        (0010) ;;-----------------------------------------------------------------------------
                                        (0011) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0012) ;;*****************************************************************************
                                        (0013) ;;*****************************************************************************
                                        (0014) 
                                        (0015) include "m8c.inc"
                                        (0016) include "PSoCGPIOINT.inc"
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export   PSoC_GPIO_ISR
                                        (0022) 
                                        (0023) 
                                        (0024) ;-----------------------------------------------
                                        (0025) ;  Constant Definitions
                                        (0026) ;-----------------------------------------------
                                        (0027) 
                                        (0028) 
                                        (0029) ;-----------------------------------------------
                                        (0030) ; Variable Allocation
                                        (0031) ;-----------------------------------------------
                                        (0032) 	
                                        (0033) 
                                        (0034) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0035) ;---------------------------------------------------
                                        (0036) ; Insert your custom declarations below this banner
                                        (0037) ;---------------------------------------------------
                                        (0038) 
                                        (0039) ;---------------------------------------------------
                                        (0040) ; Insert your custom declarations above this banner
                                        (0041) ;---------------------------------------------------
                                        (0042) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0043) 
                                        (0044) 
                                        (0045) ;-----------------------------------------------------------------------------
                                        (0046) ;  FUNCTION NAME: PSoC_GPIO_ISR
                                        (0047) ;
                                        (0048) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0049) ;
                                        (0050) ;-----------------------------------------------------------------------------
                                        (0051) ;
                                        (0052) PSoC_GPIO_ISR:
                                        (0053) 
                                        (0054) 
                                        (0055)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0056)    ;---------------------------------------------------
                                        (0057)    ; Insert your custom code below this banner
                                        (0058)    ;---------------------------------------------------
1D6D: 7D 0A 0B LJMP  _GPIO_ISR          (0059)    ljmp _GPIO_ISR
                                        (0060)    ;---------------------------------------------------
                                        (0061)    ; Insert your custom code above this banner
                                        (0062)    ;---------------------------------------------------
                                        (0063)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0064) 
1D70: 7E       RETI                     (0065)    reti
                                        (0066) 
                                        (0067) 
                                        (0068) ; end of file PSoCGPIOINT.asm
__plcall:
    1ED5: 53 11    MOV   [__rX],A
    1ED7: 28       ROMX  
    1ED8: 08       PUSH  A
    1ED9: 51 11    MOV   A,[__rX]
    1EDB: 75       INC   X
    1EDC: 09 00    ADC   A,0x0
    1EDE: 28       ROMX  
    1EDF: 08       PUSH  A
    1EE0: 7F       RET   
    1EE1: 30       HALT  
<created procedures>:
    1EE2: 5F 1C 73 MOV   [__r1],[num_channels+1]
    1EE5: 55 1D 00 MOV   [__r0],0x0
    1EE8: 65 1C    ASL   [__r1]
    1EEA: 6B 1D    RLC   [__r0]
    1EEC: 51 1C    MOV   A,[__r1]
    1EEE: 01 8A    ADD   A,0x8A
    1EF0: 53 1A    MOV   [__r3],A
    1EF2: 3E 1A    MVI   A,[__r3]
    1EF4: 53 1B    MOV   [__r2],A
    1EF6: 51 1C    MOV   A,[__r1]
    1EF8: 01 89    ADD   A,0x89
    1EFA: 53 18    MOV   [__r5],A
    1EFC: 3E 18    MVI   A,[__r5]
    1EFE: 7F       RET   
    1EFF: 6E 1C    RRC   [__r1]
    1F01: 68 1D    ASR   [__r0]
    1F03: 6E 1C    RRC   [__r1]
    1F05: 68 1D    ASR   [__r0]
    1F07: 6E 1C    RRC   [__r1]
    1F09: 7F       RET   
    1F0A: B0 09    JNZ   0x1F14
    1F0C: 56 06 01 MOV   [X+6],0x1
    1F0F: 56 05 00 MOV   [X+5],0x0
    1F12: 80 07    JMP   0x1F1A
    1F14: 56 06 00 MOV   [X+6],0x0
    1F17: 56 05 00 MOV   [X+5],0x0
    1F1A: 52 06    MOV   A,[X+6]
    1F1C: 53 70    MOV   [DSM_Is_DSMX],A
    1F1E: 7F       RET   
    1F1F: 5F 1C 01 MOV   [__r1],[cyrfmfg_id|n|ser_c+1]
    1F22: 55 1D 00 MOV   [__r0],0x0
    1F25: 5F 1B 00 MOV   [__r2],[cyrfmfg_id|n|ser_c]
    1F28: 50 00    MOV   A,0x0
    1F2A: 02 1C    ADD   A,[__r1]
    1F2C: 7F       RET   
