                        .module dsm.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./dsm.c
                        .area data(ram, con, rel)
 0000                   .dbfile ./dsm.c
 0000           _cyrfmfg_id::
 0000                   .blkb 2
                        .area idata(rom,lit)
 0000 7665              .byte 'v,'e
                        .area data(ram, con, rel)
 0002                   .dbfile ./dsm.c
 0002                   .blkb 2
                        .area idata(rom,lit)
 0002 3BCC              .byte 59,204
                        .area data(ram, con, rel)
 0004                   .dbfile ./dsm.c
 0004                   .blkb 2
                        .area idata(rom,lit)
 0004 5DFC              .byte 93,252
                        .area data(ram, con, rel)
 0006                   .dbfile ./dsm.c
 0006                   .dbfile C:\Users\Ralf\DOCUME~1\DSM_SA~1\DSM_SA~1\DSM_SA~1\dsm.c
 0006                   .dbsym e cyrfmfg_id _cyrfmfg_id A[6:6]c
                        .area lit(rom, con, rel, lit)
 0000           _pn_bind:
 0000 9888              .byte 152,136
 0002 1BE4              .byte 27,228
 0004 3079              .byte 48,'y
 0006 0384              .byte 3,132
 0008                   .dbsym s pn_bind _pn_bind A[8:8]kc
 0008           _pn_check:
 0008 C694              .byte 198,148
 000A 22FE              .byte 34,254
 000C 48E6              .byte 'H,230
 000E 574E              .byte 'W,'N
 0010                   .dbsym s pn_check _pn_check A[8:8]kc
 0010           _pncodes:
 0010 03BC              .byte 3,188
 0012 6E8A              .byte 'n,138
 0014 EFBD              .byte 239,189
 0016 FEF8              .byte 254,248
 0018 8817              .byte 136,23
 001A 133B              .byte 19,59
 001C 2DBF              .byte 45,191
 001E 06D6              .byte 6,214
 0020 F194              .byte 241,148
 0022 3021              .byte 48,33
 0024 A11C              .byte 161,28
 0026 88A9              .byte 136,169
 0028 D0D2              .byte 208,210
 002A 8EBC              .byte 142,188
 002C 822F              .byte 130,47
 002E E3B4              .byte 227,180
 0030 8CFA              .byte 140,250
 0032 479B              .byte 'G,155
 0034 83A5              .byte 131,165
 0036 66D0              .byte 'f,208
 0038 07BD              .byte 7,189
 003A 9F26              .byte 159,38
 003C C831              .byte 200,49
 003E 0FB8              .byte 15,184
 0040 EF03              .byte 239,3
 0042 9589              .byte 149,137
 0044 B471              .byte 180,'q
 0046 619D              .byte 'a,157
 0048 40BA              .byte 64,186
 004A 97D5              .byte 151,213
 004C 864F              .byte 134,'O
 004E CCD1              .byte 204,209
 0050 D7A1              .byte 215,161
 0052 54B1              .byte 'T,177
 0054 5E89              .byte 94,137
 0056 AE86              .byte 174,134
 0058 83F7              .byte 131,247
 005A A82D              .byte 168,45
 005C 7A44              .byte 'z,'D
 005E 64D3              .byte 'd,211
 0060 3F2C              .byte 63,44
 0062 4EAA              .byte 'N,170
 0064 7148              .byte 'q,'H
 0066 7AC9              .byte 'z,201
 0068 17FF              .byte 23,255
 006A 9E21              .byte 158,33
 006C 3690              .byte 54,144
 006E C782              .byte 199,130
 0070 BC5D              .byte 188,93
 0072 9A5B              .byte 154,91
 0074 EE7F              .byte 238,127
 0076 42EB              .byte 'B,235
 0078 24F5              .byte 36,245
 007A DDF8              .byte 221,248
 007C 7A77              .byte 'z,'w
 007E 74E7              .byte 't,231
 0080 3D70              .byte 61,'p
 0082 7C94              .byte 124,148
 0084 DC84              .byte 220,132
 0086 AD95              .byte 173,149
 0088 1E6A              .byte 30,'j
 008A F037              .byte 240,55
 008C 527B              .byte 'R,123
 008E 11D4              .byte 17,212
 0090 62F5              .byte 'b,245
 0092 2BAA              .byte 43,170
 0094 FC33              .byte 252,51
 0096 BFAF              .byte 191,175
 0098 4056              .byte 64,'V
 009A 32D9              .byte 50,217
 009C 0FD9              .byte 15,217
 009E 5D97              .byte 93,151
 00A0 4056              .byte 64,'V
 00A2 32D9              .byte 50,217
 00A4 0FD9              .byte 15,217
 00A6 5D97              .byte 93,151
 00A8 8E4A              .byte 142,'J
 00AA D0A9              .byte 208,169
 00AC A7FF              .byte 167,255
 00AE 20CA              .byte 32,202
 00B0 4C97              .byte 'L,151
 00B2 9DBF              .byte 157,191
 00B4 B83D              .byte 184,61
 00B6 B5BE              .byte 181,190
 00B8 0C5D              .byte 12,93
 00BA 2430              .byte 36,48
 00BC 9FCA              .byte 159,202
 00BE 6DBD              .byte 'm,189
 00C0 5014              .byte 'P,20
 00C2 33DE              .byte 51,222
 00C4 F178              .byte 241,'x
 00C6 95AD              .byte 149,173
 00C8 0C3C              .byte 12,60
 00CA FAF9              .byte 250,249
 00CC F0F2              .byte 240,242
 00CE 10C9              .byte 16,201
 00D0 F4DA              .byte 244,218
 00D2 06DB              .byte 6,219
 00D4 BF4E              .byte 191,'N
 00D6 6FB3              .byte 'o,179
 00D8 9E08              .byte 158,8
 00DA D1AE              .byte 209,174
 00DC 595E              .byte 'Y,94
 00DE E8F0              .byte 232,240
 00E0 C090              .byte 192,144
 00E2 8FBB              .byte 143,187
 00E4 7C8E              .byte 124,142
 00E6 2B8E              .byte 43,142
 00E8 C090              .byte 192,144
 00EA 8FBB              .byte 143,187
 00EC 7C8E              .byte 124,142
 00EE 2B8E              .byte 43,142
 00F0 8069              .byte 128,'i
 00F2 2680              .byte 38,128
 00F4 08F8              .byte 8,248
 00F6 49E7              .byte 'I,231
 00F8 7D2D              .byte 125,45
 00FA 4954              .byte 'I,'T
 00FC D080              .byte 208,128
 00FE 40C1              .byte 64,193
 0100 B6F2              .byte 182,242
 0102 E61B              .byte 230,27
 0104 805A              .byte 128,'Z
 0106 36B4              .byte 54,180
 0108 42AE              .byte 'B,174
 010A 9C1C              .byte 156,28
 010C DA67              .byte 218,'g
 010E 05F6              .byte 5,246
 0110 9B75              .byte 155,'u
 0112 F7E0              .byte 247,224
 0114 148D              .byte 20,141
 0116 B580              .byte 181,128
 0118 BF54              .byte 191,'T
 011A 98B9              .byte 152,185
 011C B730              .byte 183,48
 011E 5A88              .byte 'Z,136
 0120 35D1              .byte 53,209
 0122 FC97              .byte 252,151
 0124 23D4              .byte 35,212
 0126 C988              .byte 201,136
 0128 88E1              .byte 136,225
 012A D631              .byte 214,49
 012C 265F              .byte 38,95
 012E BD40              .byte 189,64
 0130 E1D6              .byte 225,214
 0132 3126              .byte 49,38
 0134 5FBD              .byte 95,189
 0136 4093              .byte 64,147
 0138 DC68              .byte 220,'h
 013A 0899              .byte 8,153
 013C 97AE              .byte 151,174
 013E AF8C              .byte 175,140
 0140 C30E              .byte 195,14
 0142 0116              .byte 1,22
 0144 0E32              .byte 14,50
 0146 06BA              .byte 6,186
 0148 E083              .byte 224,131
 014A 01FA              .byte 1,250
 014C AB3E              .byte 171,62
 014E 8FAC              .byte 143,172
 0150 5CD5              .byte 92,213
 0152 9CB8              .byte 156,184
 0154 469C              .byte 'F,156
 0156 7D84              .byte 125,132
 0158 F1C6              .byte 241,198
 015A FE5C              .byte 254,92
 015C 9DA5              .byte 157,165
 015E 4FB7              .byte 'O,183
 0160 58B5              .byte 'X,181
 0162 B3DD              .byte 179,221
 0164 0E28              .byte 14,40
 0166 F1B0              .byte 241,176
 0168 5F30              .byte 95,48
 016A 3B56              .byte 59,'V
 016C 9645              .byte 150,'E
 016E F4A1              .byte 244,161
 0170 03BC              .byte 3,188
 0172 6E8A              .byte 'n,138
 0174 EFBD              .byte 239,189
 0176 FEF8              .byte 254,248
 0178                   .dbsym s pncodes _pncodes A[360:5:9:8]kc
 0178           _init_vals:
 0178 2802              .byte 40,2
 017A 323C              .byte 50,60
 017C 3514              .byte 53,20
 017E 0D40              .byte 13,64
 0180 0648              .byte 6,'H
 0182 1B55              .byte 27,'U
 0184 1C05              .byte 28,5
 0186 0F24              .byte 15,36
 0188 120A              .byte 18,10
 018A 0F04              .byte 15,4
 018C 3901              .byte 57,1
 018E 0F24              .byte 15,36
 0190 2900              .byte 41,0
 0192 120A              .byte 18,10
 0194 104A              .byte 16,'J
 0196 290F              .byte 41,15
 0198                   .dbsym s init_vals _init_vals A[32:16:2]kc
 0198           _Transmit_vals:
 0198 10EA              .byte 16,234
 019A 1F00              .byte 31,0
 019C 1E00              .byte 30,0
 019E                   .dbsym s Transmit_vals _Transmit_vals A[6:3:2]kc
 019E           _bind_vals:
 019E 033A              .byte 3,58
 01A0 104A              .byte 16,'J
 01A2 1F04              .byte 31,4
 01A4 1E04              .byte 30,4
 01A6 1402              .byte 20,2
 01A8                   .dbsym s bind_vals _bind_vals A[10:5:2]kc
 01A8           _preamble:
 01A8 0433              .byte 4,51
 01AA 33                .byte 51
 01AB                   .dbsym s preamble _preamble A[3:3]kc
                        .area data(ram, con, rel)
 0006                   .dbfile C:\Users\Ralf\DOCUME~1\DSM_SA~1\DSM_SA~1\DSM_SA~1\dsm.c
 0006           _tx_cmd:
 0006                   .blkb 2
                        .area idata(rom,lit)
 0006 10C3              .byte 16,195
                        .area data(ram, con, rel)
 0008                   .dbfile C:\Users\Ralf\DOCUME~1\DSM_SA~1\DSM_SA~1\DSM_SA~1\dsm.c
 0008                   .dbsym s tx_cmd _tx_cmd A[2:2]c
                        .area text(rom, con, rel)
 0000                   .dbfile C:\Users\Ralf\DOCUME~1\DSM_SA~1\DSM_SA~1\DSM_SA~1\dsm.c
 0000                   .dbfunc e DSM_SetRangeCheck _DSM_SetRangeCheck fV
 0000           ;            val -> X-4
 0000           _DSM_SetRangeCheck::
 0000                   .dbline -1
 0000 10                push X
 0001 4F                mov X,SP
 0002 3802              add SP,2
 0004                   .dbline 155
 0004           ; #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
 0004           ; #include "dsm.h"
 0004           ; #include "serial.h"
 0004           ; #include "timer.h"
 0004           ; 
 0004           ; extern BYTE ModellNr;
 0004           ; 
 0004           ; 
 0004           ; //share memory with flash buffer
 0004           ; extern RAM_D mem;
 0004           ; #define tx_buf mem.b.buf0
 0004           ; //BYTE tx_buf[16];    //transmit buffer
 0004           ; #define bind_buf mem.b.buf0
 0004           ; //BYTE bind_buf[16];  //transmit buffer
 0004           ; #define rx_buf mem.b.buf1
 0004           ; //BYTE rx_buf[16];    //recive buffer
 0004           ; 
 0004           ; //config data
 0004           ; BOOL DSM_Is_DSMX;             //true for DSMX false for DSM2
 0004           ; BOOL DSM_Is_11ms;             //true for 11ms update
 0004           ; BOOL DSM_Is_11Bit;            //true for 11bit resolution
 0004           ; 
 0004           ; //global data
 0004           ; BYTE channels[23];    //list of channels
 0004           ; BYTE chidx;                   //current channel index 
 0004           ; BOOL DSM_Is_Forced;           //if true ignore reciver response
 0004           ; BOOL RX_Response;     //true if we got a response from reciver
 0004           ; BOOL Ch_A;                    //true for channel A false for channel B
 0004           ; BYTE dsm_Max_pos;     
 0004           ; BYTE sop_col;         
 0004           ; BYTE data_col;                
 0004           ; BYTE Bind_cnt;                //bind pulse counter
 0004           ; BYTE State;                   
 0004           ; BYTE bind_channal;    //channel used to send bind packes
 0004           ; BYTE num_channels;    //number fo transmit channels
 0004           ; BYTE cyrfmfg_id[6];   //manufacturer ID of cyrf6936
 0004           ; //BYTE cyrfmfg_id[6]={0x67,0x3B,0x16,0xCC,0xD8,0xFF}; //Does Work
 0004           ; //BYTE cyrfmfg_id[6]={0x76,0x65,0x3B,0x0F,0x5D,0xFC}; //Does Not Work
 0004           ; //BYTE cyrfmfg_id[6]={0x67,0x65,0x3B,0x0F,0x5D,0xFC}; //Test OK n
 0004           ; //BYTE cyrfmfg_id[6]={0x76,0x3B,0x3B,0x0F,0x5D,0xFC}; //Test OK
 0004           ; //BYTE cyrfmfg_id[6]={0x76,0x65,0x16,0x0F,0x5D,0xFC}; //Test OK
 0004           ; BYTE cyrfmfg_id[6]={0x76,0x65,0x3B,0xCC,0x5D,0xFC}; ///Test OK
 0004           ; BYTE tx_cfg;          //xmit power precomputed
 0004           ; WORD DSM_Perriode;            //cycle time - 4000
 0004           ; BOOL DSM_ready_for_Serial; //true if we are ready for the next serial package
 0004           ; int Last_Phase_error;
 0004           ; 
 0004           ; 
 0004           ; static const BYTE pn_bind[] = {0x98, 0x88, 0x1B, 0xE4, 0x30, 0x79, 0x03, 0x84}; //used for reciving bind response
 0004           ; static const BYTE pn_check[] = {0xc6,0x94,0x22,0xfe,0x48,0xe6,0x57,0x4e };            //used for scanning channel RSSI (found on spi capture of LPDSM)
 0004           ; 
 0004           ; static const BYTE pncodes[5][9][8] = {
 0004           ;     /* Note these are in order transmitted (LSB 1st) */
 0004           ; { /* Row 0 */
 0004           ;   /* Col 0 */ {0x03, 0xBC, 0x6E, 0x8A, 0xEF, 0xBD, 0xFE, 0xF8},
 0004           ;   /* Col 1 */ {0x88, 0x17, 0x13, 0x3B, 0x2D, 0xBF, 0x06, 0xD6},
 0004           ;   /* Col 2 */ {0xF1, 0x94, 0x30, 0x21, 0xA1, 0x1C, 0x88, 0xA9},
 0004           ;   /* Col 3 */ {0xD0, 0xD2, 0x8E, 0xBC, 0x82, 0x2F, 0xE3, 0xB4},
 0004           ;   /* Col 4 */ {0x8C, 0xFA, 0x47, 0x9B, 0x83, 0xA5, 0x66, 0xD0},
 0004           ;   /* Col 5 */ {0x07, 0xBD, 0x9F, 0x26, 0xC8, 0x31, 0x0F, 0xB8},
 0004           ;   /* Col 6 */ {0xEF, 0x03, 0x95, 0x89, 0xB4, 0x71, 0x61, 0x9D},
 0004           ;   /* Col 7 */ {0x40, 0xBA, 0x97, 0xD5, 0x86, 0x4F, 0xCC, 0xD1},
 0004           ;   /* Col 8 */ {0xD7, 0xA1, 0x54, 0xB1, 0x5E, 0x89, 0xAE, 0x86}
 0004           ; },
 0004           ; { /* Row 1 */
 0004           ;   /* Col 0 */ {0x83, 0xF7, 0xA8, 0x2D, 0x7A, 0x44, 0x64, 0xD3},
 0004           ;   /* Col 1 */ {0x3F, 0x2C, 0x4E, 0xAA, 0x71, 0x48, 0x7A, 0xC9},
 0004           ;   /* Col 2 */ {0x17, 0xFF, 0x9E, 0x21, 0x36, 0x90, 0xC7, 0x82},
 0004           ;   /* Col 3 */ {0xBC, 0x5D, 0x9A, 0x5B, 0xEE, 0x7F, 0x42, 0xEB},
 0004           ;   /* Col 4 */ {0x24, 0xF5, 0xDD, 0xF8, 0x7A, 0x77, 0x74, 0xE7},
 0004           ;   /* Col 5 */ {0x3D, 0x70, 0x7C, 0x94, 0xDC, 0x84, 0xAD, 0x95},
 0004           ;   /* Col 6 */ {0x1E, 0x6A, 0xF0, 0x37, 0x52, 0x7B, 0x11, 0xD4},
 0004           ;   /* Col 7 */ {0x62, 0xF5, 0x2B, 0xAA, 0xFC, 0x33, 0xBF, 0xAF},
 0004           ;   /* Col 8 */ {0x40, 0x56, 0x32, 0xD9, 0x0F, 0xD9, 0x5D, 0x97}
 0004           ; },
 0004           ; { /* Row 2 */
 0004           ;   /* Col 0 */ {0x40, 0x56, 0x32, 0xD9, 0x0F, 0xD9, 0x5D, 0x97},
 0004           ;   /* Col 1 */ {0x8E, 0x4A, 0xD0, 0xA9, 0xA7, 0xFF, 0x20, 0xCA},
 0004           ;   /* Col 2 */ {0x4C, 0x97, 0x9D, 0xBF, 0xB8, 0x3D, 0xB5, 0xBE},
 0004           ;   /* Col 3 */ {0x0C, 0x5D, 0x24, 0x30, 0x9F, 0xCA, 0x6D, 0xBD},
 0004           ;   /* Col 4 */ {0x50, 0x14, 0x33, 0xDE, 0xF1, 0x78, 0x95, 0xAD},
 0004           ;   /* Col 5 */ {0x0C, 0x3C, 0xFA, 0xF9, 0xF0, 0xF2, 0x10, 0xC9},
 0004           ;   /* Col 6 */ {0xF4, 0xDA, 0x06, 0xDB, 0xBF, 0x4E, 0x6F, 0xB3},
 0004           ;   /* Col 7 */ {0x9E, 0x08, 0xD1, 0xAE, 0x59, 0x5E, 0xE8, 0xF0},
 0004           ;   /* Col 8 */ {0xC0, 0x90, 0x8F, 0xBB, 0x7C, 0x8E, 0x2B, 0x8E}
 0004           ; },
 0004           ; { /* Row 3 */
 0004           ;   /* Col 0 */ {0xC0, 0x90, 0x8F, 0xBB, 0x7C, 0x8E, 0x2B, 0x8E},
 0004           ;   /* Col 1 */ {0x80, 0x69, 0x26, 0x80, 0x08, 0xF8, 0x49, 0xE7},
 0004           ;   /* Col 2 */ {0x7D, 0x2D, 0x49, 0x54, 0xD0, 0x80, 0x40, 0xC1},
 0004           ;   /* Col 3 */ {0xB6, 0xF2, 0xE6, 0x1B, 0x80, 0x5A, 0x36, 0xB4},
 0004           ;   /* Col 4 */ {0x42, 0xAE, 0x9C, 0x1C, 0xDA, 0x67, 0x05, 0xF6},
 0004           ;   /* Col 5 */ {0x9B, 0x75, 0xF7, 0xE0, 0x14, 0x8D, 0xB5, 0x80},
 0004           ;   /* Col 6 */ {0xBF, 0x54, 0x98, 0xB9, 0xB7, 0x30, 0x5A, 0x88},
 0004           ;   /* Col 7 */ {0x35, 0xD1, 0xFC, 0x97, 0x23, 0xD4, 0xC9, 0x88},
 0004           ;   /* Col 8 */ {0x88, 0xE1, 0xD6, 0x31, 0x26, 0x5F, 0xBD, 0x40}
 0004           ; },
 0004           ; { /* Row 4 */
 0004           ;   /* Col 0 */ {0xE1, 0xD6, 0x31, 0x26, 0x5F, 0xBD, 0x40, 0x93},
 0004           ;   /* Col 1 */ {0xDC, 0x68, 0x08, 0x99, 0x97, 0xAE, 0xAF, 0x8C},
 0004           ;   /* Col 2 */ {0xC3, 0x0E, 0x01, 0x16, 0x0E, 0x32, 0x06, 0xBA},
 0004           ;   /* Col 3 */ {0xE0, 0x83, 0x01, 0xFA, 0xAB, 0x3E, 0x8F, 0xAC},
 0004           ;   /* Col 4 */ {0x5C, 0xD5, 0x9C, 0xB8, 0x46, 0x9C, 0x7D, 0x84},
 0004           ;   /* Col 5 */ {0xF1, 0xC6, 0xFE, 0x5C, 0x9D, 0xA5, 0x4F, 0xB7},
 0004           ;   /* Col 6 */ {0x58, 0xB5, 0xB3, 0xDD, 0x0E, 0x28, 0xF1, 0xB0},
 0004           ;   /* Col 7 */ {0x5F, 0x30, 0x3B, 0x56, 0x96, 0x45, 0xF4, 0xA1},
 0004           ;   /* Col 8 */ {0x03, 0xBC, 0x6E, 0x8A, 0xEF, 0xBD, 0xFE, 0xF8}
 0004           ; },};
 0004           ; 
 0004           ; 
 0004           ; static const BYTE init_vals[][2] = {
 0004           ; //    {CYRF_MODE_OVERRIDE, 0x01},
 0004           ;     {CYRF_CLK_EN, CLK_EN_RXF},  //0x02
 0004           ;     {CYRF_AUTO_CAL_TIME, 0x3c}, //see cyrf manual
 0004           ;     {CYRF_AUTO_CAL_OFFSET, 0x14}, //see cyrf manual
 0004           ;       {CYRF_IO_CFG,IO_CFG_IRQ_POL}, //0x40 IRQ active High 
 0004           ;     {CYRF_RX_CFG, RX_LNA|FAST_TURN_EN}, //0x48 Fast Turn Mode Enable, Low Noise Amplifier ON
 0004           ;     {CYRF_TX_OFFSET_LSB, 0x55},//see cyrf manual
 0004           ;     {CYRF_TX_OFFSET_MSB, 0x05},//see cyrf manual
 0004           ;     {CYRF_XACT_CFG,CYRF_XACT_END_STATE(CYRF_MODE_IDLE)|CYRF_FRC_END}, //0x24 Force  Idle Mode
 0004           ;     //{CYRF_TX_CFG,TX_DM(TX_DM_SDR)|TX_DC_LEN}, //0x38 SDR Mode  64 chip
 0004           ;     {CYRF_DATA64_THOLD, 0x0a},//see cyrf manual
 0004           ;     {CYRF_XACT_CFG,CYRF_XACT_END_STATE(CYRF_MODE_IDLE)}, //0x04 Transaction End State Idle Mode
 0004           ;     //{CYRF_XTAL_CTRL,0x80},
 0004           ;       {CYRF_ANALOG_CTRL, ALL_SLOW}, //0x01 all slow
 0004           ;     {CYRF_XACT_CFG,CYRF_XACT_END_STATE(CYRF_MODE_IDLE)| CYRF_FRC_END}, //0x24 Force IDLE
 0004           ;       {CYRF_RX_ABORT, 0x00}, //Clear RX abort
 0004           ;     {CYRF_DATA64_THOLD, 0x0a}, //set pn correlation threshold
 0004           ;     {CYRF_FRAMING_CFG, SOP_LEN|0xa}, //set sop len and threshold
 0004           ;     {CYRF_RX_ABORT, 0x0f}, //Clear RX abort?
 0004           ; };
 0004           ; 
 0004           ; static const BYTE Transmit_vals[][2] = {
 0004           ;     //{CYRF_TX_CFG,TX_DM(TX_DM_8DR)|TX_PA_P4DBM}, //0x0F 8DR Mode  +4 dBm 32 chip codes
 0004           ;       {CYRF_FRAMING_CFG,LEN_EN|SOP_LEN|SOP_EN|0xA},  //0xEA SOP Enable SOP code length is 64 chips Packet Length Enable  SOP Correlator Threshold=0xA
 0004           ;     {CYRF_TX_OVERRIDE, 0x00},
 0004           ;     {CYRF_RX_OVERRIDE, 0x00},
 0004           ; };
 0004           ; 
 0004           ; static const BYTE bind_vals[][2] = {
 0004           ;     {CYRF_TX_CFG,TX_DC_LEN|TX_DM(TX_DM_SDR)|DSM_BIND_POWER}, //0x38 Set 64 chip, SDR mode
 0004           ;     {CYRF_FRAMING_CFG,SOP_LEN|0xA}, //0x4A set sop len  32 chip and threshold =0xA 
 0004           ;     {CYRF_TX_OVERRIDE, DIS_TXCRC}, //0x4 disable tx CRC
 0004           ;     {CYRF_RX_OVERRIDE, DIS_RXCRC}, //0x4 disable rx CRC
 0004           ;     {CYRF_EOP_CTRL, 0x02}, //set EOP sync == 2
 0004           ; };
 0004           ; 
 0004           ; 
 0004           ; static const BYTE preamble[]={0x04,0x33,0x33};
 0004           ; static  BYTE tx_cmd[]={0x10,TXE_IRQEN|TXC_IRQEN|TX_GO|TX_CLR}; //0xC3
 0004           ; 
 0004           ; #define TX_CFG (TX_DM(TX_DM_8DR)|TX_DC_LEN) //0x28 DDR Mode  64 chip codes
 0004           ; 
 0004           ; void DSM_SetRangeCheck(BOOL val)
 0004           ; {
 0004                   .dbline 156
 0004           ;       tx_cfg=val?TX_CFG|DSM_RANGE_CHECK_POWER:TX_CFG|DSM_TX_POWER;    
 0004 3DFC00            cmp [X-4],0
 0007 A009              jz L13
 0009 56012B            mov [X+1],43
 000C 560000            mov [X+0],0
 000F 8007              xjmp L14
 0011           L13:
 0011 56012F            mov [X+1],47
 0014 560000            mov [X+0],0
 0017           L14:
 0017 5201              mov A,[X+1]
 0019 5303              mov [_tx_cfg],A
 001B                   .dbline -2
 001B           L11:
 001B 38FE              add SP,-2
 001D 20                pop X
 001E                   .dbline 0 ; func end
 001E 7F                ret
 001F                   .dbsym l val -4 c
 001F                   .dbend
 001F                   .dbfunc e SetTimer _SetTimer fV
 001F           _SetTimer::
 001F                   .dbline -1
 001F                   .dbline 161
 001F           ; }
 001F           ; 
 001F           ; //set time till periode
 001F           ; void SetTimer(void)
 001F           ; {
 001F                   .dbline 162
 001F           ;       if(Ch_A)
 001F 3C0800            cmp [_Ch_A],0
 0022 A00F              jz L16
 0024                   .dbline 166
 0024           ;       {
 0024           ;               //if CH_A is on, CH_B has been send out, 
 0024           ;               //from now till CH_A transmit is the windows where the serial data must come in  
 0024           ;               DSM_ready_for_Serial=TRUE;
 0024                   .dbline 166
 0024 552501            mov [_DSM_ready_for_Serial],1
 0027                   .dbline 168
 0027           ;               //DSM_Data_To_send=FALSE;
 0027           ;               Timer_SetPeriod(DSM_TIME_CHA_CHB);
 0027 10                push X
 0028 570F              mov X,15
 002A 50A0              mov A,-96
 002C 7C0000            xcall _Counter16_1_WritePeriod
 002F 20                pop X
 0030                   .dbline 169
 0030           ;       }
 0030 800A              xjmp L17
 0032           L16:
 0032                   .dbline 171
 0032           ;       else
 0032           ;       {
 0032                   .dbline 172
 0032           ;               Timer_SetPeriod(DSM_Perriode);
 0032 10                push X
 0033 5823              mov X,[_DSM_Perriode]
 0035 5124              mov A,[_DSM_Perriode+1]
 0037 7C0000            xcall _Counter16_1_WritePeriod
 003A 20                pop X
 003B                   .dbline 173
 003B           ;       }
 003B           L17:
 003B                   .dbline -2
 003B           L15:
 003B                   .dbline 0 ; func end
 003B 7F                ret
 003C                   .dbend
 003C                   .dbfunc e SetCH_CRC_SOP_DATA _SetCH_CRC_SOP_DATA fV
 003C           ;        CRCSeed -> X+2
 003C           ;         pn_row -> X+1
 003C           ;        channel -> X+0
 003C           _SetCH_CRC_SOP_DATA::
 003C                   .dbline -1
 003C 10                push X
 003D 4F                mov X,SP
 003E 3808              add SP,8
 0040                   .dbline 178
 0040           ; }
 0040           ; 
 0040           ; //calculate and set channel CRC , SOP and data code 
 0040           ; void SetCH_CRC_SOP_DATA(void)
 0040           ; {
 0040                   .dbline 179
 0040           ;       BYTE channel=channels[chidx];
 0040 5F000A            mov [__r1],[_chidx]
 0043 06000B            add [__r1],<_channels
 0046 3E00              mvi A,[__r1]
 0048 5400              mov [X+0],A
 004A                   .dbline 180
 004A           ;       BYTE pn_row = DSM_Is_DSMX ? (channel - 2)%5 : channel%5;
 004A 3C2900            cmp [_DSM_Is_DSMX],0
 004D A027              jz L20
 004F 5200              mov A,[X+0]
 0051 5300              mov [__r1],A
 0053 550000            mov [__r0],0
 0056 160002            sub [__r1],2
 0059 1E0000            sbb [__r0],0
 005C 5000              mov A,0
 005E 08                push A
 005F 5005              mov A,5
 0061 08                push A
 0062 5100              mov A,[__r0]
 0064 08                push A
 0065 5100              mov A,[__r1]
 0067 08                push A
 0068 7C0000            xcall __divmod_16X16_16
 006B 38FE              add SP,-2
 006D 18                pop A
 006E 5405              mov [X+5],A
 0070 18                pop A
 0071 5404              mov [X+4],A
 0073 801C              xjmp L21
 0075           L20:
 0075 5200              mov A,[X+0]
 0077 5300              mov [__r1],A
 0079 5000              mov A,0
 007B 08                push A
 007C 5005              mov A,5
 007E 08                push A
 007F 5000              mov A,0
 0081 08                push A
 0082 5100              mov A,[__r1]
 0084 08                push A
 0085 7C0000            xcall __divmod_16X16_16
 0088 38FE              add SP,-2
 008A 18                pop A
 008B 5405              mov [X+5],A
 008D 18                pop A
 008E 5404              mov [X+4],A
 0090           L21:
 0090 5205              mov A,[X+5]
 0092 5401              mov [X+1],A
 0094                   .dbline 181
 0094           ;       WORD CRCSeed=Ch_A?~((WORD)(cyrfmfg_id[0] << 8) + (WORD)cyrfmfg_id[1]):((WORD)(cyrfmfg_id[0] << 8) + (WORD)cyrfmfg_id[1]);
 0094 3C0800            cmp [_Ch_A],0
 0097 A022              jz L25
 0099 5F0001            mov [__r1],[_cyrfmfg_id+1]
 009C 550000            mov [__r0],0
 009F 5F0000            mov [__r2],[_cyrfmfg_id]
 00A2 5000              mov A,0
 00A4 0200              add A,[__r1]
 00A6 5300              mov [__r1],A
 00A8 5100              mov A,[__r2]
 00AA 0A00              adc A,[__r0]
 00AC 5300              mov [__r0],A
 00AE 5100              mov A,[__r1]
 00B0 73                cpl A
 00B1 5407              mov [X+7],A
 00B3 5100              mov A,[__r0]
 00B5 73                cpl A
 00B6 5406              mov [X+6],A
 00B8 8016              xjmp L26
 00BA           L25:
 00BA 5F0001            mov [__r1],[_cyrfmfg_id+1]
 00BD 550000            mov [__r0],0
 00C0 5F0000            mov [__r2],[_cyrfmfg_id]
 00C3 5000              mov A,0
 00C5 0200              add A,[__r1]
 00C7 5407              mov [X+7],A
 00C9 5100              mov A,[__r2]
 00CB 0A00              adc A,[__r0]
 00CD 5406              mov [X+6],A
 00CF           L26:
 00CF 5207              mov A,[X+7]
 00D1 5403              mov [X+3],A
 00D3 5206              mov A,[X+6]
 00D5 5402              mov [X+2],A
 00D7                   .dbline 182
 00D7           ;       CYRF_SetRFChannel(channel);
 00D7 5200              mov A,[X+0]
 00D9 08                push A
 00DA 5000              mov A,0
 00DC 08                push A
 00DD 7C0000            xcall _CYRF_WriteRegister
 00E0                   .dbline 183
 00E0           ;       CYRF_SetCRCSeed(CRCSeed);
 00E0 5202              mov A,[X+2]
 00E2 08                push A
 00E3 5203              mov A,[X+3]
 00E5 08                push A
 00E6 7C0000            xcall _CYRF_SetCRCSeed
 00E9 38FC              add SP,-4
 00EB                   .dbline 184
 00EB           ;     CYRF_SetSOPCode(pncodes[pn_row][sop_col]);
 00EB 5008              mov A,8
 00ED 08                push A
 00EE 5201              mov A,[X+1]
 00F0 5300              mov [__r1],A
 00F2 5000              mov A,0
 00F4 08                push A
 00F5 5100              mov A,[__r1]
 00F7 08                push A
 00F8 5000              mov A,0
 00FA 08                push A
 00FB 5048              mov A,72
 00FD 08                push A
 00FE 7C0000            xcall __mul16
 0101 38FC              add SP,-4
 0103 5F0000            mov [__r1],[__rX]
 0106 5F0000            mov [__r0],[__rY]
 0109 060010            add [__r1],<_pncodes
 010C 0E0010            adc [__r0],>_pncodes
 010F 5F0007            mov [__r3],[_sop_col]
 0112 550000            mov [__r2],0
 0115 6500              asl [__r3]
 0117 6B00              rlc [__r2]
 0119 6500              asl [__r3]
 011B 6B00              rlc [__r2]
 011D 6500              asl [__r3]
 011F 6B00              rlc [__r2]
 0121 5100              mov A,[__r3]
 0123 0200              add A,[__r1]
 0125 5300              mov [__r1],A
 0127 5100              mov A,[__r2]
 0129 0A00              adc A,[__r0]
 012B 08                push A
 012C 5100              mov A,[__r1]
 012E 08                push A
 012F 5022              mov A,34
 0131 08                push A
 0132 7C0000            xcall _CYRF_WriteRegisterMulti
 0135 38FC              add SP,-4
 0137                   .dbline 185
 0137           ;     CYRF_SetDataCode(pncodes[pn_row][data_col], 16);
 0137 5010              mov A,16
 0139 08                push A
 013A 5201              mov A,[X+1]
 013C 5300              mov [__r1],A
 013E 5000              mov A,0
 0140 08                push A
 0141 5100              mov A,[__r1]
 0143 08                push A
 0144 5000              mov A,0
 0146 08                push A
 0147 5048              mov A,72
 0149 08                push A
 014A 7C0000            xcall __mul16
 014D 38FC              add SP,-4
 014F 5F0000            mov [__r1],[__rX]
 0152 5F0000            mov [__r0],[__rY]
 0155 060010            add [__r1],<_pncodes
 0158 0E0010            adc [__r0],>_pncodes
 015B 5F0006            mov [__r3],[_data_col]
 015E 550000            mov [__r2],0
 0161 6500              asl [__r3]
 0163 6B00              rlc [__r2]
 0165 6500              asl [__r3]
 0167 6B00              rlc [__r2]
 0169 6500              asl [__r3]
 016B 6B00              rlc [__r2]
 016D 5100              mov A,[__r3]
 016F 0200              add A,[__r1]
 0171 5300              mov [__r1],A
 0173 5100              mov A,[__r2]
 0175 0A00              adc A,[__r0]
 0177 08                push A
 0178 5100              mov A,[__r1]
 017A 08                push A
 017B 5023              mov A,35
 017D 08                push A
 017E 7C0000            xcall _CYRF_WriteRegisterMulti
 0181 38FC              add SP,-4
 0183                   .dbline 186
 0183           ;     if(DSM_Is_DSMX)
 0183 3C2900            cmp [_DSM_Is_DSMX],0
 0186 A017              jz L27
 0188                   .dbline 187
 0188           ;         chidx = (chidx + 1) % 23;
 0188 510A              mov A,[_chidx]
 018A 0101              add A,1
 018C 5300              mov [__r0],A
 018E 5017              mov A,23
 0190 08                push A
 0191 5100              mov A,[__r0]
 0193 08                push A
 0194 7C0000            xcall __divmodu_8X8_8
 0197 38FF              add SP,-1
 0199 18                pop A
 019A 530A              mov [_chidx],A
 019C 8015              xjmp L28
 019E           L27:
 019E                   .dbline 189
 019E           ;     else
 019E           ;         chidx = (chidx + 1) % 2;
 019E 510A              mov A,[_chidx]
 01A0 0101              add A,1
 01A2 5300              mov [__r0],A
 01A4 5002              mov A,2
 01A6 08                push A
 01A7 5100              mov A,[__r0]
 01A9 08                push A
 01AA 7C0000            xcall __divmodu_8X8_8
 01AD 38FF              add SP,-1
 01AF 18                pop A
 01B0 530A              mov [_chidx],A
 01B2           L28:
 01B2                   .dbline -2
 01B2           L18:
 01B2 38F8              add SP,-8
 01B4 20                pop X
 01B5                   .dbline 0 ; func end
 01B5 7F                ret
 01B6                   .dbsym l CRCSeed 2 i
 01B6                   .dbsym l pn_row 1 c
 01B6                   .dbsym l channel 0 c
 01B6                   .dbend
 01B6                   .dbfunc e DSM_Load_Config _DSM_Load_Config fV
 01B6           ;              n -> X+0
 01B6           ;            cnt -> X-6
 01B6           ;           vals -> X-5
 01B6           _DSM_Load_Config::
 01B6                   .dbline -1
 01B6 10                push X
 01B7 4F                mov X,SP
 01B8 3801              add SP,1
 01BA                   .dbline 194
 01BA           ; }
 01BA           ; 
 01BA           ; //load the given config into cyfr6936
 01BA           ; void DSM_Load_Config(const BYTE vals[][2],BYTE cnt)
 01BA           ; {
 01BA                   .dbline 197
 01BA           ; BYTE n;
 01BA           ; 
 01BA           ; for(n=0;n<cnt;n++)
 01BA 560000            mov [X+0],0
 01BD 8033              xjmp L33
 01BF           L30:
 01BF                   .dbline 198
 01BF           ;       {
 01BF                   .dbline 199
 01BF           ;       CYRF_WriteRegister(vals[n][0],vals[n][1]);
 01BF 5200              mov A,[X+0]
 01C1 5300              mov [__r1],A
 01C3 550000            mov [__r0],0
 01C6 6500              asl [__r1]
 01C8 6B00              rlc [__r0]
 01CA 52FC              mov A,[X-4]
 01CC 0400              add [__r1],A
 01CE 52FB              mov A,[X-5]
 01D0 0C00              adc [__r0],A
 01D2 5100              mov A,[__r1]
 01D4 0101              add A,1
 01D6 5300              mov [__r3],A
 01D8 5100              mov A,[__r0]
 01DA 0900              adc A,0
 01DC 10                push X
 01DD 5800              mov X,[__r3]
 01DF 28                romx
 01E0 20                pop X
 01E1 08                push A
 01E2 5100              mov A,[__r0]
 01E4 10                push X
 01E5 5800              mov X,[__r1]
 01E7 28                romx
 01E8 20                pop X
 01E9 08                push A
 01EA 7C0000            xcall _CYRF_WriteRegister
 01ED 38FE              add SP,-2
 01EF                   .dbline 200
 01EF           ;       }
 01EF           L31:
 01EF                   .dbline 197
 01EF 7700              inc [X+0]
 01F1           L33:
 01F1                   .dbline 197
 01F1 5200              mov A,[X+0]
 01F3 3BFA              cmp A,[X-6]
 01F5 CFC9              jc L30
 01F7           X0:
 01F7                   .dbline -2
 01F7           L29:
 01F7 38FF              add SP,-1
 01F9 20                pop X
 01FA                   .dbline 0 ; func end
 01FA 7F                ret
 01FB                   .dbsym l n 0 c
 01FB                   .dbsym l cnt -6 c
 01FB                   .dbsym l vals -5 pA[2:2]kc
 01FB                   .dbend
 01FB                   .dbfunc e Bind_Xmit_cb _Bind_Xmit_cb fV
 01FB           _Bind_Xmit_cb::
 01FB                   .dbline -1
 01FB                   .dbline 206
 01FB           ; }
 01FB           ; 
 01FB           ; //called from timer
 01FB           ; //send out next data package
 01FB           ; void Bind_Xmit_cb(void)
 01FB           ; {
 01FB                   .dbline 210
 01FB           ; #ifdef DEBUG
 01FB           ;        //TX8SW_1_CPutString("X");
 01FB           ; #endif
 01FB           ;       CYRF_WriteRegisterInc(CYRF_TX_LENGTH,tx_cmd,sizeof(tx_cmd)/sizeof(BYTE));
 01FB 5002              mov A,2
 01FD 08                push A
 01FE 5006              mov A,>_tx_cmd
 0200 08                push A
 0201 5006              mov A,<_tx_cmd
 0203 08                push A
 0204 5001              mov A,1
 0206 08                push A
 0207 7C0000            xcall _CYRF_WriteRegisterInc
 020A                   .dbline 211
 020A           ;       CYRF_WriteTx_Data(bind_buf);
 020A 5010              mov A,16
 020C 08                push A
 020D 5000              mov A,>_mem
 020F 08                push A
 0210 5000              mov A,<_mem
 0212 08                push A
 0213 5020              mov A,32
 0215 08                push A
 0216 7C0000            xcall _CYRF_WriteRegisterMultiD
 0219 38F8              add SP,-8
 021B                   .dbline -2
 021B           L34:
 021B                   .dbline 0 ; func end
 021B 7F                ret
 021C                   .dbend
 021C                   .dbfunc e Send_Xmit_cb _Send_Xmit_cb fV
 021C           _Send_Xmit_cb::
 021C                   .dbline -1
 021C 10                push X
 021D 4F                mov X,SP
 021E 3802              add SP,2
 0220                   .dbline 216
 0220           ; }
 0220           ; 
 0220           ; 
 0220           ; void Send_Xmit_cb(void)
 0220           ; {
 0220                   .dbline 223
 0220           ; #ifdef DEBUG
 0220           ;       //TX8SW_1_CPutString("X");
 0220           ;       //DIAG_OUT1_Switch(Ch_A);
 0220           ; #endif
 0220           ;       //if(Ch_A) //found on SPI capture from mlp4dsm
 0220           ;       //      CYRF_ReadRegister(CYRF_XTAL_CTRL);
 0220           ;       CYRF_WriteRegisterInc(CYRF_TX_LENGTH,tx_cmd,sizeof(tx_cmd)/sizeof(BYTE));
 0220 5002              mov A,2
 0222 08                push A
 0223 5006              mov A,>_tx_cmd
 0225 08                push A
 0226 5006              mov A,<_tx_cmd
 0228 08                push A
 0229 5001              mov A,1
 022B 08                push A
 022C 7C0000            xcall _CYRF_WriteRegisterInc
 022F                   .dbline 224
 022F           ;       CYRF_WriteTx_Data(tx_buf);
 022F 5010              mov A,16
 0231 08                push A
 0232 5000              mov A,>_mem
 0234 08                push A
 0235 5000              mov A,<_mem
 0237 08                push A
 0238 5020              mov A,32
 023A 08                push A
 023B 7C0000            xcall _CYRF_WriteRegisterMultiD
 023E 38F8              add SP,-8
 0240                   .dbline 225
 0240           ;       DSM_ready_for_Serial=FALSE;             
 0240 552500            mov [_DSM_ready_for_Serial],0
 0243                   .dbline 226
 0243           ;       Ch_A=!Ch_A;
 0243 3C0800            cmp [_Ch_A],0
 0246 B009              jnz L37
 0248 560101            mov [X+1],1
 024B 560000            mov [X+0],0
 024E 8007              xjmp L38
 0250           L37:
 0250 560100            mov [X+1],0
 0253 560000            mov [X+0],0
 0256           L38:
 0256 5201              mov A,[X+1]
 0258 5308              mov [_Ch_A],A
 025A                   .dbline -2
 025A           L35:
 025A 38FE              add SP,-2
 025C 20                pop X
 025D                   .dbline 0 ; func end
 025D 7F                ret
 025E                   .dbend
 025E                   .dbfunc e DSM_StartReceive _DSM_StartReceive fV
 025E           _DSM_StartReceive::
 025E                   .dbline -1
 025E                   .dbline 233
 025E           ; }
 025E           ; 
 025E           ; 
 025E           ; 
 025E           ; //start reciving
 025E           ; void DSM_StartReceive(void)
 025E           ; {
 025E                   .dbline 234
 025E           ;       CYRF_StartReceive();
 025E 5083              mov A,-125
 0260 08                push A
 0261 5005              mov A,5
 0263 08                push A
 0264 7C0000            xcall _CYRF_WriteRegister
 0267                   .dbline 235
 0267           ;       CYRF_ReadRSSI();
 0267 5013              mov A,19
 0269 08                push A
 026A 7C0000            xcall _CYRF_ReadRegister
 026D 38FD              add SP,-3
 026F                   .dbline -2
 026F           L39:
 026F                   .dbline 0 ; func end
 026F 7F                ret
 0270                   .dbend
 0270                   .dbfunc e DSM_initialize_bind _DSM_initialize_bind fV
 0270           ;            sum -> X+1
 0270           ;              n -> X+0
 0270           _DSM_initialize_bind::
 0270                   .dbline -1
 0270 10                push X
 0271 4F                mov X,SP
 0272 380D              add SP,13
 0274                   .dbline 240
 0274           ; }
 0274           ; 
 0274           ; //initialize bind state
 0274           ; void DSM_initialize_bind(void)
 0274           ; {     
 0274                   .dbline 242
 0274           ;       BYTE n;
 0274           ;       Bind_cnt=DSM_BIND_CNT;
 0274 552A64            mov [_Bind_cnt],100
 0277                   .dbline 243
 0277           ;       State=DSM_STATE_BIND;
 0277 550500            mov [_State],0
 027A                   .dbline 244
 027A           ;       DSM_Load_Config(bind_vals,sizeof(bind_vals)/(sizeof(BYTE)*2));
 027A 5005              mov A,5
 027C 08                push A
 027D 509E              mov A,>_bind_vals
 027F 08                push A
 0280 509E              mov A,<_bind_vals
 0282 08                push A
 0283 9F31              xcall _DSM_Load_Config
 0285 38FD              add SP,-3
 0287                   .dbline 245
 0287           ;       CYRF_SetRFChannel(bind_channal);
 0287 5104              mov A,[_bind_channal]
 0289 08                push A
 028A 5000              mov A,0
 028C 08                push A
 028D 7C0000            xcall _CYRF_WriteRegister
 0290                   .dbline 246
 0290           ;       CYRF_SetDataCode(pncodes[0][8], 16);
 0290 5010              mov A,16
 0292 08                push A
 0293 5050              mov A,>_pncodes+64
 0295 08                push A
 0296 5050              mov A,<_pncodes+64
 0298 08                push A
 0299 5023              mov A,35
 029B 08                push A
 029C 7C0000            xcall _CYRF_WriteRegisterMulti
 029F 38FA              add SP,-6
 02A1                   .dbline 251
 02A1           ; 
 02A1           ;       //manual inline
 02A1           ;       //DSM_build_bind_packet();
 02A1           ;       //void DSM_build_bind_packet(void)
 02A1           ;       {
 02A1                   .dbline 253
 02A1           ;           //BYTE n;
 02A1           ;           WORD sum = 384 - 0x10;
 02A1 560270            mov [X+2],112
 02A4 560101            mov [X+1],1
 02A7                   .dbline 254
 02A7           ;           bind_buf[0] = ~cyrfmfg_id[0];
 02A7 5100              mov A,[_cyrfmfg_id]
 02A9 73                cpl A
 02AA 5300              mov [_mem],A
 02AC                   .dbline 255
 02AC           ;           bind_buf[1] = ~cyrfmfg_id[1];
 02AC 5101              mov A,[_cyrfmfg_id+1]
 02AE 73                cpl A
 02AF 5301              mov [_mem+1],A
 02B1                   .dbline 256
 02B1           ;           bind_buf[2] = ~cyrfmfg_id[2];
 02B1 5102              mov A,[_cyrfmfg_id+2]
 02B3 73                cpl A
 02B4 5302              mov [_mem+2],A
 02B6                   .dbline 257
 02B6           ;           bind_buf[3] = ~(cyrfmfg_id[3]+ModellNr);
 02B6 5103              mov A,[_cyrfmfg_id+3]
 02B8 0200              add A,[_ModellNr]
 02BA 73                cpl A
 02BB 5303              mov [_mem+3],A
 02BD                   .dbline 258
 02BD           ;           bind_buf[4] = bind_buf[0];
 02BD 5F0400            mov [_mem+4],[_mem]
 02C0                   .dbline 259
 02C0           ;           bind_buf[5] = bind_buf[1];
 02C0 5F0501            mov [_mem+5],[_mem+1]
 02C3                   .dbline 260
 02C3           ;           bind_buf[6] = bind_buf[2];
 02C3 5F0602            mov [_mem+6],[_mem+2]
 02C6                   .dbline 261
 02C6           ;           bind_buf[7] = bind_buf[3];
 02C6 5F0703            mov [_mem+7],[_mem+3]
 02C9                   .dbline 264
 02C9           ;               
 02C9           ;               //gennerate first checksum
 02C9           ;           for(n = 0; n < 8; n++)
 02C9 560000            mov [X+0],0
 02CC 8012              xjmp L58
 02CE           L55:
 02CE                   .dbline 265
 02CE           ;               sum += bind_buf[n];
 02CE 5200              mov A,[X+0]
 02D0 0100              add A,<_mem
 02D2 5300              mov [__r1],A
 02D4 3E00              mvi A,[__r1]
 02D6 0502              add [X+2],A
 02D8 5000              mov A,0
 02DA 0F0100            adc [X+1],0
 02DD           L56:
 02DD                   .dbline 264
 02DD 7700              inc [X+0]
 02DF           L58:
 02DF                   .dbline 264
 02DF 3D0008            cmp [X+0],8
 02E2 CFEB              jc L55
 02E4           X1:
 02E4                   .dbline 266
 02E4           ;           bind_buf[8] = sum >> 8;
 02E4 5201              mov A,[X+1]
 02E6 5308              mov [_mem+8],A
 02E8                   .dbline 267
 02E8           ;           bind_buf[9] = sum & 0xff;
 02E8 5202              mov A,[X+2]
 02EA 5309              mov [_mem+9],A
 02EC                   .dbline 269
 02EC           ; 
 02EC           ;               bind_buf[10] = 0x01; //?Air 0x2; //surface 
 02EC 550A01            mov [_mem+10],1
 02EF                   .dbline 270
 02EF           ;           bind_buf[11] =num_channels;
 02EF 5F0B2B            mov [_mem+11],[_num_channels]
 02F2                   .dbline 271
 02F2           ;           bind_buf[12] = DSM_Is_DSMX?(DSM_Is_11ms?0xB2:0xA2):DSM_Is_11Bit?(DSM_Is_11ms?0x12:0x11):(DSM_Is_11ms?0x02:0x01);
 02F2 3C2900            cmp [_DSM_Is_DSMX],0
 02F5 A01E              jz L69
 02F7 3C2800            cmp [_DSM_Is_11ms],0
 02FA A009              jz L71
 02FC 5606B2            mov [X+6],-78
 02FF 560500            mov [X+5],0
 0302 8007              xjmp L72
 0304           L71:
 0304 5606A2            mov [X+6],-94
 0307 560500            mov [X+5],0
 030A           L72:
 030A 5206              mov A,[X+6]
 030C 5404              mov [X+4],A
 030E 5205              mov A,[X+5]
 0310 5403              mov [X+3],A
 0312 8046              xjmp L70
 0314           L69:
 0314 3C2700            cmp [_DSM_Is_11Bit],0
 0317 A01E              jz L73
 0319 3C2800            cmp [_DSM_Is_11ms],0
 031C A009              jz L75
 031E 560A12            mov [X+10],18
 0321 560900            mov [X+9],0
 0324 8007              xjmp L76
 0326           L75:
 0326 560A11            mov [X+10],17
 0329 560900            mov [X+9],0
 032C           L76:
 032C 520A              mov A,[X+10]
 032E 5408              mov [X+8],A
 0330 5209              mov A,[X+9]
 0332 5407              mov [X+7],A
 0334 801C              xjmp L74
 0336           L73:
 0336 3C2800            cmp [_DSM_Is_11ms],0
 0339 A009              jz L77
 033B 560C02            mov [X+12],2
 033E 560B00            mov [X+11],0
 0341 8007              xjmp L78
 0343           L77:
 0343 560C01            mov [X+12],1
 0346 560B00            mov [X+11],0
 0349           L78:
 0349 520C              mov A,[X+12]
 034B 5408              mov [X+8],A
 034D 520B              mov A,[X+11]
 034F 5407              mov [X+7],A
 0351           L74:
 0351 5208              mov A,[X+8]
 0353 5404              mov [X+4],A
 0355 5207              mov A,[X+7]
 0357 5403              mov [X+3],A
 0359           L70:
 0359 5204              mov A,[X+4]
 035B 530C              mov [_mem+12],A
 035D                   .dbline 277
 035D           ; 
 035D           ; #ifdef DEBUG
 035D           ;               TX8SW_1_PutSHexByte(bind_buf[12]);      
 035D           ; #endif
 035D           ;               
 035D           ;               bind_buf[13] = 0x00; //???
 035D 550D00            mov [_mem+13],0
 0360                   .dbline 280
 0360           ;               
 0360           ;           //gennerate second checksum 
 0360           ;               for(n = 8; n < 14; n++)
 0360 560008            mov [X+0],8
 0363 8012              xjmp L83
 0365           L80:
 0365                   .dbline 281
 0365           ;               sum += bind_buf[n];
 0365 5200              mov A,[X+0]
 0367 0100              add A,<_mem
 0369 5300              mov [__r1],A
 036B 3E00              mvi A,[__r1]
 036D 0502              add [X+2],A
 036F 5000              mov A,0
 0371 0F0100            adc [X+1],0
 0374           L81:
 0374                   .dbline 280
 0374 7700              inc [X+0]
 0376           L83:
 0376                   .dbline 280
 0376 3D000E            cmp [X+0],14
 0379 CFEB              jc L80
 037B           X2:
 037B                   .dbline 283
 037B           ;           
 037B           ;               bind_buf[14] = sum >> 8;
 037B 5201              mov A,[X+1]
 037D 530E              mov [_mem+14],A
 037F                   .dbline 284
 037F           ;           bind_buf[15] = sum & 0xff;
 037F 5202              mov A,[X+2]
 0381 530F              mov [_mem+15],A
 0383                   .dbline 285
 0383           ;       }
 0383                   .dbline 286
 0383           ;       Timer_SetPeriod(DSM_TIME_BIND);
 0383 10                push X
 0384 5727              mov X,39
 0386 5010              mov A,16
 0388 7C0000            xcall _Counter16_1_WritePeriod
 038B 20                pop X
 038C                   .dbline 287
 038C           ;       Timer_SetCallback(Bind_Xmit_cb);
 038C 5008              mov A,>PL_Bind_Xmit_cb
 038E 08                push A
 038F 5008              mov A,<PL_Bind_Xmit_cb
 0391 08                push A
 0392 7C0000            xcall _Timer_SetCallback
 0395 38FE              add SP,-2
 0397                   .dbline 288
 0397           ;       Timer_Start();
 0397 10                push X
 0398 7C0000            xcall _Counter16_1_Start
 039B 20                pop X
 039C                   .dbline -2
 039C           L40:
 039C 38F3              add SP,-13
 039E 20                pop X
 039F                   .dbline 0 ; func end
 039F 7F                ret
 03A0                   .dbsym l sum 1 i
 03A0                   .dbsym l n 0 c
 03A0                   .dbend
 03A0                   .dbfunc e DSM_build_data_packet _DSM_build_data_packet fV
 03A0           ;            val -> X+1
 03A0           ;              i -> X+0
 03A0           _DSM_build_data_packet::
 03A0                   .dbline -1
 03A0 10                push X
 03A1 4F                mov X,SP
 03A2 3803              add SP,3
 03A4                   .dbline 294
 03A4           ; }
 03A4           ; 
 03A4           ; 
 03A4           ; //build the data package
 03A4           ; void DSM_build_data_packet(void)
 03A4           ; {
 03A4                   .dbline 297
 03A4           ; BYTE i;
 03A4           ;       //init header
 03A4           ;    if (DSM_Is_DSMX) {
 03A4 3C2900            cmp [_DSM_Is_DSMX],0
 03A7 A00C              jz L87
 03A9                   .dbline 298
 03A9           ;         tx_buf[0] = cyrfmfg_id[2];
 03A9                   .dbline 298
 03A9 5F0002            mov [_mem],[_cyrfmfg_id+2]
 03AC                   .dbline 299
 03AC           ;         tx_buf[1] = (cyrfmfg_id[3]+ModellNr);
 03AC 5103              mov A,[_cyrfmfg_id+3]
 03AE 0200              add A,[_ModellNr]
 03B0 5301              mov [_mem+1],A
 03B2                   .dbline 300
 03B2           ;     } else {
 03B2 800D              xjmp L88
 03B4           L87:
 03B4                   .dbline 300
 03B4                   .dbline 301
 03B4           ;         tx_buf[0] = ~cyrfmfg_id[2];
 03B4 5102              mov A,[_cyrfmfg_id+2]
 03B6 73                cpl A
 03B7 5300              mov [_mem],A
 03B9                   .dbline 302
 03B9           ;         tx_buf[1] = ~(cyrfmfg_id[3]+ModellNr);
 03B9 5103              mov A,[_cyrfmfg_id+3]
 03BB 0200              add A,[_ModellNr]
 03BD 73                cpl A
 03BE 5301              mov [_mem+1],A
 03C0                   .dbline 303
 03C0           ;     }
 03C0           L88:
 03C0                   .dbline 305
 03C0           ;       //fill data 
 03C0           ;     for (i = 0; i < 6; i++) 
 03C0 560000            mov [X+0],0
 03C3 803B              xjmp L98
 03C5           L95:
 03C5                   .dbline 306
 03C5           ;               {
 03C5                   .dbline 307
 03C5           ;               WORD val=Ch_Data[i];
 03C5 5200              mov A,[X+0]
 03C7 64                asl A
 03C8 0100              add A,<_Ch_Data
 03CA 5300              mov [__r1],A
 03CC 3E00              mvi A,[__r1]
 03CE 5401              mov [X+1],A
 03D0 3E00              mvi A,[__r1]
 03D2 5402              mov [X+2],A
 03D4                   .dbline 310
 03D4           ;               //input data is allways 11Bit
 03D4           ;               //so we need to shift down if we transmit DSM2 10Bit format
 03D4           ;               if(!DSM_Is_11Bit)
 03D4 3C2700            cmp [_DSM_Is_11Bit],0
 03D7 B007              jnz L99
 03D9                   .dbline 311
 03D9           ;                       val=val>>1;
 03D9 70FB              and F,-5
 03DB 6F01              rrc [X+1]
 03DD 6F02              rrc [X+2]
 03DF           L99:
 03DF                   .dbline 312
 03DF           ;               tx_buf[i*2+2]=val>>8;
 03DF 5201              mov A,[X+1]
 03E1 5300              mov [__r0],A
 03E3 5200              mov A,[X+0]
 03E5 64                asl A
 03E6 0102              add A,<_mem+2
 03E8 5300              mov [__r3],A
 03EA 5100              mov A,[__r0]
 03EC 3F00              mvi [__r3],A
 03EE                   .dbline 313
 03EE           ;               tx_buf[i*2+3]=val&0xFF;
 03EE 5202              mov A,[X+2]
 03F0 5300              mov [__r1],A
 03F2 5200              mov A,[X+0]
 03F4 64                asl A
 03F5 0103              add A,<_mem+3
 03F7 5300              mov [__r3],A
 03F9 5100              mov A,[__r1]
 03FB 3F00              mvi [__r3],A
 03FD                   .dbline 314
 03FD           ;               }
 03FD           L96:
 03FD                   .dbline 305
 03FD 7700              inc [X+0]
 03FF           L98:
 03FF                   .dbline 305
 03FF 3D0006            cmp [X+0],6
 0402 CFC2              jc L95
 0404           X3:
 0404                   .dbline 315
 0404           ;       tx_buf[14]=0xFF;
 0404 550EFF            mov [_mem+14],-1
 0407                   .dbline 316
 0407           ;       tx_buf[15]=0xFF;
 0407 550FFF            mov [_mem+15],-1
 040A                   .dbline -2
 040A           L86:
 040A 38FD              add SP,-3
 040C 20                pop X
 040D                   .dbline 0 ; func end
 040D 7F                ret
 040E                   .dbsym l val 1 i
 040E                   .dbsym l i 0 c
 040E                   .dbend
 040E                   .dbfunc e DSM_ClearRxError _DSM_ClearRxError fV
 040E           ;              i -> X+0
 040E           _DSM_ClearRxError::
 040E                   .dbline -1
 040E 10                push X
 040F 4F                mov X,SP
 0410 3801              add SP,1
 0412                   .dbline 321
 0412           ;  }
 0412           ; 
 0412           ; //clear recive error and pending interupt flags
 0412           ; void DSM_ClearRxError(void)
 0412           ; {
 0412                   .dbline 322
 0412           ;       BYTE i=100;
 0412 560064            mov [X+0],100
 0415                   .dbline 323
 0415           ;       CYRF_ReadRegister(CYRF_RX_IRQ_STATUS);
 0415 5007              mov A,7
 0417 08                push A
 0418 7C0000            xcall _CYRF_ReadRegister
 041B                   .dbline 324
 041B           ;       CYRF_ReadRegister(CYRF_RX_IRQ_STATUS);
 041B 5007              mov A,7
 041D 08                push A
 041E 7C0000            xcall _CYRF_ReadRegister
 0421 38FE              add SP,-2
 0423                   .dbline 325
 0423           ;       CYRF_WriteRegister(CYRF_RX_ABORT,ABORT_EN); //abort
 0423 5020              mov A,32
 0425 08                push A
 0426 5029              mov A,41
 0428 08                push A
 0429 7C0000            xcall _CYRF_WriteRegister
 042C                   .dbline 327
 042C           ;       //force end state
 042C           ;       CYRF_WriteRegister(CYRF_XACT_CFG,CYRF_XACT_END_STATE(CYRF_MODE_IDLE)|CYRF_FRC_END);
 042C 5024              mov A,36
 042E 08                push A
 042F 500F              mov A,15
 0431 08                push A
 0432 7C0000            xcall _CYRF_WriteRegister
 0435 38FC              add SP,-4
 0437 800A              xjmp L107
 0439           L106:
 0439                   .dbline 329
 0439           ;     while (! (CYRF_ReadRegister(CYRF_XACT_CFG) & CYRF_XACT_END_STATE(CYRF_MODE_IDLE))) 
 0439           ;       {
 0439                   .dbline 330
 0439           ;         if(!--i)
 0439 170001            sub [X+0],1
 043C 5200              mov A,[X+0]
 043E B003              jnz L109
 0440                   .dbline 331
 0440           ;             break;
 0440 8010              xjmp L108
 0442           L109:
 0442                   .dbline 332
 0442           ;       }
 0442           L107:
 0442                   .dbline 328
 0442 500F              mov A,15
 0444 08                push A
 0445 7C0000            xcall _CYRF_ReadRegister
 0448 38FF              add SP,-1
 044A 5300              mov [__r0],A
 044C 470004            tst [__r0],4
 044F AFE9              jz L106
 0451           L108:
 0451                   .dbline 334
 0451           ;       //clear abort
 0451           ;       CYRF_WriteRegister(CYRF_RX_ABORT,0);
 0451 5000              mov A,0
 0453 08                push A
 0454 5029              mov A,41
 0456 08                push A
 0457 7C0000            xcall _CYRF_WriteRegister
 045A 38FE              add SP,-2
 045C                   .dbline -2
 045C           L105:
 045C 38FF              add SP,-1
 045E 20                pop X
 045F                   .dbline 0 ; func end
 045F 7F                ret
 0460                   .dbsym l i 0 c
 0460                   .dbend
 0460                   .dbfunc e Rcv_cb _Rcv_cb fV
 0460           _Rcv_cb::
 0460                   .dbline -1
 0460                   .dbline 341
 0460           ; }
 0460           ; 
 0460           ; 
 0460           ; //called from timer
 0460           ; //see if we recived response from reciver
 0460           ; void Rcv_cb(void)
 0460           ; {
 0460                   .dbline 345
 0460           ; #ifdef DEBUG
 0460           ;       //TX8SW_1_CPutString("R");
 0460           ; #endif
 0460           ;       Bind_cnt--;
 0460 7A2A              dec [_Bind_cnt]
 0462                   .dbline 347
 0462           ;       //check if time is over
 0462           ;       if(!Bind_cnt)
 0462 3C2A00            cmp [_Bind_cnt],0
 0465 B01E              jnz L112
 0467                   .dbline 349
 0467           ;       {
 0467           ;               Timer_Stop();
 0467                   .dbline 349
 0467 10                push X
 0468 7C0000            xcall _Counter16_1_Stop
 046B 20                pop X
 046C                   .dbline 351
 046C           ;               //if we got no response abbort RX and clear anny rx error
 046C           ;               if(!RX_Response)
 046C 3C0900            cmp [_RX_Response],0
 046F B011              jnz L114
 0471                   .dbline 353
 0471           ;               {
 0471           ;                       DSM_ClearRxError();
 0471                   .dbline 353
 0471 9F9B              xcall _DSM_ClearRxError
 0473                   .dbline 355
 0473           ;                       //fallback to DSM2 10Bit 22ms if not forced 
 0473           ;                       if(!DSM_Is_Forced)
 0473 3C2600            cmp [_DSM_Is_Forced],0
 0476 B00A              jnz L116
 0478                   .dbline 357
 0478           ;                       {
 0478           ;                               DSM_Is_DSMX=FALSE;
 0478                   .dbline 357
 0478 552900            mov [_DSM_Is_DSMX],0
 047B                   .dbline 358
 047B           ;                               DSM_Is_11Bit=FALSE;
 047B 552700            mov [_DSM_Is_11Bit],0
 047E                   .dbline 359
 047E           ;                               DSM_Is_11ms=FALSE;
 047E 552800            mov [_DSM_Is_11ms],0
 0481                   .dbline 360
 0481           ;                       }
 0481           L116:
 0481                   .dbline 361
 0481           ;               }
 0481           L114:
 0481                   .dbline 362
 0481           ;       State=DSM_STATE_TRANSMIT;
 0481 550502            mov [_State],2
 0484                   .dbline 377
 0484           ; #ifdef DEBUG
 0484           ;       /*if(DSM_Is_DSMX)
 0484           ;               TX8SW_1_CPutString("DSMX ");
 0484           ;       else
 0484           ;               TX8SW_1_CPutString("DSM2 ");
 0484           ;       if(DSM_Is_11ms)
 0484           ;               TX8SW_1_CPutString("11ms ");
 0484           ;       else
 0484           ;               TX8SW_1_CPutString("22ms ");
 0484           ;       if(DSM_Is_11Bit)
 0484           ;               TX8SW_1_CPutString("11Bit ");
 0484           ;       else
 0484           ;               TX8SW_1_CPutString("10Bit ");*/
 0484           ; #endif
 0484           ;       }
 0484           L112:
 0484                   .dbline -2
 0484           L111:
 0484                   .dbline 0 ; func end
 0484 7F                ret
 0485                   .dbend
 0485                   .dbfunc e DSM_StartBindRcv _DSM_StartBindRcv fV
 0485           _DSM_StartBindRcv::
 0485                   .dbline -1
 0485                   .dbline 382
 0485           ; }
 0485           ; 
 0485           ; //start waiting for the bind recive signal
 0485           ; void DSM_StartBindRcv(void)
 0485           ; {
 0485                   .dbline 383
 0485           ;       State=DSM_STATE_BIND_RCV;
 0485 550501            mov [_State],1
 0488                   .dbline 384
 0488           ;       Timer_SetCallback(Rcv_cb);
 0488 5006              mov A,>PL_Rcv_cb
 048A 08                push A
 048B 5006              mov A,<PL_Rcv_cb
 048D 08                push A
 048E 7C0000            xcall _Timer_SetCallback
 0491                   .dbline 385
 0491           ;     CYRF_SetDataCode(pn_bind, 16);
 0491 5010              mov A,16
 0493 08                push A
 0494 5000              mov A,>_pn_bind
 0496 08                push A
 0497 5000              mov A,<_pn_bind
 0499 08                push A
 049A 5023              mov A,35
 049C 08                push A
 049D 7C0000            xcall _CYRF_WriteRegisterMulti
 04A0 38FA              add SP,-6
 04A2                   .dbline 386
 04A2           ;       Bind_cnt=DSM_BIND_RCV_CNT;
 04A2 552A1E            mov [_Bind_cnt],30
 04A5                   .dbline 387
 04A5           ;       CYRF_StartReceive();
 04A5 5083              mov A,-125
 04A7 08                push A
 04A8 5005              mov A,5
 04AA 08                push A
 04AB 7C0000            xcall _CYRF_WriteRegister
 04AE                   .dbline 388
 04AE           ;       CYRF_ReadRSSI();
 04AE 5013              mov A,19
 04B0 08                push A
 04B1 7C0000            xcall _CYRF_ReadRegister
 04B4 38FD              add SP,-3
 04B6                   .dbline -2
 04B6           L118:
 04B6                   .dbline 0 ; func end
 04B6 7F                ret
 04B7                   .dbend
 04B7                   .dbfunc e DSM_Cyclic _DSM_Cyclic fV
 04B7           ;              i -> X+7
 04B7           ;         rx_cnt -> X+6
 04B7           ;          ckSum -> X+4
 04B7           ;     Irq_Status -> X+0
 04B7           _DSM_Cyclic::
 04B7                   .dbline -1
 04B7 10                push X
 04B8 4F                mov X,SP
 04B9 380C              add SP,12
 04BB                   .dbline 394
 04BB           ; }
 04BB           ; 
 04BB           ; 
 04BB           ; 
 04BB           ; void DSM_Cyclic(void)
 04BB           ; {
 04BB                   .dbline 395
 04BB           ;       if(CY_irq) //we got an IRQ from CYRF6936
 04BB 3C0000            cmp [_CY_irq],0
 04BE A16F              jz L120
 04C0                   .dbline 397
 04C0           ;       {
 04C0           ;               BYTE Irq_Status[2];
 04C0                   .dbline 398
 04C0           ;               CY_irq=FALSE;
 04C0 550000            mov [_CY_irq],0
 04C3                   .dbline 405
 04C3           ; #ifdef DEBUG
 04C3           ;               //DIAG_OUT1_Invert();
 04C3           ;               //DIAG_OUT1_Invert();
 04C3           ;               //TX8SW_1_CPutString("I");
 04C3           ; #endif
 04C3           ;               
 04C3           ;               switch(State)
 04C3 5105              mov A,[_State]
 04C5 5403              mov [X+3],A
 04C7 560200            mov [X+2],0
 04CA 3D0200            cmp [X+2],0
 04CD B006              jnz X4
 04CF 3D0300            cmp [X+3],0
 04D2 A00D              jz L125
 04D4           X4:
 04D4 3D0200            cmp [X+2],0
 04D7 B006              jnz X5
 04D9 3D0301            cmp [X+3],1
 04DC A028              jz L131
 04DE           X5:
 04DE 8121              xjmp L122
 04E0           L125:
 04E0                   .dbline 408
 04E0           ;               {
 04E0           ;                       case DSM_STATE_BIND:
 04E0           ;                       {
 04E0                   .dbline 410
 04E0           ;                               //read IRQ status
 04E0           ;                               CYRF_ReadRegisterMulti(CYRF_TX_IRQ_STATUS,Irq_Status,2);
 04E0 5002              mov A,2
 04E2 08                push A
 04E3 5100              mov A,[__r0]
 04E5 08                push A
 04E6 10                push X
 04E7 5004              mov A,4
 04E9 08                push A
 04EA 7C0000            xcall _CYRF_ReadRegisterMulti
 04ED 38FC              add SP,-4
 04EF                   .dbline 411
 04EF           ;                               Irq_Status[0]|=Irq_Status[1]&TXE_IRQ;
 04EF 5201              mov A,[X+1]
 04F1 2101              and A,1
 04F3 2D00              or [X+0],A
 04F5                   .dbline 413
 04F5           ;                               //TX done
 04F5           ;                               if(Irq_Status[0]&TXC_IRQ)
 04F5 480002            tst [X+0],2
 04F8 A135              jz L119
 04FA                   .dbline 415
 04FA           ;                                       {
 04FA           ;                                               Bind_cnt--;
 04FA                   .dbline 415
 04FA 7A2A              dec [_Bind_cnt]
 04FC                   .dbline 417
 04FC           ;                                               //check if we are done (time is over)
 04FC           ;                                               if(!Bind_cnt)
 04FC 3C2A00            cmp [_Bind_cnt],0
 04FF B12E              jnz L119
 0501                   .dbline 420
 0501           ;                                               {
 0501           ;                                                       //start reciving the response
 0501           ;                                                       DSM_StartBindRcv();
 0501                   .dbline 420
 0501 9F82              xcall _DSM_StartBindRcv
 0503                   .dbline 421
 0503           ;                                               }
 0503                   .dbline 422
 0503           ;                                       }       
 0503                   .dbline 423
 0503           ;                       }
 0503                   .dbline 424
 0503           ;                       return;
 0503 812A              xjmp L119
 0505           L131:
 0505                   .dbline 426
 0505           ;                       case DSM_STATE_BIND_RCV:
 0505           ;                               {
 0505                   .dbline 428
 0505           ;                                       //read IRQ status
 0505           ;                                       CYRF_ReadRegisterMulti(CYRF_RX_IRQ_STATUS,Irq_Status,2);
 0505 5002              mov A,2
 0507 08                push A
 0508 5100              mov A,[__r0]
 050A 08                push A
 050B 10                push X
 050C 5007              mov A,7
 050E 08                push A
 050F 7C0000            xcall _CYRF_ReadRegisterMulti
 0512 38FC              add SP,-4
 0514                   .dbline 429
 0514           ;                                       Irq_Status[0]|=Irq_Status[1]&RXE_IRQ;
 0514 5201              mov A,[X+1]
 0516 2101              and A,1
 0518 2D00              or [X+0],A
 051A                   .dbline 430
 051A           ;                                       if(Irq_Status[0]&RXC_IRQ)
 051A 480002            tst [X+0],2
 051D A110              jz L119
 051F                   .dbline 433
 051F           ;                                       {
 051F           ;                                               //we got some thing
 051F           ;                                               BYTE i;
 051F                   .dbline 434
 051F           ;                                       WORD ckSum = 0x170;
 051F 560570            mov [X+5],112
 0522 560401            mov [X+4],1
 0525                   .dbline 436
 0525           ;                                               
 0525           ;                                               BYTE rx_cnt=CYRF_Rx_cnt();
 0525 5009              mov A,9
 0527 08                push A
 0528 7C0000            xcall _CYRF_ReadRegister
 052B 5406              mov [X+6],A
 052D                   .dbline 441
 052D           ; #ifdef DEBUG
 052D           ;                                               //TX8SW_1_CPutString("i");
 052D           ; #endif
 052D           ;                                               //read it in
 052D           ;                                               CYRF_ReadRx_data(rx_buf,rx_cnt);
 052D 5206              mov A,[X+6]
 052F 08                push A
 0530 5010              mov A,>_mem+16
 0532 08                push A
 0533 5010              mov A,<_mem+16
 0535 08                push A
 0536 5021              mov A,33
 0538 08                push A
 0539 7C0000            xcall _CYRF_ReadRegisterMulti
 053C 38FB              add SP,-5
 053E                   .dbline 443
 053E           ;                                               //check recived data
 053E           ;                                               if(rx_cnt!=10)
 053E 3D060A            cmp [X+6],10
 0541 A003              jz L136
 0543                   .dbline 445
 0543           ;                                               {
 0543           ;                                                       goto rcv_error;
 0543                   .dbline 445
 0543 80B6              xjmp L138
 0545           L136:
 0545                   .dbline 450
 0545           ;                                               }
 0545           ; #ifdef DEBUG
 0545           ;                                               //TX8SW_1_CPutString("a");
 0545           ; #endif
 0545           ;                                               if(rx_buf[0]!=bind_buf[0] || rx_buf[1]!=bind_buf[1] || rx_buf[2]!=bind_buf[2] || rx_buf[3]!=bind_buf[3])
 0545 5110              mov A,[_mem+16]
 0547 3A00              cmp A,[_mem]
 0549 B013              jnz L153
 054B 5111              mov A,[_mem+16+1]
 054D 3A01              cmp A,[_mem+1]
 054F B00D              jnz L153
 0551 5112              mov A,[_mem+16+2]
 0553 3A02              cmp A,[_mem+2]
 0555 B007              jnz L153
 0557 5113              mov A,[_mem+16+3]
 0559 3A03              cmp A,[_mem+3]
 055B A003              jz L139
 055D           L153:
 055D                   .dbline 452
 055D           ;                                               {
 055D           ;                                                       goto rcv_error;
 055D                   .dbline 452
 055D 809C              xjmp L138
 055F           L139:
 055F                   .dbline 457
 055F           ;                                               }
 055F           ; #ifdef DEBUG
 055F           ;                                               //TX8SW_1_CPutString("b");
 055F           ; #endif
 055F           ;                                               for (i = 0; i < 8; i++)
 055F 560700            mov [X+7],0
 0562 8012              xjmp L157
 0564           L154:
 0564                   .dbline 458
 0564           ;                                                ckSum += rx_buf[i];
 0564 5207              mov A,[X+7]
 0566 0110              add A,<_mem+16
 0568 5300              mov [__r1],A
 056A 3E00              mvi A,[__r1]
 056C 0505              add [X+5],A
 056E 5000              mov A,0
 0570 0F0400            adc [X+4],0
 0573           L155:
 0573                   .dbline 457
 0573 7707              inc [X+7]
 0575           L157:
 0575                   .dbline 457
 0575 3D0708            cmp [X+7],8
 0578 CFEB              jc L154
 057A           X6:
 057A                   .dbline 459
 057A           ;                                               if(rx_buf[8] != (ckSum >> 8) || rx_buf[9] !=(ckSum & 0xff))
 057A 5204              mov A,[X+4]
 057C 5300              mov [__r1],A
 057E 550000            mov [__r0],0
 0581 5F0018            mov [__r3],[_mem+16+8]
 0584 5000              mov A,0
 0586 3A00              cmp A,[__r0]
 0588 B01D              jnz L165
 058A 5100              mov A,[__r3]
 058C 3A00              cmp A,[__r1]
 058E B017              jnz L165
 0590           X7:
 0590 5205              mov A,[X+5]
 0592 5300              mov [__r1],A
 0594 550000            mov [__r0],0
 0597 5F0019            mov [__r3],[_mem+16+9]
 059A 5000              mov A,0
 059C 3A00              cmp A,[__r0]
 059E B007              jnz X8
 05A0 5100              mov A,[__r3]
 05A2 3A00              cmp A,[__r1]
 05A4 A003              jz L159
 05A6           X8:
 05A6           L165:
 05A6                   .dbline 461
 05A6           ;                                               {
 05A6           ;                                                       goto rcv_error;
 05A6                   .dbline 461
 05A6 8053              xjmp L138
 05A8           L159:
 05A8                   .dbline 470
 05A8           ;                                               }
 05A8           ; #ifdef DEBUG
 05A8           ;                                               //TX8SW_1_CPutString("c");
 05A8           ; #endif
 05A8           ;                                               //I have no Ida what to do with the channel count the reciver send us
 05A8           ;                                               //dsmNumChannels=packet[5];
 05A8           ;                                               
 05A8           ;                                               //if transmitter is not forced determin operation mode
 05A8           ;                                               if(!DSM_Is_Forced)
 05A8 3C2600            cmp [_DSM_Is_Forced],0
 05AB B049              jnz L166
 05AD                   .dbline 472
 05AD           ;                                                       {
 05AD           ;                                                       DSM_Is_DSMX=PROTOC_IS_DSMX(rx_buf[6]);
 05AD                   .dbline 472
 05AD 5116              mov A,[_mem+16+6]
 05AF 21A0              and A,-96
 05B1 39A0              cmp A,-96
 05B3 B009              jnz L171
 05B5 560901            mov [X+9],1
 05B8 560800            mov [X+8],0
 05BB 8007              xjmp L172
 05BD           L171:
 05BD 560900            mov [X+9],0
 05C0 560800            mov [X+8],0
 05C3           L172:
 05C3 5209              mov A,[X+9]
 05C5 5329              mov [_DSM_Is_DSMX],A
 05C7                   .dbline 473
 05C7           ;                                                       DSM_Is_11Bit = PROTOC_IS_DSM_11BIT(rx_buf[6]);
 05C7 5116              mov A,[_mem+16+6]
 05C9 2130              and A,48
 05CB 67                asr A
 05CC 67                asr A
 05CD 67                asr A
 05CE 67                asr A
 05CF 210F              and A,15
 05D1 5327              mov [_DSM_Is_11Bit],A
 05D3                   .dbline 474
 05D3           ;                                                       DSM_Is_11ms=PROTOC_IS_DSM_11MS(rx_buf[6]);
 05D3 5116              mov A,[_mem+16+6]
 05D5 21B2              and A,-78
 05D7 3902              cmp A,2
 05D9 A009              jz L182
 05DB 5116              mov A,[_mem+16+6]
 05DD 21B2              and A,-78
 05DF 39B2              cmp A,-78
 05E1 B009              jnz L180
 05E3           L182:
 05E3 560B01            mov [X+11],1
 05E6 560A00            mov [X+10],0
 05E9 8007              xjmp L181
 05EB           L180:
 05EB 560B00            mov [X+11],0
 05EE 560A00            mov [X+10],0
 05F1           L181:
 05F1 520B              mov A,[X+11]
 05F3 5328              mov [_DSM_Is_11ms],A
 05F5                   .dbline 475
 05F5           ;                                                       }
 05F5           L166:
 05F5                   .dbline 476
 05F5           ;                                               RX_Response=TRUE;
 05F5 550901            mov [_RX_Response],1
 05F8                   .dbline 480
 05F8           ; #ifdef DEBUG
 05F8           ;                                               TX8SW_1_PutSHexByte(rx_buf[6]); 
 05F8           ; #endif
 05F8           ;                                       }                       
 05F8                   .dbline 481
 05F8           ;                               return;                 
 05F8 8035              xjmp L119
 05FA           L138:
 05FA                   .dbline 484
 05FA           ;                               }
 05FA           ;                               rcv_error:
 05FA           ;                                       DSM_ClearRxError();
 05FA 9E12              xcall _DSM_ClearRxError
 05FC                   .dbline 485
 05FC           ;                                       DSM_StartBindRcv();
 05FC 9E87              xcall _DSM_StartBindRcv
 05FE                   .dbline 486
 05FE           ;                               return;
 05FE 802F              xjmp L119
 0600           L122:
 0600                   .dbline 488
 0600           ;                       default:
 0600           ;                               { //transmit Mode
 0600                   .dbline 490
 0600           ;                               //get IRQ Status
 0600           ;                               CYRF_ReadRegisterMulti(CYRF_TX_IRQ_STATUS,Irq_Status,2);
 0600 5002              mov A,2
 0602 08                push A
 0603 5100              mov A,[__r0]
 0605 08                push A
 0606 10                push X
 0607 5004              mov A,4
 0609 08                push A
 060A 7C0000            xcall _CYRF_ReadRegisterMulti
 060D 38FC              add SP,-4
 060F                   .dbline 491
 060F           ;                               Irq_Status[0]|=Irq_Status[1]&TXE_IRQ;
 060F 5201              mov A,[X+1]
 0611 2101              and A,1
 0613 2D00              or [X+0],A
 0615                   .dbline 493
 0615           ;                               //tx done
 0615           ;                               if(Irq_Status[0]&TXC_IRQ)
 0615 480002            tst [X+0],2
 0618 A015              jz L184
 061A                   .dbline 497
 061A           ;                                       {
 061A           ;                                       //tx done
 061A           ;                                               //set timer for next transmit
 061A           ;                                               SetTimer();
 061A                   .dbline 497
 061A 9A03              xcall _SetTimer
 061C                   .dbline 502
 061C           ; #ifdef DEBUG
 061C           ;                                               //TX8SW_1_CPutString("C");
 061C           ; #endif
 061C           ;                                               //calculate and set channel SOP , CRC and data code
 061C           ;                                               SetCH_CRC_SOP_DATA();
 061C 9A1E              xcall _SetCH_CRC_SOP_DATA
 061E                   .dbline 503
 061E           ;                                               if(!Ch_A)
 061E 3C0800            cmp [_Ch_A],0
 0621 B00C              jnz L186
 0623                   .dbline 505
 0623           ;                                               {
 0623           ;                                                       CYRF_WriteRegister(CYRF_TX_CFG,tx_cfg); //update TX power 
 0623                   .dbline 505
 0623 5103              mov A,[_tx_cfg]
 0625 08                push A
 0626 5003              mov A,3
 0628 08                push A
 0629 7C0000            xcall _CYRF_WriteRegister
 062C 38FE              add SP,-2
 062E                   .dbline 506
 062E           ;                                               }
 062E           L186:
 062E                   .dbline 507
 062E           ;                                       }       
 062E           L184:
 062E                   .dbline 508
 062E           ;                               }
 062E                   .dbline 509
 062E           ;               }
 062E                   .dbline 510
 062E           ;       }
 062E           L120:
 062E                   .dbline -2
 062E           L119:
 062E 38F4              add SP,-12
 0630 20                pop X
 0631                   .dbline 0 ; func end
 0631 7F                ret
 0632                   .dbsym l i 7 c
 0632                   .dbsym l rx_cnt 6 c
 0632                   .dbsym l ckSum 4 i
 0632                   .dbsym l Irq_Status 0 A[2:2]c
 0632                   .dbend
 0632                   .dbfunc e DSM_NewSerialData _DSM_NewSerialData fV
 0632           ;           time -> X+4
 0632           ;     Freq_Error -> X+2
 0632           ;    Phase_Error -> X+0
 0632           _DSM_NewSerialData::
 0632                   .dbline -1
 0632 10                push X
 0633 4F                mov X,SP
 0634 3806              add SP,6
 0636                   .dbline 516
 0636           ; }
 0636           ; 
 0636           ; 
 0636           ; //called if there is new serial data
 0636           ; void DSM_NewSerialData(void)
 0636           ; {
 0636                   .dbline 520
 0636           ;       int Phase_Error;        
 0636           ;       int Freq_Error;
 0636           ;               //if we are in the windows for reciving data proceed
 0636           ;               if(DSM_ready_for_Serial)
 0636 3C2500            cmp [_DSM_ready_for_Serial],0
 0639 A097              jz L189
 063B                   .dbline 523
 063B           ;               {
 063B           ;                       //get time left till next transmit, shall be 2ms
 063B           ;                       WORD time=Counter16_1_wReadCounter();
 063B                   .dbline 523
 063B 10                push X
 063C 7C0000            xcall _Counter16_1_wReadCounter
 063F 5A00              mov [__r0],X
 0641 20                pop X
 0642 5405              mov [X+5],A
 0644 5100              mov A,[__r0]
 0646 5404              mov [X+4],A
 0648                   .dbline 525
 0648           ;                       //we need at least one ms for building the package
 0648           ;                       if(time>DSM_TIME11MS && !DSM_Is_11ms )//&& ((Ch_Data[dsm_Max_pos]>>11)+1)==num_channels)
 0648 5058              mov A,88
 064A 1305              sub A,[X+5]
 064C 501B              mov A,27
 064E 1B04              sbb A,[X+4]
 0650 D008              jnc L191
 0652           X9:
 0652 3C2800            cmp [_DSM_Is_11ms],0
 0655 B003              jnz L191
 0657                   .dbline 530
 0657           ;                               { //ignore extra data (transmitter running 11ms while reciver expect 11ms)
 0657           ; #ifdef DEBUG
 0657           ;                               TX8SW_1_CPutString("Q");
 0657           ; #endif
 0657           ;                               return;
 0657                   .dbline 530
 0657 80A3              xjmp L188
 0659           L191:
 0659                   .dbline 532
 0659           ;                               }
 0659           ;                       if(time>200)
 0659 50C8              mov A,-56
 065B 1305              sub A,[X+5]
 065D 5000              mov A,0
 065F 1B04              sbb A,[X+4]
 0661 D003              jnc L193
 0663           X10:
 0663                   .dbline 534
 0663           ;                       {
 0663           ;                               DSM_build_data_packet();
 0663                   .dbline 534
 0663 9D3B              xcall _DSM_build_data_packet
 0665                   .dbline 538
 0665           ; #ifdef DEBUG
 0665           ;                               TX8SW_1_CPutString("P");
 0665           ; #endif
 0665           ;                       }
 0665           L193:
 0665                   .dbline 543
 0665           ; #ifdef DEBUG
 0665           ;                               TX8SW_1_CPutString("S");
 0665           ; #endif
 0665           ;               //calculate pahse error 
 0665           ;               Phase_Error=DSM_SER_TO_XMIT_TIME-time;
 0665 50D0              mov A,-48
 0667 1305              sub A,[X+5]
 0669 5300              mov [__r1],A
 066B 5007              mov A,7
 066D 1B04              sbb A,[X+4]
 066F 5300              mov [__r0],A
 0671 5100              mov A,[__r1]
 0673 5401              mov [X+1],A
 0675 5100              mov A,[__r0]
 0677 5400              mov [X+0],A
 0679                   .dbline 547
 0679           ;               //calculate frequency error
 0679           ;               //instead off measuring the perriode and the transmision perriode
 0679           ;               //wee use the change the Phase Error to calculate the frequency error
 0679           ;               Freq_Error=Phase_Error-Last_Phase_error;
 0679 5201              mov A,[X+1]
 067B 1202              sub A,[_Last_Phase_error+1]
 067D 5403              mov [X+3],A
 067F 5200              mov A,[X+0]
 0681 1A01              sbb A,[_Last_Phase_error]
 0683 5402              mov [X+2],A
 0685                   .dbline 549
 0685           ;               //save corrent error as last
 0685           ;               Last_Phase_error=Phase_Error;
 0685 5201              mov A,[X+1]
 0687 5302              mov [_Last_Phase_error+1],A
 0689 5200              mov A,[X+0]
 068B 5301              mov [_Last_Phase_error],A
 068D                   .dbline 551
 068D           ;               //simple double P-Term loop.
 068D           ;               DSM_Perriode+=Freq_Error>>3;
 068D 5203              mov A,[X+3]
 068F 5300              mov [__r1],A
 0691 5202              mov A,[X+2]
 0693 67                asr A
 0694 5300              mov [__r0],A
 0696 6E00              rrc [__r1]
 0698 6800              asr [__r0]
 069A 6E00              rrc [__r1]
 069C 6800              asr [__r0]
 069E 6E00              rrc [__r1]
 06A0 5100              mov A,[__r1]
 06A2 0424              add [_DSM_Perriode+1],A
 06A4 5100              mov A,[__r0]
 06A6 0C23              adc [_DSM_Perriode],A
 06A8                   .dbline 552
 06A8           ;               DSM_Perriode+=Phase_Error>>6;
 06A8 5201              mov A,[X+1]
 06AA 5300              mov [__r1],A
 06AC 5200              mov A,[X+0]
 06AE 67                asr A
 06AF 5300              mov [__r0],A
 06B1 6E00              rrc [__r1]
 06B3 6800              asr [__r0]
 06B5 6E00              rrc [__r1]
 06B7 6800              asr [__r0]
 06B9 6E00              rrc [__r1]
 06BB 6800              asr [__r0]
 06BD 6E00              rrc [__r1]
 06BF 6800              asr [__r0]
 06C1 6E00              rrc [__r1]
 06C3 6800              asr [__r0]
 06C5 6E00              rrc [__r1]
 06C7 5100              mov A,[__r1]
 06C9 0424              add [_DSM_Perriode+1],A
 06CB 5100              mov A,[__r0]
 06CD 0C23              adc [_DSM_Perriode],A
 06CF                   .dbline 560
 06CF           ; #ifdef DEBUG
 06CF           ;                       if(Phase_Error>200)
 06CF           ;                               TX8SW_1_CPutString("p");
 06CF           ;                       if(Phase_Error<-300)
 06CF           ;                               TX8SW_1_CPutString("m");
 06CF           ; #endif
 06CF           ;               
 06CF           ;               }
 06CF 8029              xjmp L190
 06D1           L189:
 06D1                   .dbline 562
 06D1           ;               else //lost sync
 06D1           ;               {
 06D1                   .dbline 573
 06D1           ;               //serial data came in at a time we did not expected it
 06D1           ;               //porbably we are out of sync
 06D1           ;               //resync
 06D1           ; #ifdef DEBUG
 06D1           ;                       TX8SW_1_CPutString("L");
 06D1           ;                       //DIAG_OUT1_Switch(0);
 06D1           ; #endif
 06D1           ;                       //manual inline
 06D1           ;                       //DSM_StartTransmit();
 06D1           ;                       //void DSM_StartTransmit(void)
 06D1           ;                       {
 06D1                   .dbline 574
 06D1           ;                               State=DSM_STATE_TRANSMIT;
 06D1 550502            mov [_State],2
 06D4                   .dbline 575
 06D4           ;                               Timer_SetCallback(Send_Xmit_cb);
 06D4 5004              mov A,>PL_Send_Xmit_cb
 06D6 08                push A
 06D7 5004              mov A,<PL_Send_Xmit_cb
 06D9 08                push A
 06DA 7C0000            xcall _Timer_SetCallback
 06DD 38FE              add SP,-2
 06DF                   .dbline 578
 06DF           ;                               //to set timer current value we need to
 06DF           ;                               //stop timer ans set period instead
 06DF           ;                               Timer_Stop();
 06DF 10                push X
 06E0 7C0000            xcall _Counter16_1_Stop
 06E3                   .dbline 579
 06E3           ;                               Timer_SetPeriod(DSM_SER_TO_XMIT_TIME);
 06E3 5707              mov X,7
 06E5 50D0              mov A,-48
 06E7 7C0000            xcall _Counter16_1_WritePeriod
 06EA                   .dbline 581
 06EA           ;                               //start timer
 06EA           ;                               Timer_Start();
 06EA 7C0000            xcall _Counter16_1_Start
 06ED 20                pop X
 06EE                   .dbline 582
 06EE           ;                               Last_Phase_error=0;
 06EE 550200            mov [_Last_Phase_error+1],0
 06F1 550100            mov [_Last_Phase_error],0
 06F4                   .dbline 583
 06F4           ;                               Ch_A=TRUE;
 06F4 550801            mov [_Ch_A],1
 06F7                   .dbline 584
 06F7           ;                               SetTimer();
 06F7 9926              xcall _SetTimer
 06F9                   .dbline 585
 06F9           ;                       }
 06F9                   .dbline 586
 06F9           ;               }
 06F9           L190:
 06F9                   .dbline 587
 06F9           ;               DSM_build_data_packet();
 06F9 9CA5              xcall _DSM_build_data_packet
 06FB                   .dbline -2
 06FB           L188:
 06FB 38FA              add SP,-6
 06FD 20                pop X
 06FE                   .dbline 0 ; func end
 06FE 7F                ret
 06FF                   .dbsym l time 4 i
 06FF                   .dbsym l Freq_Error 2 I
 06FF                   .dbsym l Phase_Error 0 I
 06FF                   .dbend
 06FF                   .dbfunc e calc_dsmx_channel _calc_dsmx_channel fV
 06FF           ;    count_52_76 -> X+20
 06FF           ;    count_28_51 -> X+18
 06FF           ;     count_3_27 -> X+16
 06FF           ;        next_ch -> X+15
 06FF           ;              i -> X+13
 06FF           ;             id -> X+5
 06FF           ;         id_tmp -> X+1
 06FF           ;            idx -> X+0
 06FF           _calc_dsmx_channel::
 06FF                   .dbline -1
 06FF 10                push X
 0700 4F                mov X,SP
 0701 3816              add SP,22
 0703                   .dbline 595
 0703           ; }
 0703           ; 
 0703           ; //calculate dsmX channels 
 0703           ; //found on deviation-tx source
 0703           ; // math by Alexandr Alexandrov code by Sergey Gimaev
 0703           ; //pseudo random gennerator /Linear congruential generator based on "Numerical Recipes" Chapter 7.1
 0703           ; void calc_dsmx_channel(void)
 0703           ; {
 0703                   .dbline 598
 0703           ;     BYTE idx; 
 0703           ;       DWORD id_tmp;
 0703           ;     DWORD id = ~(((DWORD)cyrfmfg_id[0] << 24) | ((DWORD)cyrfmfg_id[1] << 16) | ((DWORD)cyrfmfg_id[2] << 8) | (((DWORD)cyrfmfg_id[3]+ModellNr) << 0));
 0703 5F0000            mov [__r3],[_ModellNr]
 0706 550000            mov [__r2],0
 0709 550000            mov [__r1],0
 070C 550000            mov [__r0],0
 070F 5103              mov A,[_cyrfmfg_id+3]
 0711 0200              add A,[__r3]
 0713 5300              mov [__r3],A
 0715 5000              mov A,0
 0717 0A00              adc A,[__r2]
 0719 5300              mov [__r2],A
 071B 5000              mov A,0
 071D 0A00              adc A,[__r1]
 071F 5300              mov [__r1],A
 0721 5000              mov A,0
 0723 0A00              adc A,[__r0]
 0725 5409              mov [X+9],A
 0727 5100              mov A,[__r1]
 0729 540A              mov [X+10],A
 072B 5100              mov A,[__r2]
 072D 540B              mov [X+11],A
 072F 5100              mov A,[__r3]
 0731 540C              mov [X+12],A
 0733 5F0002            mov [__r7],[_cyrfmfg_id+2]
 0736 550000            mov [__r6],0
 0739 550000            mov [__r5],0
 073C 550000            mov [__r4],0
 073F 5008              mov A,8
 0741           X11:
 0741 6500              asl [__r7]
 0743 6B00              rlc [__r6]
 0745 6B00              rlc [__r5]
 0747 6B00              rlc [__r4]
 0749 78                dec A
 074A BFF6              jnz X11
 074C 5F0001            mov [__r11],[_cyrfmfg_id+1]
 074F 550000            mov [__r10],0
 0752 550000            mov [__r9],0
 0755 550000            mov [__r8],0
 0758 5010              mov A,16
 075A           X12:
 075A 6500              asl [__r11]
 075C 6B00              rlc [__r10]
 075E 6B00              rlc [__r9]
 0760 6B00              rlc [__r8]
 0762 78                dec A
 0763 BFF6              jnz X12
 0765 5F0000            mov [__r3],[_cyrfmfg_id]
 0768 550000            mov [__r2],0
 076B 550000            mov [__r1],0
 076E 550000            mov [__r0],0
 0771 5018              mov A,24
 0773           X13:
 0773 6500              asl [__r3]
 0775 6B00              rlc [__r2]
 0777 6B00              rlc [__r1]
 0779 6B00              rlc [__r0]
 077B 78                dec A
 077C BFF6              jnz X13
 077E 5100              mov A,[__r11]
 0780 2C00              or [__r3],A
 0782 5100              mov A,[__r10]
 0784 2C00              or [__r2],A
 0786 5100              mov A,[__r9]
 0788 2C00              or [__r1],A
 078A 5100              mov A,[__r8]
 078C 2C00              or [__r0],A
 078E 5100              mov A,[__r7]
 0790 2C00              or [__r3],A
 0792 5100              mov A,[__r6]
 0794 2C00              or [__r2],A
 0796 5100              mov A,[__r5]
 0798 2C00              or [__r1],A
 079A 5100              mov A,[__r4]
 079C 2C00              or [__r0],A
 079E 520C              mov A,[X+12]
 07A0 2C00              or [__r3],A
 07A2 520B              mov A,[X+11]
 07A4 2C00              or [__r2],A
 07A6 520A              mov A,[X+10]
 07A8 2C00              or [__r1],A
 07AA 5209              mov A,[X+9]
 07AC 2C00              or [__r0],A
 07AE 5100              mov A,[__r0]
 07B0 73                cpl A
 07B1 5405              mov [X+5],A
 07B3 5100              mov A,[__r1]
 07B5 73                cpl A
 07B6 5406              mov [X+6],A
 07B8 5100              mov A,[__r2]
 07BA 73                cpl A
 07BB 5407              mov [X+7],A
 07BD 5100              mov A,[__r3]
 07BF 73                cpl A
 07C0 5408              mov [X+8],A
 07C2                   .dbline 599
 07C2           ;       idx = 0;
 07C2 560000            mov [X+0],0
 07C5                   .dbline 600
 07C5           ;     id_tmp = id;
 07C5 5205              mov A,[X+5]
 07C7 5401              mov [X+1],A
 07C9 5206              mov A,[X+6]
 07CB 5402              mov [X+2],A
 07CD 5207              mov A,[X+7]
 07CF 5403              mov [X+3],A
 07D1 5208              mov A,[X+8]
 07D3 5404              mov [X+4],A
 07D5 819B              xjmp L200
 07D7           L199:
 07D7                   .dbline 601
 07D7           ;     while(idx < 23) {
 07D7                   .dbline 604
 07D7           ;         int i;
 07D7           ;         BYTE next_ch;
 07D7           ;               int count_3_27 = 0, count_28_51 = 0, count_52_76 = 0;
 07D7 561100            mov [X+17],0
 07DA 561000            mov [X+16],0
 07DD                   .dbline 604
 07DD 561300            mov [X+19],0
 07E0 561200            mov [X+18],0
 07E3                   .dbline 604
 07E3 561500            mov [X+21],0
 07E6 561400            mov [X+20],0
 07E9                   .dbline 605
 07E9           ;         id_tmp = id_tmp * 0x0019660D + 0x3C6EF35F; // Randomization
 07E9 5201              mov A,[X+1]
 07EB 08                push A
 07EC 5202              mov A,[X+2]
 07EE 08                push A
 07EF 5203              mov A,[X+3]
 07F1 08                push A
 07F2 5204              mov A,[X+4]
 07F4 08                push A
 07F5 5000              mov A,0
 07F7 08                push A
 07F8 5019              mov A,25
 07FA 08                push A
 07FB 5066              mov A,102
 07FD 08                push A
 07FE 500D              mov A,13
 0800 08                push A
 0801 7C0000            xcall __mul_32X32_32
 0804 38FC              add SP,-4
 0806 18                pop A
 0807 5300              mov [__r3],A
 0809 18                pop A
 080A 5300              mov [__r2],A
 080C 18                pop A
 080D 5300              mov [__r1],A
 080F 18                pop A
 0810 5300              mov [__r0],A
 0812 5100              mov A,[__r3]
 0814 015F              add A,95
 0816 5404              mov [X+4],A
 0818 5100              mov A,[__r2]
 081A 09F3              adc A,-13
 081C 5403              mov [X+3],A
 081E 5100              mov A,[__r1]
 0820 096E              adc A,110
 0822 5402              mov [X+2],A
 0824 5100              mov A,[__r0]
 0826 093C              adc A,60
 0828 5401              mov [X+1],A
 082A                   .dbline 606
 082A           ;         next_ch = ((id_tmp >> 8) % 0x49) + 3;       // Use least-significant byte and must be larger than 3
 082A 5201              mov A,[X+1]
 082C 5300              mov [__r0],A
 082E 5202              mov A,[X+2]
 0830 5300              mov [__r1],A
 0832 5203              mov A,[X+3]
 0834 5300              mov [__r2],A
 0836 5204              mov A,[X+4]
 0838 5300              mov [__r3],A
 083A 5008              mov A,8
 083C           X14:
 083C 70FB              and F,-5
 083E 6E00              rrc [__r0]
 0840 6E00              rrc [__r1]
 0842 6E00              rrc [__r2]
 0844 6E00              rrc [__r3]
 0846 78                dec A
 0847 BFF4              jnz X14
 0849 5000              mov A,0
 084B 08                push A
 084C 08                push A
 084D 08                push A
 084E 5049              mov A,73
 0850 08                push A
 0851 5100              mov A,[__r0]
 0853 08                push A
 0854 5100              mov A,[__r1]
 0856 08                push A
 0857 5100              mov A,[__r2]
 0859 08                push A
 085A 5100              mov A,[__r3]
 085C 08                push A
 085D 7C0000            xcall __divmodu_32X32_32
 0860 38FC              add SP,-4
 0862 18                pop A
 0863 5300              mov [__r3],A
 0865 18                pop A
 0866 18                pop A
 0867 18                pop A
 0868 060003            add [__r3],3
 086B 5100              mov A,[__r3]
 086D 540F              mov [X+15],A
 086F                   .dbline 607
 086F           ;         if (((next_ch ^ id) & 0x01 )== 0)
 086F 520F              mov A,[X+15]
 0871 5300              mov [__r3],A
 0873 550000            mov [__r2],0
 0876 550000            mov [__r1],0
 0879 550000            mov [__r0],0
 087C 5208              mov A,[X+8]
 087E 3400              xor [__r3],A
 0880 5207              mov A,[X+7]
 0882 3400              xor [__r2],A
 0884 5206              mov A,[X+6]
 0886 3400              xor [__r1],A
 0888 5205              mov A,[X+5]
 088A 3400              xor [__r0],A
 088C 260001            and [__r3],1
 088F 260000            and [__r2],0
 0892 260000            and [__r1],0
 0895 260000            and [__r0],0
 0898 B012              jnz L202
 089A 3C0000            cmp [__r1],0
 089D B00D              jnz L202
 089F 3C0000            cmp [__r2],0
 08A2 B008              jnz L202
 08A4 3C0000            cmp [__r3],0
 08A7 B003              jnz L202
 08A9           X15:
 08A9                   .dbline 608
 08A9           ;             continue;
 08A9 80C7              xjmp L200
 08AB           L202:
 08AB                   .dbline 609
 08AB           ;         for (i = 0; i < idx; i++) {
 08AB 560E00            mov [X+14],0
 08AE 560D00            mov [X+13],0
 08B1 8047              xjmp L207
 08B3           L204:
 08B3                   .dbline 609
 08B3                   .dbline 610
 08B3           ;             if(channels[i] == next_ch)
 08B3 520E              mov A,[X+14]
 08B5 010B              add A,<_channels
 08B7 5300              mov [__r1],A
 08B9 3E00              mvi A,[__r1]
 08BB 3B0F              cmp A,[X+15]
 08BD B003              jnz L208
 08BF                   .dbline 611
 08BF           ;                 break;
 08BF 804F              xjmp L206
 08C1           L208:
 08C1                   .dbline 612
 08C1           ;             if(channels[i] <= 27)
 08C1 520E              mov A,[X+14]
 08C3 010B              add A,<_channels
 08C5 5300              mov [__r1],A
 08C7 3E00              mvi A,[__r1]
 08C9 5300              mov [__r0],A
 08CB 501B              mov A,27
 08CD 3A00              cmp A,[__r0]
 08CF C008              jc L210
 08D1           X16:
 08D1                   .dbline 613
 08D1           ;                 count_3_27++;
 08D1 7711              inc [X+17]
 08D3 0F1000            adc [X+16],0
 08D6 801D              xjmp L211
 08D8           L210:
 08D8                   .dbline 614
 08D8           ;             else if (channels[i] <= 51)
 08D8 520E              mov A,[X+14]
 08DA 010B              add A,<_channels
 08DC 5300              mov [__r1],A
 08DE 3E00              mvi A,[__r1]
 08E0 5300              mov [__r0],A
 08E2 5033              mov A,51
 08E4 3A00              cmp A,[__r0]
 08E6 C008              jc L212
 08E8           X17:
 08E8                   .dbline 615
 08E8           ;                 count_28_51++;
 08E8 7713              inc [X+19]
 08EA 0F1200            adc [X+18],0
 08ED 8006              xjmp L213
 08EF           L212:
 08EF                   .dbline 617
 08EF           ;             else
 08EF           ;                 count_52_76++;
 08EF 7715              inc [X+21]
 08F1 0F1400            adc [X+20],0
 08F4           L213:
 08F4           L211:
 08F4                   .dbline 618
 08F4           ;         }
 08F4           L205:
 08F4                   .dbline 609
 08F4 770E              inc [X+14]
 08F6 0F0D00            adc [X+13],0
 08F9           L207:
 08F9                   .dbline 609
 08F9 5200              mov A,[X+0]
 08FB 5300              mov [__r1],A
 08FD 520E              mov A,[X+14]
 08FF 1200              sub A,[__r1]
 0901 5000              mov A,0
 0903 3180              xor A,-128
 0905 5300              mov [__rX],A
 0907 520D              mov A,[X+13]
 0909 3180              xor A,-128
 090B 1A00              sbb A,[__rX]
 090D CFA5              jc L204
 090F           X18:
 090F           L206:
 090F                   .dbline 619
 090F           ;         if (i != idx)
 090F 5200              mov A,[X+0]
 0911 5300              mov [__r1],A
 0913 550000            mov [__r0],0
 0916 520D              mov A,[X+13]
 0918 3A00              cmp A,[__r0]
 091A B007              jnz X19
 091C 520E              mov A,[X+14]
 091E 3A00              cmp A,[__r1]
 0920 A003              jz L214
 0922           X19:
 0922                   .dbline 620
 0922           ;             continue;
 0922 804E              xjmp L200
 0924           L214:
 0924                   .dbline 621
 0924           ;         if ((next_ch < 28 && count_3_27 < 8)
 0924 3D0F1C            cmp [X+15],28
 0927 D00D              jnc L219
 0929           X20:
 0929 5211              mov A,[X+17]
 092B 1108              sub A,8
 092D 5210              mov A,[X+16]
 092F 3180              xor A,-128
 0931 1980              sbb A,(0 ^ 0x80)
 0933 C028              jc L220
 0935           X21:
 0935           L219:
 0935 3D0F1C            cmp [X+15],28
 0938 C012              jc L222
 093A           X22:
 093A 3D0F34            cmp [X+15],52
 093D D00D              jnc L222
 093F           X23:
 093F 5213              mov A,[X+19]
 0941 1107              sub A,7
 0943 5212              mov A,[X+18]
 0945 3180              xor A,-128
 0947 1980              sbb A,(0 ^ 0x80)
 0949 C012              jc L220
 094B           X24:
 094B           L222:
 094B 3D0F34            cmp [X+15],52
 094E C022              jc L216
 0950           X25:
 0950 5215              mov A,[X+21]
 0952 1108              sub A,8
 0954 5214              mov A,[X+20]
 0956 3180              xor A,-128
 0958 1980              sbb A,(0 ^ 0x80)
 095A D016              jnc L216
 095C           X26:
 095C           L220:
 095C                   .dbline 625
 095C           ;           ||(next_ch >= 28 && next_ch < 52 && count_28_51 < 7)
 095C           ;           ||(next_ch >= 52 && count_52_76 < 8))
 095C           ;         {
 095C           ;             channels[idx++] = next_ch;
 095C                   .dbline 625
 095C 5200              mov A,[X+0]
 095E 5300              mov [__r1],A
 0960 550000            mov [__r0],0
 0963 0101              add A,1
 0965 5400              mov [X+0],A
 0967 06000B            add [__r1],<_channels
 096A 0E000B            adc [__r0],>_channels
 096D 520F              mov A,[X+15]
 096F 3F00              mvi [__r1],A
 0971                   .dbline 629
 0971           ; #ifdef DEBUG
 0971           ;               TX8SW_1_PutSHexByte(next_ch);   
 0971           ; #endif
 0971           ;         }
 0971           L216:
 0971                   .dbline 630
 0971           ;     }
 0971           L200:
 0971                   .dbline 601
 0971 3D0017            cmp [X+0],23
 0974 CE62              jc L199
 0976           X27:
 0976                   .dbline -2
 0976           L195:
 0976 38EA              add SP,-22
 0978 20                pop X
 0979                   .dbline 0 ; func end
 0979 7F                ret
 097A                   .dbsym l count_52_76 20 I
 097A                   .dbsym l count_28_51 18 I
 097A                   .dbsym l count_3_27 16 I
 097A                   .dbsym l next_ch 15 c
 097A                   .dbsym l i 13 I
 097A                   .dbsym l id 5 l
 097A                   .dbsym l id_tmp 1 l
 097A                   .dbsym l idx 0 c
 097A                   .dbend
 097A                   .dbfunc e src_cb _src_cb fV
 097A           _src_cb::
 097A                   .dbline -1
 097A                   .dbline 637
 097A           ; }
 097A           ; 
 097A           ; BOOL cb_tick;
 097A           ; //called form timer
 097A           ; //set flag that timer ticked
 097A           ; void src_cb(void)
 097A           ; {
 097A                   .dbline 638
 097A           ;       cb_tick=TRUE;
 097A 550001            mov [_cb_tick],1
 097D                   .dbline -2
 097D           L223:
 097D                   .dbline 0 ; func end
 097D 7F                ret
 097E                   .dbend
 097E                   .dbfunc e find_dsm2_channel _find_dsm2_channel fV
 097E           ;            val -> X+2
 097E           ;           rssi -> X+1
 097E           ;             ch -> X+0
 097E           _find_dsm2_channel::
 097E                   .dbline -1
 097E 10                push X
 097F 4F                mov X,SP
 0980 3803              add SP,3
 0982                   .dbline 647
 0982           ;       #ifdef DEBUG
 0982           ;       //TX8SW_1_CPutString("t");
 0982           ;       #endif
 0982           ; 
 0982           ; }
 0982           ; 
 0982           ; //find 2 channels with low noise
 0982           ; void find_dsm2_channel(void)
 0982           ; {
 0982                   .dbline 653
 0982           ; BYTE ch;
 0982           ; #ifdef DEBUG
 0982           ;       //TX8SW_1_CPutString("F");
 0982           ; #endif
 0982           ;       //set timing    
 0982           ;       Timer_SetCallback(src_cb);
 0982 5002              mov A,>PL_src_cb
 0984 08                push A
 0985 5002              mov A,<PL_src_cb
 0987 08                push A
 0988 7C0000            xcall _Timer_SetCallback
 098B 38FE              add SP,-2
 098D                   .dbline 654
 098D           ;       Timer_SetPeriod(DSM_SCAN_TIME);
 098D 10                push X
 098E 5755              mov X,85
 0990 50F0              mov A,-16
 0992 7C0000            xcall _Counter16_1_WritePeriod
 0995                   .dbline 655
 0995           ;       Timer_Start();
 0995 7C0000            xcall _Counter16_1_Start
 0998 20                pop X
 0999                   .dbline 656
 0999           ;       cb_tick=FALSE;
 0999 550000            mov [_cb_tick],0
 099C                   .dbline 658
 099C           ;       //loop thru both channels
 099C           ;       for(ch=0;ch<2;)
 099C 560000            mov [X+0],0
 099F 8092              xjmp L228
 09A1           L225:
 09A1                   .dbline 659
 09A1           ;       {
 09A1                   .dbline 660
 09A1           ;               BYTE rssi=0;
 09A1 560100            mov [X+1],0
 09A4                   .dbline 662
 09A4           ;               //take from spi capture of MLP4DSM
 09A4           ;               CYRF_WriteRegister(CYRF_DATA64_THOLD,0x3F);
 09A4 503F              mov A,63
 09A6 08                push A
 09A7 5012              mov A,18
 09A9 08                push A
 09AA 7C0000            xcall _CYRF_WriteRegister
 09AD 38FE              add SP,-2
 09AF                   .dbline 663
 09AF           ;               CYRF_WriteRegister(CYRF_FRAMING_CFG,0xFF);
 09AF 50FF              mov A,-1
 09B1 08                push A
 09B2 5010              mov A,16
 09B4 08                push A
 09B5 7C0000            xcall _CYRF_WriteRegister
 09B8                   .dbline 664
 09B8           ;               CYRF_SetSOPCode(pn_check);
 09B8 5008              mov A,8
 09BA 08                push A
 09BB 5008              mov A,>_pn_check
 09BD 08                push A
 09BE 5008              mov A,<_pn_check
 09C0 08                push A
 09C1 5022              mov A,34
 09C3 08                push A
 09C4 7C0000            xcall _CYRF_WriteRegisterMulti
 09C7 38FA              add SP,-6
 09C9                   .dbline 666
 09C9           ;               //loop thru avaliable channels
 09C9           ;               bind_channal+=5;
 09C9 060405            add [_bind_channal],5
 09CC                   .dbline 667
 09CC           ;               bind_channal%=0x4F;
 09CC 504F              mov A,79
 09CE 08                push A
 09CF 5104              mov A,[_bind_channal]
 09D1 08                push A
 09D2 7C0000            xcall __divmodu_8X8_8
 09D5 38FF              add SP,-1
 09D7 18                pop A
 09D8 5304              mov [_bind_channal],A
 09DA                   .dbline 668
 09DA           ;               bind_channal|=1;
 09DA 2E0401            or [_bind_channal],1
 09DD                   .dbline 669
 09DD           ;               CYRF_SetRFChannel(bind_channal);
 09DD 5104              mov A,[_bind_channal]
 09DF 08                push A
 09E0 5000              mov A,0
 09E2 08                push A
 09E3 7C0000            xcall _CYRF_WriteRegister
 09E6 38FE              add SP,-2
 09E8                   .dbline 671
 09E8           ;               //start reciving
 09E8           ;               DSM_StartReceive();
 09E8 9874              xcall _DSM_StartReceive
 09EA 8017              xjmp L230
 09EC           L229:
 09EC                   .dbline 674
 09EC           ;               //capture max of rssi
 09EC           ;               while(!cb_tick)
 09EC           ;               {
 09EC                   .dbline 675
 09EC           ;                       BYTE val=0x1F&CYRF_ReadRSSI();
 09EC 5013              mov A,19
 09EE 08                push A
 09EF 7C0000            xcall _CYRF_ReadRegister
 09F2 38FF              add SP,-1
 09F4 211F              and A,31
 09F6 5402              mov [X+2],A
 09F8                   .dbline 676
 09F8           ;                       if(val>rssi)
 09F8 5201              mov A,[X+1]
 09FA 3B02              cmp A,[X+2]
 09FC D005              jnc L232
 09FE           X28:
 09FE                   .dbline 677
 09FE           ;                               rssi=val;
 09FE 5202              mov A,[X+2]
 0A00 5401              mov [X+1],A
 0A02           L232:
 0A02                   .dbline 678
 0A02           ;               }
 0A02           L230:
 0A02                   .dbline 673
 0A02 3C0000            cmp [_cb_tick],0
 0A05 AFE6              jz L229
 0A07                   .dbline 683
 0A07           ; #ifdef DEBUG
 0A07           ;               //TX8SW_1_CPutString("T");
 0A07           ;               //TX8SW_1_PutSHexByte(bind_channal);
 0A07           ; #endif
 0A07           ;               cb_tick=FALSE;
 0A07 550000            mov [_cb_tick],0
 0A0A                   .dbline 685
 0A0A           ;               //low noise? use this one
 0A0A           ;               if(rssi<15)
 0A0A 3D010F            cmp [X+1],15
 0A0D D00D              jnc L234
 0A0F           X29:
 0A0F                   .dbline 687
 0A0F           ;                       {
 0A0F           ;                       channels[ch]=bind_channal;
 0A0F                   .dbline 687
 0A0F 5200              mov A,[X+0]
 0A11 010B              add A,<_channels
 0A13 5300              mov [__r1],A
 0A15 5104              mov A,[_bind_channal]
 0A17 3F00              mvi [__r1],A
 0A19                   .dbline 688
 0A19           ;                       ch++;
 0A19 7700              inc [X+0]
 0A1B                   .dbline 692
 0A1B           ; #ifdef DEBUG
 0A1B           ;                       //TX8SW_1_CPutString("P ");
 0A1B           ; #endif
 0A1B           ;                       }
 0A1B           L234:
 0A1B                   .dbline 694
 0A1B           ;       //read away any data we recived and clear any error
 0A1B           ;       CYRF_ReadRx_data(rx_buf,CYRF_Rx_cnt());
 0A1B 5009              mov A,9
 0A1D 08                push A
 0A1E 7C0000            xcall _CYRF_ReadRegister
 0A21 08                push A
 0A22 5010              mov A,>_mem+16
 0A24 08                push A
 0A25 5010              mov A,<_mem+16
 0A27 08                push A
 0A28 5021              mov A,33
 0A2A 08                push A
 0A2B 7C0000            xcall _CYRF_ReadRegisterMulti
 0A2E 38FB              add SP,-5
 0A30                   .dbline 695
 0A30           ;       DSM_ClearRxError();
 0A30 99DC              xcall _DSM_ClearRxError
 0A32                   .dbline 696
 0A32           ;       }
 0A32           L226:
 0A32                   .dbline 658
 0A32           L228:
 0A32                   .dbline 658
 0A32 3D0002            cmp [X+0],2
 0A35 CF6B              jc L225
 0A37           X30:
 0A37                   .dbline 698
 0A37           ;       //we are done stop timer
 0A37           ;       Timer_SetCallback(0);
 0A37 5000              mov A,>PL0
 0A39 08                push A
 0A3A 5000              mov A,<PL0
 0A3C 08                push A
 0A3D 7C0000            xcall _Timer_SetCallback
 0A40 38FE              add SP,-2
 0A42                   .dbline 699
 0A42           ;       Timer_Stop();
 0A42 10                push X
 0A43 7C0000            xcall _Counter16_1_Stop
 0A46 20                pop X
 0A47                   .dbline -2
 0A47           L224:
 0A47 38FD              add SP,-3
 0A49 20                pop X
 0A4A                   .dbline 0 ; func end
 0A4A 7F                ret
 0A4B                   .dbsym l val 2 c
 0A4B                   .dbsym l rssi 1 c
 0A4B                   .dbsym l ch 0 c
 0A4B                   .dbend
 0A4B                   .dbfunc e DSM_LoadTransmitMode _DSM_LoadTransmitMode fV
 0A4B           _DSM_LoadTransmitMode::
 0A4B                   .dbline -1
 0A4B 10                push X
 0A4C 4F                mov X,SP
 0A4D 3802              add SP,2
 0A4F                   .dbline 706
 0A4F           ; #ifdef DEBUG
 0A4F           ;               //TX8SW_1_CPutString("E");
 0A4F           ; #endif
 0A4F           ; }
 0A4F           ; //coad configuration for transmit mode
 0A4F           ; void DSM_LoadTransmitMode(void)
 0A4F           ; {
 0A4F                   .dbline 707
 0A4F           ;       CYRF_WriteRegister(CYRF_TX_CFG,tx_cfg); 
 0A4F 5103              mov A,[_tx_cfg]
 0A51 08                push A
 0A52 5003              mov A,3
 0A54 08                push A
 0A55 7C0000            xcall _CYRF_WriteRegister
 0A58                   .dbline 708
 0A58           ;       DSM_Load_Config(Transmit_vals,sizeof(Transmit_vals)/(sizeof(BYTE)*2));
 0A58 5003              mov A,3
 0A5A 08                push A
 0A5B 5098              mov A,>_Transmit_vals
 0A5D 08                push A
 0A5E 5098              mov A,<_Transmit_vals
 0A60 08                push A
 0A61 7C01B6            xcall _DSM_Load_Config
 0A64 38FB              add SP,-5
 0A66                   .dbline 709
 0A66           ;       if(DSM_Is_DSMX)
 0A66 3C2900            cmp [_DSM_Is_DSMX],0
 0A69 A005              jz L238
 0A6B                   .dbline 714
 0A6B           ;               {
 0A6B           ; #ifdef DEBUG
 0A6B           ;                       //TX8SW_1_CPutString("CH_");
 0A6B           ; #endif
 0A6B           ;               calc_dsmx_channel();
 0A6B                   .dbline 714
 0A6B 9C92              xcall _calc_dsmx_channel
 0A6D                   .dbline 715
 0A6D           ;               }
 0A6D 8003              xjmp L239
 0A6F           L238:
 0A6F                   .dbline 717
 0A6F           ;       else
 0A6F           ;               {
 0A6F                   .dbline 718
 0A6F           ;               find_dsm2_channel();
 0A6F 9F0D              xcall _find_dsm2_channel
 0A71                   .dbline 719
 0A71           ;               }       
 0A71           L239:
 0A71                   .dbline 721
 0A71           ;       //set periode to be 11ms or 22ms        
 0A71           ;       DSM_Perriode=DSM_Is_11ms?DSM_TIME11MS:DSM_TIME22MS;
 0A71 3C2800            cmp [_DSM_Is_11ms],0
 0A74 A009              jz L241
 0A76 560158            mov [X+1],88
 0A79 56001B            mov [X+0],27
 0A7C 8007              xjmp L242
 0A7E           L241:
 0A7E 560150            mov [X+1],80
 0A81 560046            mov [X+0],70
 0A84           L242:
 0A84 5201              mov A,[X+1]
 0A86 5324              mov [_DSM_Perriode+1],A
 0A88 5200              mov A,[X+0]
 0A8A 5323              mov [_DSM_Perriode],A
 0A8C                   .dbline 723
 0A8C           ;       //calculate channel CRC SOP and data code for first channel to transmitt
 0A8C           ;       SetCH_CRC_SOP_DATA();
 0A8C 7C003C            xcall _SetCH_CRC_SOP_DATA
 0A8F                   .dbline -2
 0A8F           L237:
 0A8F 38FE              add SP,-2
 0A91 20                pop X
 0A92                   .dbline 0 ; func end
 0A92 7F                ret
 0A93                   .dbend
 0A93                   .dbfunc e DSM_Init _DSM_Init fV
 0A93           ;              n -> X+0
 0A93           _DSM_Init::
 0A93                   .dbline -1
 0A93 10                push X
 0A94 4F                mov X,SP
 0A95 3801              add SP,1
 0A97                   .dbline 736
 0A97           ;       
 0A97           ; #ifdef DEBUG
 0A97           ;       if(DSM_Perriode==DSM_TIME11MS)
 0A97           ;               TX8SW_1_CPutString("T11");
 0A97           ;       if(DSM_Perriode==DSM_TIME22MS)
 0A97           ;               TX8SW_1_CPutString("T22");
 0A97           ; #endif
 0A97           ; }
 0A97           ; 
 0A97           ; 
 0A97           ; //initialise system
 0A97           ; void DSM_Init(void)
 0A97           ; {
 0A97                   .dbline 739
 0A97           ;       BYTE n;
 0A97           ;       //init CYRF6936
 0A97           ;       CYRF_Init();
 0A97 7C0000            xcall _CYRF_Init
 0A9A                   .dbline 741
 0A9A           ;       //set defalut values
 0A9A           ;       DSM_Is_DSMX=TRUE;
 0A9A 552901            mov [_DSM_Is_DSMX],1
 0A9D                   .dbline 742
 0A9D           ;       DSM_Is_11ms=TRUE;
 0A9D 552801            mov [_DSM_Is_11ms],1
 0AA0                   .dbline 743
 0AA0           ;       DSM_Is_11Bit=TRUE;
 0AA0 552701            mov [_DSM_Is_11Bit],1
 0AA3                   .dbline 744
 0AA3           ;       DSM_Is_Forced=FALSE;
 0AA3 552600            mov [_DSM_Is_Forced],0
 0AA6                   .dbline 745
 0AA6           ;       RX_Response=FALSE;
 0AA6 550900            mov [_RX_Response],0
 0AA9                   .dbline 746
 0AA9           ;       Ch_A=TRUE;
 0AA9 550801            mov [_Ch_A],1
 0AAC                   .dbline 747
 0AAC           ;       chidx=0;
 0AAC 550A00            mov [_chidx],0
 0AAF                   .dbline 748
 0AAF           ;       DSM_ready_for_Serial=FALSE;
 0AAF 552500            mov [_DSM_ready_for_Serial],0
 0AB2                   .dbline 749
 0AB2           ;       Bind_cnt=0;
 0AB2 552A00            mov [_Bind_cnt],0
 0AB5                   .dbline 750
 0AB5           ;       num_channels=6;
 0AB5 552B06            mov [_num_channels],6
 0AB8                   .dbline 752
 0AB8           ;       //set tx power to defalut
 0AB8           ;       tx_cfg=TX_CFG|DSM_TX_POWER;
 0AB8 55032F            mov [_tx_cfg],47
 0ABB                   .dbline 754
 0ABB           ;       
 0ABB           ;       CYRF_WritePreamble(preamble);
 0ABB 5003              mov A,3
 0ABD 08                push A
 0ABE 50A8              mov A,>_preamble
 0AC0 08                push A
 0AC1 50A8              mov A,<_preamble
 0AC3 08                push A
 0AC4 5024              mov A,36
 0AC6 08                push A
 0AC7 7C0000            xcall _CYRF_WriteRegisterMulti
 0ACA 38FC              add SP,-4
 0ACC                   .dbline 755
 0ACC           ;       CYRF_GetMfgData(cyrfmfg_id);
 0ACC 5000              mov A,>_cyrfmfg_id
 0ACE 08                push A
 0ACF 5000              mov A,<_cyrfmfg_id
 0AD1 08                push A
 0AD2 7C0000            xcall _CYRF_GetMfgData
 0AD5                   .dbline 770
 0AD5           ; #ifdef SHIFT_MFG_ID
 0AD5           ;       for (n=0;n<6;n++)
 0AD5           ;               {
 0AD5           ;               cyrfmfg_id[n]=cyrfmfg_id[(n+1)%6];
 0AD5           ;               }
 0AD5           ; #endif
 0AD5           ; #ifdef DEBUG
 0AD5           ;       TX8SW_1_CPutString("MfgId:");
 0AD5           ;       for (n=0;n<6;n++)
 0AD5           ;               {
 0AD5           ;               TX8SW_1_PutSHexByte(cyrfmfg_id[n]);     
 0AD5           ;               }
 0AD5           ; #endif
 0AD5           ;       //calculate sop and data column
 0AD5           ;       sop_col = (cyrfmfg_id[0] + cyrfmfg_id[1] + cyrfmfg_id[2] + 2) & 0x07;
 0AD5 5100              mov A,[_cyrfmfg_id]
 0AD7 0201              add A,[_cyrfmfg_id+1]
 0AD9 5300              mov [__r0],A
 0ADB 5102              mov A,[_cyrfmfg_id+2]
 0ADD 0400              add [__r0],A
 0ADF 060002            add [__r0],2
 0AE2 5100              mov A,[__r0]
 0AE4 2107              and A,7
 0AE6 5307              mov [_sop_col],A
 0AE8                   .dbline 771
 0AE8           ;     data_col = 7 - sop_col;
 0AE8 5007              mov A,7
 0AEA 1207              sub A,[_sop_col]
 0AEC 5306              mov [_data_col],A
 0AEE                   .dbline 772
 0AEE           ;       CYRF_SetRFChannel(0x61);
 0AEE 5061              mov A,97
 0AF0 08                push A
 0AF1 5000              mov A,0
 0AF3 08                push A
 0AF4 7C0000            xcall _CYRF_WriteRegister
 0AF7 38FC              add SP,-4
 0AF9                   .dbline 778
 0AF9           ;       //get some random
 0AF9           ;       //for choosing a random bind cannel we need some randomness.
 0AF9           ;       //but on a microcontroller this is hard to archive
 0AF9           ;       //so use some noise we capture on channel 0x61
 0AF9           ;       //if you look on the SPI trace from MLP4DSM spectrum seems to do something simmular
 0AF9           ;       DSM_StartReceive();
 0AF9 7C025E            xcall _DSM_StartReceive
 0AFC                   .dbline 779
 0AFC           ;       CYRF_WriteRegister(CYRF_DATA64_THOLD,0x3F);
 0AFC 503F              mov A,63
 0AFE 08                push A
 0AFF 5012              mov A,18
 0B01 08                push A
 0B02 7C0000            xcall _CYRF_WriteRegister
 0B05                   .dbline 780
 0B05           ;       CYRF_WriteRegister(CYRF_FRAMING_CFG,0x7F);
 0B05 507F              mov A,127
 0B07 08                push A
 0B08 5010              mov A,16
 0B0A 08                push A
 0B0B 7C0000            xcall _CYRF_WriteRegister
 0B0E 38FC              add SP,-4
 0B10                   .dbline 781
 0B10           ;       DSM_StartReceive();
 0B10 7C025E            xcall _DSM_StartReceive
 0B13                   .dbline 782
 0B13           ;       Timer_Wait_ms(10);
 0B13 500A              mov A,10
 0B15 08                push A
 0B16 7C0000            xcall _Timer_Wait_ms
 0B19                   .dbline 783
 0B19           ;       CYRF_ReadRx_data(rx_buf,CYRF_Rx_cnt());
 0B19 5009              mov A,9
 0B1B 08                push A
 0B1C 7C0000            xcall _CYRF_ReadRegister
 0B1F 38FE              add SP,-2
 0B21 08                push A
 0B22 5010              mov A,>_mem+16
 0B24 08                push A
 0B25 5010              mov A,<_mem+16
 0B27 08                push A
 0B28 5021              mov A,33
 0B2A 08                push A
 0B2B 7C0000            xcall _CYRF_ReadRegisterMulti
 0B2E                   .dbline 784
 0B2E           ;       DSM_ClearRxError();
 0B2E 98DE              xcall _DSM_ClearRxError
 0B30                   .dbline 785
 0B30           ;       DSM_Load_Config(init_vals,sizeof(init_vals)/(sizeof(BYTE)*2));
 0B30 5010              mov A,16
 0B32 08                push A
 0B33 5078              mov A,>_init_vals
 0B35 08                push A
 0B36 5078              mov A,<_init_vals
 0B38 08                push A
 0B39 7C01B6            xcall _DSM_Load_Config
 0B3C 38F9              add SP,-7
 0B3E                   .dbline 791
 0B3E           ; 
 0B3E           ; #ifdef DEBUG
 0B3E           ;       TX8SW_1_CPutString(" BindCH:");
 0B3E           ; #endif
 0B3E           ;       //simpel xor sum of what we got
 0B3E           ;       for(n=0;n<16;n++)
 0B3E 560000            mov [X+0],0
 0B41 8013              xjmp L250
 0B43           L247:
 0B43                   .dbline 792
 0B43           ;               bind_channal^=rx_buf[n];
 0B43 5200              mov A,[X+0]
 0B45 0110              add A,<_mem+16
 0B47 5300              mov [__r1],A
 0B49 3E00              mvi A,[__r1]
 0B4B 5300              mov [__r0],A
 0B4D 5104              mov A,[_bind_channal]
 0B4F 3200              xor A,[__r0]
 0B51 5304              mov [_bind_channal],A
 0B53           L248:
 0B53                   .dbline 791
 0B53 7700              inc [X+0]
 0B55           L250:
 0B55                   .dbline 791
 0B55 3D0010            cmp [X+0],16
 0B58 CFEA              jc L247
 0B5A           X31:
 0B5A                   .dbline 794
 0B5A           ;       //add systic
 0B5A           ;       bind_channal+=(systic&0xFF)^(systic>>8);
 0B5A 5F0000            mov [__r1],[_systic]
 0B5D 5101              mov A,[_systic+1]
 0B5F 3200              xor A,[__r1]
 0B61 5300              mov [__r1],A
 0B63 5104              mov A,[_bind_channal]
 0B65 0200              add A,[__r1]
 0B67 5304              mov [_bind_channal],A
 0B69                   .dbline 795
 0B69           ;       bind_channal&=0x3F;
 0B69 26043F            and [_bind_channal],63
 0B6C                   .dbline 796
 0B6C           ;       bind_channal|=1; //make shure channel is odd
 0B6C 2E0401            or [_bind_channal],1
 0B6F                   .dbline 800
 0B6F           ; #ifdef DEBUG
 0B6F           ;       TX8SW_1_PutSHexByte(bind_channal);
 0B6F           ; #endif
 0B6F           ;       CY_irq=FALSE;;
 0B6F 550000            mov [_CY_irq],0
 0B72                   .dbline 800
 0B72                   .dbline -2
 0B72           L243:
 0B72 38FF              add SP,-1
 0B74 20                pop X
 0B75                   .dbline 0 ; func end
 0B75 7F                ret
 0B76                   .dbsym l n 0 c
 0B76                   .dbend
                        .area bss(ram, con, rel)
 0000                   .dbfile C:\Users\Ralf\DOCUME~1\DSM_SA~1\DSM_SA~1\DSM_SA~1\dsm.c
 0000           _cb_tick::
 0000                   .blkb 1
 0001                   .dbsym e cb_tick _cb_tick c
 0001           _Last_Phase_error::
 0001                   .blkb 2
 0003                   .dbsym e Last_Phase_error _Last_Phase_error I
 0003           _tx_cfg::
 0003                   .blkb 1
 0004                   .dbsym e tx_cfg _tx_cfg c
 0004           _bind_channal::
 0004                   .blkb 1
 0005                   .dbsym e bind_channal _bind_channal c
 0005           _State::
 0005                   .blkb 1
 0006                   .dbsym e State _State c
 0006           _data_col::
 0006                   .blkb 1
 0007                   .dbsym e data_col _data_col c
 0007           _sop_col::
 0007                   .blkb 1
 0008                   .dbsym e sop_col _sop_col c
 0008           _Ch_A::
 0008                   .blkb 1
 0009                   .dbsym e Ch_A _Ch_A c
 0009           _RX_Response::
 0009                   .blkb 1
 000A                   .dbsym e RX_Response _RX_Response c
 000A           _chidx::
 000A                   .blkb 1
 000B                   .dbsym e chidx _chidx c
 000B           _channels::
 000B                   .blkb 23
 0022                   .dbsym e channels _channels A[23:23]c
 0022           _dsm_Max_pos::
 0022                   .blkb 1
 0023                   .dbsym e dsm_Max_pos _dsm_Max_pos c
 0023           _DSM_Perriode::
 0023                   .blkb 2
 0025                   .dbsym e DSM_Perriode _DSM_Perriode i
 0025           _DSM_ready_for_Serial::
 0025                   .blkb 1
 0026                   .dbsym e DSM_ready_for_Serial _DSM_ready_for_Serial c
 0026           _DSM_Is_Forced::
 0026                   .blkb 1
 0027                   .dbsym e DSM_Is_Forced _DSM_Is_Forced c
 0027           _DSM_Is_11Bit::
 0027                   .blkb 1
 0028                   .dbsym e DSM_Is_11Bit _DSM_Is_11Bit c
 0028           _DSM_Is_11ms::
 0028                   .blkb 1
 0029                   .dbsym e DSM_Is_11ms _DSM_Is_11ms c
 0029           _DSM_Is_DSMX::
 0029                   .blkb 1
 002A                   .dbsym e DSM_Is_DSMX _DSM_Is_DSMX c
 002A           _Bind_cnt::
 002A                   .blkb 1
 002B                   .dbsym e Bind_cnt _Bind_cnt c
 002B           _num_channels::
 002B                   .blkb 1
 002C                   .dbsym e num_channels _num_channels c
                        .area func_lit(rom, con, rel, proclab)
 0000 0000      PL0:    .word 0
 0002 097A      PL_src_cb:      .word _src_cb
 0004 021C      PL_Send_Xmit_cb:        .word _Send_Xmit_cb
 0006 0460      PL_Rcv_cb:      .word _Rcv_cb
 0008 01FB      PL_Bind_Xmit_cb:        .word _Bind_Xmit_cb
