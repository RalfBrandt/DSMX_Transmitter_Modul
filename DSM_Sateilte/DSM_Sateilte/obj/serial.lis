                        .module serial.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./serial.c
                        .area data(ram, con, rel)
 0000                   .dbfile ./serial.c
 0000           _ser_idx::
 0000                   .blkb 1
                        .area idata(rom,lit)
 0000 00                .byte 0
                        .area data(ram, con, rel)
 0001                   .dbfile ./serial.c
 0001                   .dbfile C:\Users\Ralf\DOCUME~1\DSM_SA~1\DSM_SA~1\DSM_SA~1\serial.c
 0001                   .dbsym e ser_idx _ser_idx c
 0001           _ser_status::
 0001                   .blkb 1
                        .area idata(rom,lit)
 0001 00                .byte 0
                        .area data(ram, con, rel)
 0002                   .dbfile C:\Users\Ralf\DOCUME~1\DSM_SA~1\DSM_SA~1\DSM_SA~1\serial.c
 0002                   .dbsym e ser_status _ser_status c
 0002           _ser_to::
 0002                   .blkb 1
                        .area idata(rom,lit)
 0002 00                .byte 0
                        .area data(ram, con, rel)
 0003                   .dbfile C:\Users\Ralf\DOCUME~1\DSM_SA~1\DSM_SA~1\DSM_SA~1\serial.c
 0003                   .dbsym e ser_to _ser_to c
                        .area text(rom, con, rel)
 0000                   .dbfile C:\Users\Ralf\DOCUME~1\DSM_SA~1\DSM_SA~1\DSM_SA~1\serial.c
 0000                   .dbfunc e SerialSetCallback _SerialSetCallback fV
 0000           ;             cb -> X-5
 0000           _SerialSetCallback::
 0000                   .dbline -1
 0000 10                push X
 0001 4F                mov X,SP
 0002                   .dbline 23
 0002           ; /*this module contains the code for serial reciving the data from the Transmitter
 0002           ; * a Buffer of 16 byte ist used to store recived data
 0002           ; * most work is doen within the interrupt sevice routine
 0002           ; *datarate is set in the chip design to 115200 by the devider for VC3
 0002           ; *the timer module will call the ser_Tic function once per ms
 0002           ; *if for 5ms no more chars are recived the index is reset to zerro
 0002           ; */
 0002           ; 
 0002           ; #include <m8c.h>        // part specific constants and macros
 0002           ; #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
 0002           ; #include "serial.h"
 0002           ; 
 0002           ; 
 0002           ; 
 0002           ; BYTE ser_databuf[SER_BUFFER_SIZE]; //the buffer to hold the recived data
 0002           ; BYTE ser_idx=0;                                               //index into buffer
 0002           ; BYTE ser_status=0;                                    //reciver status
 0002           ; BYTE ser_to=0;                                                //timeout variable to determin end of transmision
 0002           ; 
 0002           ; ser_callback_t serial_cb;
 0002           ; 
 0002           ; void SerialSetCallback(ser_callback_t cb)
 0002           ; {
 0002                   .dbline 24
 0002           ;       serial_cb=cb;
 0002 52FC              mov A,[X-4]
 0004 5302              mov [_serial_cb+1],A
 0006 52FB              mov A,[X-5]
 0008 5301              mov [_serial_cb],A
 000A                   .dbline -2
 000A           L1:
 000A 20                pop X
 000B                   .dbline 0 ; func end
 000B 7F                ret
 000C                   .dbsym l cb -5 pfV
 000C                   .dbend
 000C                   .dbfunc e SerialRX_Init _SerialRX_Init fV
 000C           ;              n -> X+0
 000C           _SerialRX_Init::
 000C                   .dbline -1
 000C 10                push X
 000D 4F                mov X,SP
 000E 3802              add SP,2
 0010                   .dbline 29
 0010           ; }
 0010           ; 
 0010           ; //initialize the RX8 module
 0010           ; void SerialRX_Init(void )
 0010           ; {
 0010                   .dbline 31
 0010           ;       int n;
 0010           ;       serial_cb=0;
 0010 550200            mov [_serial_cb+1],<PL0
 0013 550100            mov [_serial_cb],>PL0
 0016                   .dbline 32
 0016           ;       RX8_1_EnableInt(); //enable hardwar
 0016 10                push X
 0017 7C0000            xcall _RX8_1_EnableInt
 001A 20                pop X
 001B                   .dbline 34
 001B           ;       //clear buffer
 001B           ;       for (n=0;n<16;n++)
 001B 560100            mov [X+1],0
 001E 560000            mov [X+0],0
 0021           L3:
 0021                   .dbline 35
 0021           ;               ser_databuf[n]=0;
 0021 5201              mov A,[X+1]
 0023 0103              add A,<_ser_databuf
 0025 5300              mov [__r1],A
 0027 5000              mov A,0
 0029 3F00              mvi [__r1],A
 002B           L4:
 002B                   .dbline 34
 002B 7701              inc [X+1]
 002D 0F0000            adc [X+0],0
 0030                   .dbline 34
 0030 5201              mov A,[X+1]
 0032 1110              sub A,16
 0034 5200              mov A,[X+0]
 0036 3180              xor A,-128
 0038 1980              sbb A,(0 ^ 0x80)
 003A CFE6              jc L3
 003C           X0:
 003C                   .dbline 37
 003C           ;       //set index to 0
 003C           ;       ser_idx=0;
 003C 550000            mov [_ser_idx],0
 003F                   .dbline 39
 003F           ;       //enable interrupts
 003F           ;       M8C_EnableGInt;
 003F 7101                      or  F, 01h
 0041           
 0041                   .dbline 40
 0041           ;       RX8_1_EnableInt();
 0041 10                push X
 0042 7C0000            xcall _RX8_1_EnableInt
 0045                   .dbline 42
 0045           ;       //start reciving
 0045           ;       RX8_1_Start(RX8_PARITY_NONE);
 0045 5000              mov A,0
 0047 7C0000            xcall _RX8_1_Start
 004A 20                pop X
 004B                   .dbline -2
 004B           L2:
 004B 38FE              add SP,-2
 004D 20                pop X
 004E                   .dbline 0 ; func end
 004E 7F                ret
 004F                   .dbsym l n 0 I
 004F                   .dbend
 004F                   .dbfunc e SerialDataReady _SerialDataReady fc
 004F           _SerialDataReady::
 004F                   .dbline -1
 004F                   .dbline 47
 004F           ; }
 004F           ; 
 004F           ; //check if there is a complete package avaliable
 004F           ; BOOL SerialDataReady(void )
 004F           ; {
 004F                   .dbline 49
 004F           ;       //check if status contains anny error bits
 004F           ;       if (0xF0&SER_GET_STATUS())
 004F 4701F0            tst [_ser_status],-16
 0052 A00E              jz L8
 0054                   .dbline 51
 0054           ;       {       //reset in case of an error
 0054           ;               SER_CLEAR_ERROR();
 0054                   .dbline 51
 0054                   .dbline 51
 0054 2601F0            and [_ser_status],-16
 0057                   .dbline 51
 0057                   .dbline 51
 0057                   .dbline 52
 0057           ;               SER_RESET();
 0057                   .dbline 52
 0057                   .dbline 52
 0057 550100            mov [_ser_status],0
 005A                   .dbline 52
 005A                   .dbline 52
 005A                   .dbline 52
 005A                   .dbline 52
 005A 550000            mov [_ser_idx],0
 005D                   .dbline 52
 005D                   .dbline 52
 005D                   .dbline 52
 005D                   .dbline 52
 005D                   .dbline 53
 005D           ;               return 0;
 005D 5000              mov A,0
 005F 800C              xjmp L7
 0061           L8:
 0061                   .dbline 56
 0061           ;       }
 0061           ;       //ckeck if buffer is full
 0061           ;       if (SER_PEAK())
 0061 470101            tst [_ser_status],1
 0064 A005              jz L10
 0066                   .dbline 58
 0066           ;       {
 0066           ;               return 1;
 0066                   .dbline 58
 0066 5001              mov A,1
 0068 8003              xjmp L7
 006A           L10:
 006A                   .dbline 60
 006A           ;       }
 006A           ; return 0;
 006A 5000              mov A,0
 006C                   .dbline -2
 006C           L7:
 006C                   .dbline 0 ; func end
 006C 7F                ret
 006D                   .dbend
 006D                   .dbfunc e ser_Tic _ser_Tic fV
 006D           _ser_Tic::
 006D                   .dbline -1
 006D                   .dbline 68
 006D           ; }
 006D           ; 
 006D           ; 
 006D           ; //this is called from the system timer once per 1,953125 ms
 006D           ; //ser_to is reset to zerro each time a char is recived by the serial interupt service
 006D           ; //if there has not been anny char recived for 3 consecutive calls then reset the index
 006D           ; void ser_Tic(void )
 006D           ; {
 006D                   .dbline 69
 006D           ;       ser_to++; //increment timeout
 006D 7602              inc [_ser_to]
 006F                   .dbline 70
 006F           ;       if (ser_idx!=0 && ser_to > 3) //to we have a timeout (>6ms)
 006F 3C0000            cmp [_ser_idx],0
 0072 A00A              jz L13
 0074 5003              mov A,3
 0076 3A02              cmp A,[_ser_to]
 0078 D004              jnc L13
 007A           X1:
 007A                   .dbline 71
 007A           ;               ser_idx=0; //reset index
 007A 550000            mov [_ser_idx],0
 007D           L13:
 007D                   .dbline -2
 007D           L12:
 007D                   .dbline 0 ; func end
 007D 7F                ret
 007E                   .dbend
                        .area bss(ram, con, rel)
 0000                   .dbfile C:\Users\Ralf\DOCUME~1\DSM_SA~1\DSM_SA~1\DSM_SA~1\serial.c
 0000           L16:
 0000                   .blkb 1
                        .area text(rom, con, rel)
 007E                   .dbfile C:\Users\Ralf\DOCUME~1\DSM_SA~1\DSM_SA~1\DSM_SA~1\serial.c
 007E                   .dbfunc e RX8_1_Interrupt _RX8_1_Interrupt fV
 007E                   .dbsym s ser_c L16 c
 007E           _RX8_1_Interrupt::
 007E                   .dbline -1
 007E 08                push A
 007F 5100              mov A,[__r0]
 0081 08                push A
 0082 5100              mov A,[__r1]
 0084 08                push A
 0085 5100              mov A,[__r2]
 0087 08                push A
 0088 5100              mov A,[__r3]
 008A 08                push A
 008B 5100              mov A,[__r4]
 008D 08                push A
 008E 5100              mov A,[__r5]
 0090 08                push A
 0091 5100              mov A,[__r6]
 0093 08                push A
 0094 5100              mov A,[__r7]
 0096 08                push A
 0097 5100              mov A,[__r8]
 0099 08                push A
 009A 5100              mov A,[__r9]
 009C 08                push A
 009D 5100              mov A,[__r10]
 009F 08                push A
 00A0 5100              mov A,[__r11]
 00A2 08                push A
 00A3 5100              mov A,[__rX]
 00A5 08                push A
 00A6 5100              mov A,[__rY]
 00A8 08                push A
 00A9 5100              mov A,[__rZ]
 00AB 08                push A
 00AC                   .dbline 79
 00AC           ; }
 00AC           ; 
 00AC           ; #define RX8_1_RX_ENABLE 1
 00AC           ; #pragma interrupt_handler RX8_1_Interrupt
 00AC           ; 
 00AC           ; //interrupt handler called if a char is recived
 00AC           ; void RX8_1_Interrupt(void )
 00AC           ; {
 00AC                   .dbline 82
 00AC           ;       static BYTE ser_c; //the char buffer, defined as static to save stack space
 00AC           ;       
 00AC           ;       ser_to=0; //reset timeout
 00AC 550200            mov [_ser_to],0
 00AF 8083              xjmp L18
 00B1           L17:
 00B1                   .dbline 89
 00B1           ; 
 00B1           ; 
 00B1           ;       //if a char is recived 
 00B1           ;       //we use while instead of if because it can happen that another char is recived while we are here, 
 00B1           ;       //in that case no extra interrop for that one will occour
 00B1           ;       while (RX8_RX_COMPLETE & RX8_1_CONTROL_REG)
 00B1           ;       {       //get the char
 00B1                   .dbline 90
 00B1           ;               ser_c=RX8_1_RX_BUFFER_REG;
 00B1 5D2E              mov A,REG[0x2e]
 00B3 5300              mov [L16],A
 00B5                   .dbline 92
 00B5           ;               //if we have no error store the char
 00B5           ;               if (!(RX8_1_RX_ERROR & RX8_1_CONTROL_REG))
 00B5 5D2F              mov A,REG[0x2f]
 00B7 5300              mov [__r0],A
 00B9 4700E0            tst [__r0],-32
 00BC B055              jnz L20
 00BE                   .dbline 95
 00BE           ;               {
 00BE           ;                       //if there is still room in bufffer
 00BE           ;                       if (ser_idx<SER_BUFFER_SIZE)
 00BE                   .dbline 95
 00BE 3C000E            cmp [_ser_idx],14
 00C1 D04B              jnc L22
 00C3           X2:
 00C3                   .dbline 97
 00C3           ;                       {//store data
 00C3           ;                               ser_databuf[ser_idx++]=ser_c;
 00C3                   .dbline 97
 00C3 5F0000            mov [__r1],[_ser_idx]
 00C6 550000            mov [__r0],0
 00C9 5100              mov A,[__r1]
 00CB 0101              add A,1
 00CD 5300              mov [_ser_idx],A
 00CF 060003            add [__r1],<_ser_databuf
 00D2 0E0003            adc [__r0],>_ser_databuf
 00D5 5100              mov A,[L16]
 00D7 3F00              mvi [__r1],A
 00D9                   .dbline 99
 00D9           ;                               //check if buffer is full now
 00D9           ;                               if (ser_idx==SER_BUFFER_SIZE)
 00D9 3C000E            cmp [_ser_idx],14
 00DC B05F              jnz L15
 00DE                   .dbline 101
 00DE           ;                               {
 00DE           ;                                       ser_status|=SER_BUFFERFULL; //flag that we are done
 00DE                   .dbline 101
 00DE 2E0101            or [_ser_status],1
 00E1                   .dbline 102
 00E1           ;                                       if(serial_cb)
 00E1 5F0002            mov [__r1],[_serial_cb+1]
 00E4 5101              mov A,[_serial_cb]
 00E6 10                push X
 00E7 5800              mov X,[__r1]
 00E9 08                push A
 00EA 28                romx
 00EB 5300              mov [__r0],A
 00ED 18                pop A
 00EE 75                inc X
 00EF 0900              adc A,0
 00F1 28                romx
 00F2 20                pop X
 00F3 3C0000            cmp [__r0],0
 00F6 B005              jnz X3
 00F8 3900              cmp A,0
 00FA A041              jz L15
 00FC           X3:
 00FC                   .dbline 104
 00FC           ;                                       {
 00FC           ;                                               serial_cb();
 00FC                   .dbline 104
 00FC 5F0002            mov [__r1],[_serial_cb+1]
 00FF 5F0001            mov [__r0],[_serial_cb]
 0102 10                push X
 0103 5800              mov X,[__r1]
 0105 5100              mov A,[__r0]
 0107 7C0000            xcall __plcall
 010A 20                pop X
 010B                   .dbline 105
 010B           ;                                               return;
 010B 8030              xjmp L15
 010D           L22:
 010D                   .dbline 110
 010D           ;                                       }
 010D           ;                               }
 010D           ;                       }
 010D           ;                       else 
 010D           ;                               ser_status|=SER_BUFOVERRUN_ERROR; //flag a buffer overrun
 010D 2E0110            or [_ser_status],16
 0110                   .dbline 111
 0110           ;                       return ;
 0110 802B              xjmp L15
 0112           L20:
 0112                   .dbline 114
 0112           ;               }
 0112           ;               //if we got anny error
 0112           ;               if(RX8_1_RX_ERROR & RX8_1_CONTROL_REG)
 0112 5D2F              mov A,REG[0x2f]
 0114 5300              mov [__r0],A
 0116 4700E0            tst [__r0],-32
 0119 A019              jz L28
 011B                   .dbline 116
 011B           ;               {
 011B           ;                       ser_idx=0; //reset index , trash all we have so far
 011B                   .dbline 116
 011B 550000            mov [_ser_idx],0
 011E                   .dbline 117
 011E           ;                       ser_status|=RX8_1_CONTROL_REG & RX8_1_RX_ERROR; //update status
 011E 5D2F              mov A,REG[0x2f]
 0120 21E0              and A,-32
 0122 2C01              or [_ser_status],A
 0124                   .dbline 119
 0124           ;                       //special case framing error
 0124           ;                       if (RX8_1_RX_FRAMING_ERROR & RX8_1_CONTROL_REG)
 0124 5D2F              mov A,REG[0x2f]
 0126 5300              mov [__r0],A
 0128 470020            tst [__r0],32
 012B A007              jz L30
 012D                   .dbline 121
 012D           ;                       {
 012D           ;                               RX8_1_CONTROL_REG&=~RX8_1_RX_ENABLE; //disable RX
 012D                   .dbline 121
 012D 412FFE            and REG[0x2f],-2
 0130                   .dbline 122
 0130           ;                               RX8_1_CONTROL_REG|=RX8_1_RX_ENABLE; //enable RX
 0130 432F01            or REG[0x2f],1
 0133                   .dbline 123
 0133           ;                       }
 0133           L30:
 0133                   .dbline 124
 0133           ;               }
 0133           L28:
 0133                   .dbline 125
 0133           ;       }
 0133           L18:
 0133                   .dbline 88
 0133 5D2F              mov A,REG[0x2f]
 0135 5300              mov [__r0],A
 0137 470008            tst [__r0],8
 013A BF76              jnz L17
 013C                   .dbline -2
 013C           L15:
 013C 18                pop A
 013D 5300              mov [__rZ],A
 013F 18                pop A
 0140 5300              mov [__rY],A
 0142 18                pop A
 0143 5300              mov [__rX],A
 0145 18                pop A
 0146 5300              mov [__r11],A
 0148 18                pop A
 0149 5300              mov [__r10],A
 014B 18                pop A
 014C 5300              mov [__r9],A
 014E 18                pop A
 014F 5300              mov [__r8],A
 0151 18                pop A
 0152 5300              mov [__r7],A
 0154 18                pop A
 0155 5300              mov [__r6],A
 0157 18                pop A
 0158 5300              mov [__r5],A
 015A 18                pop A
 015B 5300              mov [__r4],A
 015D 18                pop A
 015E 5300              mov [__r3],A
 0160 18                pop A
 0161 5300              mov [__r2],A
 0163 18                pop A
 0164 5300              mov [__r1],A
 0166 18                pop A
 0167 5300              mov [__r0],A
 0169 18                pop A
 016A                   .dbline 0 ; func end
 016A 7E                reti
 016B                   .dbend
                        .area bss(ram, con, rel)
 0001                   .dbfile C:\Users\Ralf\DOCUME~1\DSM_SA~1\DSM_SA~1\DSM_SA~1\serial.c
 0001           _serial_cb::
 0001                   .blkb 2
 0003                   .dbsym e serial_cb _serial_cb pfV
 0003           _ser_databuf::
 0003                   .blkb 14
 0011                   .dbsym e ser_databuf _ser_databuf A[14:14]c
                        .area func_lit(rom, con, rel, proclab)
 0000 0000      PL0:    .word 0
