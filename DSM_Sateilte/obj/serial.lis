 0000                   cpu LMM
                        .module serial.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./serial.c
                        .area data(ram, con, rel)
 0000                   .dbfile ./serial.c
 0000           _ser_idx::
 0000 00                .byte 0
 0001                   .dbfile C:\Users\Ralf\DOCUME~1\DSM_SA~1\DSM_SA~1\DSM_SA~1\serial.c
 0001                   .dbsym e ser_idx _ser_idx c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ralf\DOCUME~1\DSM_SA~1\DSM_SA~1\DSM_SA~1\serial.c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ralf\DOCUME~1\DSM_SA~1\DSM_SA~1\DSM_SA~1\serial.c
 0000           _ser_status::
 0000 00                .byte 0
 0001                   .dbsym e ser_status _ser_status c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ralf\DOCUME~1\DSM_SA~1\DSM_SA~1\DSM_SA~1\serial.c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ralf\DOCUME~1\DSM_SA~1\DSM_SA~1\DSM_SA~1\serial.c
 0000           _ser_to::
 0000 00                .byte 0
 0001                   .dbsym e ser_to _ser_to c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ralf\DOCUME~1\DSM_SA~1\DSM_SA~1\DSM_SA~1\serial.c
                        .area text(rom, con, rel)
 0000                   .dbfile C:\Users\Ralf\DOCUME~1\DSM_SA~1\DSM_SA~1\DSM_SA~1\serial.c
 0000                   .dbfunc e SerialSetCallback _SerialSetCallback fV
 0000           ;             cb -> X-5
 0000           _SerialSetCallback::
 0000                   .dbline -1
 0000 10                push X
 0001 4F                mov X,SP
 0002                   .dbline 22
 0002           ; /*this module contains the code for serial reciving the data from the Transmitter
 0002           ; * a Buffer of 16 byte ist used to store recived data
 0002           ; * most work is doen within the interrupt sevice routine
 0002           ; *datarate is set in the chip design to 115200 by the devider for VC3
 0002           ; *the timer module will call the ser_Tic function once per ms
 0002           ; *if for 5ms no more chars are recived the index is reset to zerro
 0002           ; */
 0002           ; 
 0002           ; #include <m8c.h>        // part specific constants and macros
 0002           ; #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
 0002           ; #include "serial.h"
 0002           ; 
 0002           ; 
 0002           ; BYTE ser_databuf[SER_BUFFER_SIZE]; //the buffer to hold the recived data
 0002           ; BYTE ser_idx=0;                                               //index into buffer
 0002           ; BYTE ser_status=0;                                    //reciver status
 0002           ; BYTE ser_to=0;                                                //timeout variable to determin end of transmision
 0002           ; 
 0002           ; ser_callback_t serial_cb;
 0002           ; 
 0002           ; void SerialSetCallback(ser_callback_t cb)
 0002           ; {
 0002                   .dbline 23
 0002           ;       serial_cb=cb;
 0002 62D000            mov REG[0xd0],>_serial_cb
 0005 52FC              mov A,[X-4]
 0007 5301              mov [_serial_cb+1],A
 0009 52FB              mov A,[X-5]
 000B 5300              mov [_serial_cb],A
 000D                   .dbline -2
 000D           L1:
 000D 20                pop X
 000E                   .dbline 0 ; func end
 000E 7F                ret
 000F                   .dbsym l cb -5 pfV
 000F                   .dbend
 000F                   .dbfunc e SerialRX_Init _SerialRX_Init fV
 000F           ;              n -> X+0
 000F           _SerialRX_Init::
 000F                   .dbline -1
 000F 10                push X
 0010 4F                mov X,SP
 0011 3802              add SP,2
 0013                   .dbline 28
 0013           ; }
 0013           ; 
 0013           ; //initialize the RX8 module
 0013           ; void SerialRX_Init(void )
 0013           ; {
 0013                   .dbline 30
 0013           ;       int n;
 0013           ;       serial_cb=0;
 0013 62D000            mov REG[0xd0],>_serial_cb
 0016 550100            mov [_serial_cb+1],<PL0
 0019 550000            mov [_serial_cb],>PL0
 001C                   .dbline 31
 001C           ;       RX8_1_EnableInt(); //enable hardwar
 001C 10                push X
 001D 7C0000            xcall _RX8_1_EnableInt
 0020 20                pop X
 0021                   .dbline 33
 0021           ;       //clear buffer
 0021           ;       for (n=0;n<16;n++)
 0021 560100            mov [X+1],0
 0024 560000            mov [X+0],0
 0027           L3:
 0027                   .dbline 34
 0027           ;               ser_databuf[n]=0;
 0027 62D000            mov REG[0xd0],>__r0
 002A 5201              mov A,[X+1]
 002C 0100              add A,<_ser_databuf
 002E 5300              mov [__r1],A
 0030 5200              mov A,[X+0]
 0032 0900              adc A,>_ser_databuf
 0034 60D5              mov REG[0xd5],A
 0036 5000              mov A,0
 0038 3F00              mvi [__r1],A
 003A           L4:
 003A                   .dbline 33
 003A 7701              inc [X+1]
 003C 0F0000            adc [X+0],0
 003F                   .dbline 33
 003F 5201              mov A,[X+1]
 0041 1110              sub A,16
 0043 5200              mov A,[X+0]
 0045 3180              xor A,-128
 0047 1980              sbb A,(0 ^ 0x80)
 0049 CFDD              jc L3
 004B           X0:
 004B                   .dbline 36
 004B           ;       //set index to 0
 004B           ;       ser_idx=0;
 004B 62D000            mov REG[0xd0],>_ser_idx
 004E 550000            mov [_ser_idx],0
 0051                   .dbline 38
 0051           ;       //enable interrupts
 0051           ;       M8C_EnableGInt;
 0051 7101                      or  F, 01h
 0053           
 0053                   .dbline 39
 0053           ;       RX8_1_EnableInt();
 0053 10                push X
 0054 7C0000            xcall _RX8_1_EnableInt
 0057                   .dbline 41
 0057           ;       //start reciving
 0057           ;       RX8_1_Start(RX8_PARITY_NONE);
 0057 5000              mov A,0
 0059 7C0000            xcall _RX8_1_Start
 005C 20                pop X
 005D                   .dbline -2
 005D           L2:
 005D 38FE              add SP,-2
 005F 20                pop X
 0060                   .dbline 0 ; func end
 0060 7F                ret
 0061                   .dbsym l n 0 I
 0061                   .dbend
 0061                   .dbfunc e SerialReadData _SerialReadData fc
 0061           _SerialReadData::
 0061                   .dbline -1
 0061                   .dbline 46
 0061           ; }
 0061           ; 
 0061           ; //check if there is a compleet package avaliable
 0061           ; BOOL SerialReadData(void )
 0061           ; {
 0061                   .dbline 48
 0061           ;       //check if status contains anny error bits
 0061           ;       if (0xF0&SER_GET_STATUS())
 0061 62D000            mov REG[0xd0],>_ser_status
 0064 4700F0            tst [_ser_status],-16
 0067 A014              jz L8
 0069                   .dbline 50
 0069           ;       {       //reset in case of an error
 0069           ;               SER_CLEAR_ERROR();
 0069                   .dbline 50
 0069                   .dbline 50
 0069 2600F0            and [_ser_status],-16
 006C                   .dbline 50
 006C                   .dbline 50
 006C                   .dbline 51
 006C           ;               SER_RESET();
 006C                   .dbline 51
 006C                   .dbline 51
 006C 550000            mov [_ser_status],0
 006F                   .dbline 51
 006F                   .dbline 51
 006F                   .dbline 51
 006F                   .dbline 51
 006F 62D000            mov REG[0xd0],>_ser_idx
 0072 550000            mov [_ser_idx],0
 0075                   .dbline 51
 0075                   .dbline 51
 0075                   .dbline 51
 0075                   .dbline 51
 0075                   .dbline 52
 0075           ;               return 0;
 0075 62D000            mov REG[0xd0],>__r0
 0078 5000              mov A,0
 007A 8015              xjmp L7
 007C           L8:
 007C                   .dbline 55
 007C           ;       }
 007C           ;       //ckeck if buffer is full
 007C           ;       if (SER_PEAK())
 007C 62D000            mov REG[0xd0],>_ser_status
 007F 470001            tst [_ser_status],1
 0082 A008              jz L10
 0084                   .dbline 57
 0084           ;       {
 0084           ;               return 1;
 0084                   .dbline 57
 0084 62D000            mov REG[0xd0],>__r0
 0087 5001              mov A,1
 0089 8006              xjmp L7
 008B           L10:
 008B                   .dbline 59
 008B           ;       }
 008B           ; return 0;
 008B 62D000            mov REG[0xd0],>__r0
 008E 5000              mov A,0
 0090                   .dbline -2
 0090           L7:
 0090                   .dbline 0 ; func end
 0090 7F                ret
 0091                   .dbend
 0091                   .dbfunc e ser_Tic _ser_Tic fV
 0091           _ser_Tic::
 0091                   .dbline -1
 0091                   .dbline 67
 0091           ; }
 0091           ; 
 0091           ; 
 0091           ; //this is called from the system timer once per 1,953125 ms
 0091           ; //ser_to is reset to zerro each time a char is recived by the serial interupt service
 0091           ; //if there has not been anny char recived for 3 consecutive calls then reset the index
 0091           ; void ser_Tic(void )
 0091           ; {
 0091                   .dbline 68
 0091           ;       ser_to++; //increment timeout
 0091 62D000            mov REG[0xd0],>_ser_to
 0094 7600              inc [_ser_to]
 0096                   .dbline 69
 0096           ;       if (ser_idx!=0 && ser_to > 3) //to we have a timeout (>6ms)
 0096 62D000            mov REG[0xd0],>_ser_idx
 0099 3C0000            cmp [_ser_idx],0
 009C A010              jz L13
 009E 62D000            mov REG[0xd0],>_ser_to
 00A1 5003              mov A,3
 00A3 3A00              cmp A,[_ser_to]
 00A5 D007              jnc L13
 00A7           X1:
 00A7                   .dbline 70
 00A7           ;               ser_idx=0; //reset index
 00A7 62D000            mov REG[0xd0],>_ser_idx
 00AA 550000            mov [_ser_idx],0
 00AD           L13:
 00AD                   .dbline -2
 00AD           L12:
 00AD                   .dbline 0 ; func end
 00AD 7F                ret
 00AE                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ralf\DOCUME~1\DSM_SA~1\DSM_SA~1\DSM_SA~1\serial.c
 0000           L16:
 0000 00                .byte 0
                        .area text(rom, con, rel)
 00AE                   .dbfile C:\Users\Ralf\DOCUME~1\DSM_SA~1\DSM_SA~1\DSM_SA~1\serial.c
 00AE                   .dbfunc e RX8_1_Interrupt _RX8_1_Interrupt fV
 00AE                   .dbsym s ser_c L16 c
 00AE           _RX8_1_Interrupt::
 00AE                   .dbline -1
 00AE 71C0              or F,-64
 00B0 08                push A
 00B1 5DD0              mov A,REG[0xd0]
 00B3 08                push A
 00B4 5DD3              mov A,REG[0xd3]
 00B6 08                push A
 00B7 5DD4              mov A,REG[0xd4]
 00B9 08                push A
 00BA 5DD5              mov A,REG[0xd5]
 00BC 08                push A
 00BD 62D000            mov REG[0xd0],>__r0
 00C0 5100              mov A,[__r0]
 00C2 08                push A
 00C3 5100              mov A,[__r1]
 00C5 08                push A
 00C6 5100              mov A,[__r2]
 00C8 08                push A
 00C9 5100              mov A,[__r3]
 00CB 08                push A
 00CC 5100              mov A,[__r4]
 00CE 08                push A
 00CF 5100              mov A,[__r5]
 00D1 08                push A
 00D2 5100              mov A,[__r6]
 00D4 08                push A
 00D5 5100              mov A,[__r7]
 00D7 08                push A
 00D8 5100              mov A,[__r8]
 00DA 08                push A
 00DB 5100              mov A,[__r9]
 00DD 08                push A
 00DE 5100              mov A,[__r10]
 00E0 08                push A
 00E1 5100              mov A,[__r11]
 00E3 08                push A
 00E4 5100              mov A,[__rX]
 00E6 08                push A
 00E7 5100              mov A,[__rY]
 00E9 08                push A
 00EA 5100              mov A,[__rZ]
 00EC 08                push A
 00ED                   .dbline 78
 00ED           ; }
 00ED           ; 
 00ED           ; #define RX8_1_RX_ENABLE 1
 00ED           ; #pragma interrupt_handler RX8_1_Interrupt
 00ED           ; 
 00ED           ; //interrupt handler called if a char is recived
 00ED           ; void RX8_1_Interrupt(void )
 00ED           ; {
 00ED                   .dbline 81
 00ED           ;       static BYTE ser_c; //the char buffer, defined as static to save stack space
 00ED           ;       
 00ED           ;       ser_to=0; //reset timeout
 00ED 62D000            mov REG[0xd0],>_ser_to
 00F0 550000            mov [_ser_to],0
 00F3 80D2              xjmp L18
 00F5           L17:
 00F5                   .dbline 88
 00F5           ; 
 00F5           ; 
 00F5           ;       //if a char is recived 
 00F5           ;       //we use while instead of if because it can happen that another char is recived while we are here, 
 00F5           ;       //in that case no extra interrop for that one will occour
 00F5           ;       while (RX8_RX_COMPLETE & RX8_1_CONTROL_REG)
 00F5           ;       {       //get the char
 00F5                   .dbline 89
 00F5           ;               ser_c=RX8_1_RX_BUFFER_REG;
 00F5 5D2E              mov A,REG[0x2e]
 00F7 62D000            mov REG[0xd0],>L16
 00FA 5300              mov [L16],A
 00FC                   .dbline 91
 00FC           ;               //if we have no error store the char
 00FC           ;               if (!(RX8_1_RX_ERROR & RX8_1_CONTROL_REG))
 00FC 5D2F              mov A,REG[0x2f]
 00FE 62D000            mov REG[0xd0],>__r0
 0101 5300              mov [__r0],A
 0103 4700E0            tst [__r0],-32
 0106 B08A              jnz L20
 0108                   .dbline 94
 0108           ;               {
 0108           ;                       //if there is still room in bufffer
 0108           ;                       if (ser_idx<SER_BUFFER_SIZE)
 0108                   .dbline 94
 0108 62D000            mov REG[0xd0],>_ser_idx
 010B 3C000E            cmp [_ser_idx],14
 010E D07A              jnc L22
 0110           X2:
 0110                   .dbline 96
 0110           ;                       {//store data
 0110           ;                               ser_databuf[ser_idx++]=ser_c;
 0110                   .dbline 96
 0110 62D000            mov REG[0xd0],>_ser_idx
 0113 5100              mov A,[_ser_idx]
 0115 62D000            mov REG[0xd0],>__r0
 0118 5300              mov [__r1],A
 011A 550000            mov [__r0],0
 011D 0101              add A,1
 011F 62D000            mov REG[0xd0],>_ser_idx
 0122 5300              mov [_ser_idx],A
 0124 62D000            mov REG[0xd0],>__r0
 0127 060000            add [__r1],<_ser_databuf
 012A 0E0000            adc [__r0],>_ser_databuf
 012D 5100              mov A,[__r0]
 012F 60D5              mov REG[0xd5],A
 0131 62D000            mov REG[0xd0],>L16
 0134 5100              mov A,[L16]
 0136 62D000            mov REG[0xd0],>__r0
 0139 3F00              mvi [__r1],A
 013B                   .dbline 98
 013B           ;                               //check if buffer is full now
 013B           ;                               if (ser_idx==SER_BUFFER_SIZE)
 013B 62D000            mov REG[0xd0],>_ser_idx
 013E 3C000E            cmp [_ser_idx],14
 0141 B090              jnz L15
 0143                   .dbline 100
 0143           ;                               {
 0143           ;                                       ser_status|=SER_BUFFERFULL; //flag that we are done
 0143                   .dbline 100
 0143 62D000            mov REG[0xd0],>_ser_status
 0146 2E0001            or [_ser_status],1
 0149                   .dbline 101
 0149           ;                                       if(serial_cb)
 0149 62D000            mov REG[0xd0],>_serial_cb
 014C 5101              mov A,[_serial_cb+1]
 014E 08                push A
 014F 5100              mov A,[_serial_cb]
 0151 62D000            mov REG[0xd0],>__r0
 0154 5300              mov [__r0],A
 0156 18                pop A
 0157 5300              mov [__r1],A
 0159 5100              mov A,[__r0]
 015B 10                push X
 015C 5800              mov X,[__r1]
 015E 08                push A
 015F 28                romx
 0160 5300              mov [__r0],A
 0162 18                pop A
 0163 75                inc X
 0164 0900              adc A,0
 0166 28                romx
 0167 20                pop X
 0168 3C0000            cmp [__r0],0
 016B B005              jnz X3
 016D 3900              cmp A,0
 016F A062              jz L15
 0171           X3:
 0171                   .dbline 102
 0171           ;                                               serial_cb();
 0171 62D000            mov REG[0xd0],>_serial_cb
 0174 5101              mov A,[_serial_cb+1]
 0176 08                push A
 0177 5100              mov A,[_serial_cb]
 0179 62D000            mov REG[0xd0],>__r0
 017C 5300              mov [__r0],A
 017E 18                pop A
 017F 10                push X
 0180 5C                mov X,A
 0181 5100              mov A,[__r0]
 0183 7C0000            xcall __plcall
 0186 20                pop X
 0187                   .dbline 103
 0187           ;                               }
 0187                   .dbline 104
 0187           ;                       }
 0187 804A              xjmp L15
 0189           L22:
 0189                   .dbline 106
 0189           ;                       else 
 0189           ;                               ser_status|=SER_BUFOVERRUN_ERROR; //flag a buffer overrun
 0189 62D000            mov REG[0xd0],>_ser_status
 018C 2E0010            or [_ser_status],16
 018F                   .dbline 107
 018F           ;                       return ;
 018F 8042              xjmp L15
 0191           L20:
 0191                   .dbline 110
 0191           ;               }
 0191           ;               //if we got anny error
 0191           ;               if(RX8_1_RX_ERROR & RX8_1_CONTROL_REG)
 0191 5D2F              mov A,REG[0x2f]
 0193 62D000            mov REG[0xd0],>__r0
 0196 5300              mov [__r0],A
 0198 4700E0            tst [__r0],-32
 019B A02A              jz L28
 019D                   .dbline 112
 019D           ;               {
 019D           ;                       ser_idx=0; //reset index , trash all we have so far
 019D                   .dbline 112
 019D 62D000            mov REG[0xd0],>_ser_idx
 01A0 550000            mov [_ser_idx],0
 01A3                   .dbline 113
 01A3           ;                       ser_status|=RX8_1_CONTROL_REG & RX8_1_RX_ERROR; //update status
 01A3 5D2F              mov A,REG[0x2f]
 01A5 62D000            mov REG[0xd0],>__r0
 01A8 5300              mov [__r0],A
 01AA 2600E0            and [__r0],-32
 01AD 5100              mov A,[__r0]
 01AF 62D000            mov REG[0xd0],>_ser_status
 01B2 2C00              or [_ser_status],A
 01B4                   .dbline 115
 01B4           ;                       //special case framing error
 01B4           ;                       if (RX8_1_RX_FRAMING_ERROR & RX8_1_CONTROL_REG)
 01B4 5D2F              mov A,REG[0x2f]
 01B6 62D000            mov REG[0xd0],>__r0
 01B9 5300              mov [__r0],A
 01BB 470020            tst [__r0],32
 01BE A007              jz L30
 01C0                   .dbline 117
 01C0           ;                       {
 01C0           ;                               RX8_1_CONTROL_REG&=~RX8_1_RX_ENABLE; //disable RX
 01C0                   .dbline 117
 01C0 412FFE            and REG[0x2f],-2
 01C3                   .dbline 118
 01C3           ;                               RX8_1_CONTROL_REG|=RX8_1_RX_ENABLE; //enable RX
 01C3 432F01            or REG[0x2f],1
 01C6                   .dbline 119
 01C6           ;                       }
 01C6           L30:
 01C6                   .dbline 120
 01C6           ;               }
 01C6           L28:
 01C6                   .dbline 121
 01C6           ;       }
 01C6           L18:
 01C6                   .dbline 87
 01C6 5D2F              mov A,REG[0x2f]
 01C8 62D000            mov REG[0xd0],>__r0
 01CB 5300              mov [__r0],A
 01CD 470008            tst [__r0],8
 01D0 BF24              jnz L17
 01D2                   .dbline -2
 01D2           L15:
 01D2 62D000            mov REG[0xD0],>__r0
 01D5 18                pop A
 01D6 5300              mov [__rZ],A
 01D8 18                pop A
 01D9 5300              mov [__rY],A
 01DB 18                pop A
 01DC 5300              mov [__rX],A
 01DE 18                pop A
 01DF 5300              mov [__r11],A
 01E1 18                pop A
 01E2 5300              mov [__r10],A
 01E4 18                pop A
 01E5 5300              mov [__r9],A
 01E7 18                pop A
 01E8 5300              mov [__r8],A
 01EA 18                pop A
 01EB 5300              mov [__r7],A
 01ED 18                pop A
 01EE 5300              mov [__r6],A
 01F0 18                pop A
 01F1 5300              mov [__r5],A
 01F3 18                pop A
 01F4 5300              mov [__r4],A
 01F6 18                pop A
 01F7 5300              mov [__r3],A
 01F9 18                pop A
 01FA 5300              mov [__r2],A
 01FC 18                pop A
 01FD 5300              mov [__r1],A
 01FF 18                pop A
 0200 5300              mov [__r0],A
 0202 18                pop A
 0203 60D5              mov REG[213],A
 0205 18                pop A
 0206 60D4              mov REG[212],A
 0208 18                pop A
 0209 60D3              mov REG[211],A
 020B 18                pop A
 020C 60D0              mov REG[208],A
 020E 18                pop A
 020F                   .dbline 0 ; func end
 020F 7E                reti
 0210                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ralf\DOCUME~1\DSM_SA~1\DSM_SA~1\DSM_SA~1\serial.c
 0000           _serial_cb::
 0000 0000              .byte 0,0
 0002                   .dbsym e serial_cb _serial_cb pfV
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ralf\DOCUME~1\DSM_SA~1\DSM_SA~1\DSM_SA~1\serial.c
 0000           _ser_databuf::
 0000 00000000000000000000      .word 0,0,0,0,0
 000A 00000000          .byte 0,0,0,0
 000E                   .dbsym e ser_databuf _ser_databuf A[14:14]c
                        .area func_lit(rom, con, rel, proclab)
 0000 0000      PL0:    .word 0
